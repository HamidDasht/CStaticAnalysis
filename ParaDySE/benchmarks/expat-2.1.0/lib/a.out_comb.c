/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 94 "expat_external.h"
typedef char XML_Char;
#line 95 "expat_external.h"
typedef char XML_LChar;
#line 107 "expat_external.h"
typedef long XML_Index;
#line 108 "expat_external.h"
typedef unsigned long XML_Size;
#line 24 "expat.h"
struct XML_ParserStruct ;
#line 25 "expat.h"
typedef struct XML_ParserStruct *XML_Parser;
#line 28 "expat.h"
typedef unsigned char XML_Bool;
#line 45
enum XML_Status {
    XML_STATUS_ERROR = 0,
    XML_STATUS_OK = 1,
    XML_STATUS_SUSPENDED = 2
} ;
#line 54
enum XML_Error {
    XML_ERROR_NONE = 0,
    XML_ERROR_NO_MEMORY = 1,
    XML_ERROR_SYNTAX = 2,
    XML_ERROR_NO_ELEMENTS = 3,
    XML_ERROR_INVALID_TOKEN = 4,
    XML_ERROR_UNCLOSED_TOKEN = 5,
    XML_ERROR_PARTIAL_CHAR = 6,
    XML_ERROR_TAG_MISMATCH = 7,
    XML_ERROR_DUPLICATE_ATTRIBUTE = 8,
    XML_ERROR_JUNK_AFTER_DOC_ELEMENT = 9,
    XML_ERROR_PARAM_ENTITY_REF = 10,
    XML_ERROR_UNDEFINED_ENTITY = 11,
    XML_ERROR_RECURSIVE_ENTITY_REF = 12,
    XML_ERROR_ASYNC_ENTITY = 13,
    XML_ERROR_BAD_CHAR_REF = 14,
    XML_ERROR_BINARY_ENTITY_REF = 15,
    XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF = 16,
    XML_ERROR_MISPLACED_XML_PI = 17,
    XML_ERROR_UNKNOWN_ENCODING = 18,
    XML_ERROR_INCORRECT_ENCODING = 19,
    XML_ERROR_UNCLOSED_CDATA_SECTION = 20,
    XML_ERROR_EXTERNAL_ENTITY_HANDLING = 21,
    XML_ERROR_NOT_STANDALONE = 22,
    XML_ERROR_UNEXPECTED_STATE = 23,
    XML_ERROR_ENTITY_DECLARED_IN_PE = 24,
    XML_ERROR_FEATURE_REQUIRES_XML_DTD = 25,
    XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING = 26,
    XML_ERROR_UNBOUND_PREFIX = 27,
    XML_ERROR_UNDECLARING_PREFIX = 28,
    XML_ERROR_INCOMPLETE_PE = 29,
    XML_ERROR_XML_DECL = 30,
    XML_ERROR_TEXT_DECL = 31,
    XML_ERROR_PUBLICID = 32,
    XML_ERROR_SUSPENDED = 33,
    XML_ERROR_NOT_SUSPENDED = 34,
    XML_ERROR_ABORTED = 35,
    XML_ERROR_FINISHED = 36,
    XML_ERROR_SUSPEND_PE = 37,
    XML_ERROR_RESERVED_PREFIX_XML = 38,
    XML_ERROR_RESERVED_PREFIX_XMLNS = 39,
    XML_ERROR_RESERVED_NAMESPACE_URI = 40
} ;
#line 101
enum XML_Content_Type {
    XML_CTYPE_EMPTY = 1,
    XML_CTYPE_ANY = 2,
    XML_CTYPE_MIXED = 3,
    XML_CTYPE_NAME = 4,
    XML_CTYPE_CHOICE = 5,
    XML_CTYPE_SEQ = 6
} ;
#line 110
enum XML_Content_Quant {
    XML_CQUANT_NONE = 0,
    XML_CQUANT_OPT = 1,
    XML_CQUANT_REP = 2,
    XML_CQUANT_PLUS = 3
} ;
#line 135
struct XML_cp ;
#line 135 "expat.h"
typedef struct XML_cp XML_Content;
#line 137 "expat.h"
struct XML_cp {
   enum XML_Content_Type type ;
   enum XML_Content_Quant quant ;
   XML_Char *name ;
   unsigned int numchildren ;
   XML_Content *children ;
};
#line 196 "expat.h"
struct __anonstruct_XML_Memory_Handling_Suite_1021999983 {
   void *(*malloc_fcn)(size_t size ) ;
   void *(*realloc_fcn)(void *ptr , size_t size ) ;
   void (*free_fcn)(void *ptr ) ;
};
#line 196 "expat.h"
typedef struct __anonstruct_XML_Memory_Handling_Suite_1021999983 XML_Memory_Handling_Suite;
#line 506 "expat.h"
struct __anonstruct_XML_Encoding_57076185 {
   int map[256] ;
   void *data ;
   int (*convert)(void *data , char const   *s ) ;
   void (*release)(void *data ) ;
};
#line 506 "expat.h"
typedef struct __anonstruct_XML_Encoding_57076185 XML_Encoding;
#line 835
enum XML_Parsing {
    XML_INITIALIZED = 0,
    XML_PARSING = 1,
    XML_FINISHED = 2,
    XML_SUSPENDED = 3
} ;
#line 842 "expat.h"
struct __anonstruct_XML_ParsingStatus_553604920 {
   enum XML_Parsing parsing ;
   XML_Bool finalBuffer ;
};
#line 842 "expat.h"
typedef struct __anonstruct_XML_ParsingStatus_553604920 XML_ParsingStatus;
#line 876
enum XML_ParamEntityParsing {
    XML_PARAM_ENTITY_PARSING_NEVER = 0,
    XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE = 1,
    XML_PARAM_ENTITY_PARSING_ALWAYS = 2
} ;
#line 996 "expat.h"
struct __anonstruct_XML_Expat_Version_582275743 {
   int major ;
   int minor ;
   int micro ;
};
#line 996 "expat.h"
typedef struct __anonstruct_XML_Expat_Version_582275743 XML_Expat_Version;
#line 1009
enum XML_FeatureEnum {
    XML_FEATURE_END = 0,
    XML_FEATURE_UNICODE = 1,
    XML_FEATURE_UNICODE_WCHAR_T = 2,
    XML_FEATURE_DTD = 3,
    XML_FEATURE_CONTEXT_BYTES = 4,
    XML_FEATURE_MIN_SIZE = 5,
    XML_FEATURE_SIZEOF_XML_CHAR = 6,
    XML_FEATURE_SIZEOF_XML_LCHAR = 7,
    XML_FEATURE_NS = 8,
    XML_FEATURE_LARGE_SIZE = 9,
    XML_FEATURE_ATTR_INFO = 10
} ;
#line 1024 "expat.h"
struct __anonstruct_XML_Feature_106251564 {
   enum XML_FeatureEnum feature ;
   XML_LChar const   *name ;
   long value ;
};
#line 1024 "expat.h"
typedef struct __anonstruct_XML_Feature_106251564 XML_Feature;
#line 45 "xmlparse.c"
typedef char ICHAR;
#line 112 "xmltok.h"
struct position {
   XML_Size lineNumber ;
   XML_Size columnNumber ;
};
#line 112 "xmltok.h"
typedef struct position POSITION;
#line 118 "xmltok.h"
struct __anonstruct_ATTRIBUTE_266818929 {
   char const   *name ;
   char const   *valuePtr ;
   char const   *valueEnd ;
   char normalized ;
};
#line 118 "xmltok.h"
typedef struct __anonstruct_ATTRIBUTE_266818929 ATTRIBUTE;
#line 125
struct encoding ;
#line 126 "xmltok.h"
typedef struct encoding ENCODING;
#line 128 "xmltok.h"
typedef int (*SCANNER)(ENCODING const   * , char const   * , char const   * , char const   ** );
#line 133 "xmltok.h"
struct encoding {
   SCANNER scanners[4] ;
   SCANNER literalScanners[2] ;
   int (*sameName)(ENCODING const   * , char const   * , char const   * ) ;
   int (*nameMatchesAscii)(ENCODING const   * , char const   * , char const   * ,
                           char const   * ) ;
   int (*nameLength)(ENCODING const   * , char const   * ) ;
   char const   *(*skipS)(ENCODING const   * , char const   * ) ;
   int (*getAtts)(ENCODING const   *enc , char const   *ptr , int attsMax , ATTRIBUTE *atts ) ;
   int (*charRefNumber)(ENCODING const   *enc , char const   *ptr ) ;
   int (*predefinedEntityName)(ENCODING const   * , char const   * , char const   * ) ;
   void (*updatePosition)(ENCODING const   * , char const   *ptr , char const   *end ,
                          POSITION * ) ;
   int (*isPublicId)(ENCODING const   *enc , char const   *ptr , char const   *end ,
                     char const   **badPtr ) ;
   void (*utf8Convert)(ENCODING const   *enc , char const   **fromP , char const   *fromLim ,
                       char **toP , char const   *toLim ) ;
   void (*utf16Convert)(ENCODING const   *enc , char const   **fromP , char const   *fromLim ,
                        unsigned short **toP , unsigned short const   *toLim ) ;
   int minBytesPerChar ;
   char isUtf8 ;
   char isUtf16 ;
};
#line 261 "xmltok.h"
struct __anonstruct_INIT_ENCODING_129800875 {
   ENCODING initEnc ;
   ENCODING const   **encPtr ;
};
#line 261 "xmltok.h"
typedef struct __anonstruct_INIT_ENCODING_129800875 INIT_ENCODING;
#line 87 "xmlrole.h"
struct prolog_state {
   int (*handler)(struct prolog_state *state , int tok , char const   *ptr , char const   *end ,
                  ENCODING const   *enc ) ;
   unsigned int level ;
   int role_none ;
   unsigned int includeLevel ;
   int documentEntity ;
   int inEntityValue ;
};
#line 87 "xmlrole.h"
typedef struct prolog_state PROLOG_STATE;
#line 92 "xmlparse.c"
typedef XML_Char const   *KEY;
#line 94 "xmlparse.c"
struct __anonstruct_NAMED_687056029 {
   KEY name ;
};
#line 94 "xmlparse.c"
typedef struct __anonstruct_NAMED_687056029 NAMED;
#line 98 "xmlparse.c"
struct __anonstruct_HASH_TABLE_294152293 {
   NAMED **v ;
   unsigned char power ;
   size_t size ;
   size_t used ;
   XML_Memory_Handling_Suite const   *mem ;
};
#line 98 "xmlparse.c"
typedef struct __anonstruct_HASH_TABLE_294152293 HASH_TABLE;
#line 131 "xmlparse.c"
struct __anonstruct_HASH_TABLE_ITER_15896500 {
   NAMED **p ;
   NAMED **end ;
};
#line 131 "xmlparse.c"
typedef struct __anonstruct_HASH_TABLE_ITER_15896500 HASH_TABLE_ITER;
#line 145
struct prefix ;
#line 145
struct attribute_id ;
#line 145 "xmlparse.c"
struct binding {
   struct prefix *prefix ;
   struct binding *nextTagBinding ;
   struct binding *prevPrefixBinding ;
   struct attribute_id  const  *attId ;
   XML_Char *uri ;
   int uriLen ;
   int uriAlloc ;
};
#line 145 "xmlparse.c"
typedef struct binding BINDING;
#line 155 "xmlparse.c"
struct prefix {
   XML_Char const   *name ;
   BINDING *binding ;
};
#line 155 "xmlparse.c"
typedef struct prefix PREFIX;
#line 160 "xmlparse.c"
struct __anonstruct_TAG_NAME_793067044 {
   XML_Char const   *str ;
   XML_Char const   *localPart ;
   XML_Char const   *prefix ;
   int strLen ;
   int uriLen ;
   int prefixLen ;
};
#line 160 "xmlparse.c"
typedef struct __anonstruct_TAG_NAME_793067044 TAG_NAME;
#line 182 "xmlparse.c"
struct tag {
   struct tag *parent ;
   char const   *rawName ;
   int rawNameLength ;
   TAG_NAME name ;
   char *buf ;
   char *bufEnd ;
   BINDING *bindings ;
};
#line 182 "xmlparse.c"
typedef struct tag TAG;
#line 192 "xmlparse.c"
struct __anonstruct_ENTITY_594465245 {
   XML_Char const   *name ;
   XML_Char const   *textPtr ;
   int textLen ;
   int processed ;
   XML_Char const   *systemId ;
   XML_Char const   *base ;
   XML_Char const   *publicId ;
   XML_Char const   *notation ;
   XML_Bool open ;
   XML_Bool is_param ;
   XML_Bool is_internal ;
};
#line 192 "xmlparse.c"
typedef struct __anonstruct_ENTITY_594465245 ENTITY;
#line 206 "xmlparse.c"
struct __anonstruct_CONTENT_SCAFFOLD_359432673 {
   enum XML_Content_Type type ;
   enum XML_Content_Quant quant ;
   XML_Char const   *name ;
   int firstchild ;
   int lastchild ;
   int childcnt ;
   int nextsib ;
};
#line 206 "xmlparse.c"
typedef struct __anonstruct_CONTENT_SCAFFOLD_359432673 CONTENT_SCAFFOLD;
#line 218 "xmlparse.c"
struct block {
   struct block *next ;
   int size ;
   XML_Char s[1] ;
};
#line 218 "xmlparse.c"
typedef struct block BLOCK;
#line 224 "xmlparse.c"
struct __anonstruct_STRING_POOL_617112616 {
   BLOCK *blocks ;
   BLOCK *freeBlocks ;
   XML_Char const   *end ;
   XML_Char *ptr ;
   XML_Char *start ;
   XML_Memory_Handling_Suite const   *mem ;
};
#line 224 "xmlparse.c"
typedef struct __anonstruct_STRING_POOL_617112616 STRING_POOL;
#line 235 "xmlparse.c"
struct attribute_id {
   XML_Char *name ;
   PREFIX *prefix ;
   XML_Bool maybeTokenized ;
   XML_Bool xmlns ;
};
#line 235 "xmlparse.c"
typedef struct attribute_id ATTRIBUTE_ID;
#line 242 "xmlparse.c"
struct __anonstruct_DEFAULT_ATTRIBUTE_986137207 {
   ATTRIBUTE_ID const   *id ;
   XML_Bool isCdata ;
   XML_Char const   *value ;
};
#line 242 "xmlparse.c"
typedef struct __anonstruct_DEFAULT_ATTRIBUTE_986137207 DEFAULT_ATTRIBUTE;
#line 248 "xmlparse.c"
struct __anonstruct_NS_ATT_43716280 {
   unsigned long version ;
   unsigned long hash ;
   XML_Char const   *uriName ;
};
#line 248 "xmlparse.c"
typedef struct __anonstruct_NS_ATT_43716280 NS_ATT;
#line 254 "xmlparse.c"
struct __anonstruct_ELEMENT_TYPE_58712390 {
   XML_Char const   *name ;
   PREFIX *prefix ;
   ATTRIBUTE_ID const   *idAtt ;
   int nDefaultAtts ;
   int allocDefaultAtts ;
   DEFAULT_ATTRIBUTE *defaultAtts ;
};
#line 254 "xmlparse.c"
typedef struct __anonstruct_ELEMENT_TYPE_58712390 ELEMENT_TYPE;
#line 263 "xmlparse.c"
struct __anonstruct_DTD_394863310 {
   HASH_TABLE generalEntities ;
   HASH_TABLE elementTypes ;
   HASH_TABLE attributeIds ;
   HASH_TABLE prefixes ;
   STRING_POOL pool ;
   STRING_POOL entityValuePool ;
   XML_Bool keepProcessing ;
   XML_Bool hasParamEntityRefs ;
   XML_Bool standalone ;
   XML_Bool paramEntityRead ;
   HASH_TABLE paramEntities ;
   PREFIX defaultPrefix ;
   XML_Bool in_eldecl ;
   CONTENT_SCAFFOLD *scaffold ;
   unsigned int contentStringLen ;
   unsigned int scaffSize ;
   unsigned int scaffCount ;
   int scaffLevel ;
   int *scaffIndex ;
};
#line 263 "xmlparse.c"
typedef struct __anonstruct_DTD_394863310 DTD;
#line 292 "xmlparse.c"
struct open_internal_entity {
   char const   *internalEventPtr ;
   char const   *internalEventEndPtr ;
   struct open_internal_entity *next ;
   ENTITY *entity ;
   int startTagLevel ;
   XML_Bool betweenDecl ;
};
#line 292 "xmlparse.c"
typedef struct open_internal_entity OPEN_INTERNAL_ENTITY;
#line 301 "xmlparse.c"
typedef enum XML_Error Processor(XML_Parser parser , char const   *start , char const   *end ,
                                 char const   **endPtr );
#line 460 "xmlparse.c"
struct XML_ParserStruct {
   void *m_userData ;
   void *m_handlerArg ;
   char *m_buffer ;
   XML_Memory_Handling_Suite const   m_mem ;
   char const   *m_bufferPtr ;
   char *m_bufferEnd ;
   char const   *m_bufferLim ;
   XML_Index m_parseEndByteIndex ;
   char const   *m_parseEndPtr ;
   XML_Char *m_dataBuf ;
   XML_Char *m_dataBufEnd ;
   void (*m_startElementHandler)(void *userData , XML_Char const   *name , XML_Char const   **atts ) ;
   void (*m_endElementHandler)(void *userData , XML_Char const   *name ) ;
   void (*m_characterDataHandler)(void *userData , XML_Char const   *s , int len ) ;
   void (*m_processingInstructionHandler)(void *userData , XML_Char const   *target ,
                                          XML_Char const   *data ) ;
   void (*m_commentHandler)(void *userData , XML_Char const   *data ) ;
   void (*m_startCdataSectionHandler)(void *userData ) ;
   void (*m_endCdataSectionHandler)(void *userData ) ;
   void (*m_defaultHandler)(void *userData , XML_Char const   *s , int len ) ;
   void (*m_startDoctypeDeclHandler)(void *userData , XML_Char const   *doctypeName ,
                                     XML_Char const   *sysid , XML_Char const   *pubid ,
                                     int has_internal_subset ) ;
   void (*m_endDoctypeDeclHandler)(void *userData ) ;
   void (*m_unparsedEntityDeclHandler)(void *userData , XML_Char const   *entityName ,
                                       XML_Char const   *base , XML_Char const   *systemId ,
                                       XML_Char const   *publicId , XML_Char const   *notationName ) ;
   void (*m_notationDeclHandler)(void *userData , XML_Char const   *notationName ,
                                 XML_Char const   *base , XML_Char const   *systemId ,
                                 XML_Char const   *publicId ) ;
   void (*m_startNamespaceDeclHandler)(void *userData , XML_Char const   *prefix ,
                                       XML_Char const   *uri ) ;
   void (*m_endNamespaceDeclHandler)(void *userData , XML_Char const   *prefix ) ;
   int (*m_notStandaloneHandler)(void *userData ) ;
   int (*m_externalEntityRefHandler)(XML_Parser parser , XML_Char const   *context ,
                                     XML_Char const   *base , XML_Char const   *systemId ,
                                     XML_Char const   *publicId ) ;
   XML_Parser m_externalEntityRefHandlerArg ;
   void (*m_skippedEntityHandler)(void *userData , XML_Char const   *entityName ,
                                  int is_parameter_entity ) ;
   int (*m_unknownEncodingHandler)(void *encodingHandlerData , XML_Char const   *name ,
                                   XML_Encoding *info ) ;
   void (*m_elementDeclHandler)(void *userData , XML_Char const   *name , XML_Content *model ) ;
   void (*m_attlistDeclHandler)(void *userData , XML_Char const   *elname , XML_Char const   *attname ,
                                XML_Char const   *att_type , XML_Char const   *dflt ,
                                int isrequired ) ;
   void (*m_entityDeclHandler)(void *userData , XML_Char const   *entityName , int is_parameter_entity ,
                               XML_Char const   *value , int value_length , XML_Char const   *base ,
                               XML_Char const   *systemId , XML_Char const   *publicId ,
                               XML_Char const   *notationName ) ;
   void (*m_xmlDeclHandler)(void *userData , XML_Char const   *version , XML_Char const   *encoding ,
                            int standalone ) ;
   ENCODING const   *m_encoding ;
   INIT_ENCODING m_initEncoding ;
   ENCODING const   *m_internalEncoding ;
   XML_Char const   *m_protocolEncodingName ;
   XML_Bool m_ns ;
   XML_Bool m_ns_triplets ;
   void *m_unknownEncodingMem ;
   void *m_unknownEncodingData ;
   void *m_unknownEncodingHandlerData ;
   void (*m_unknownEncodingRelease)(void * ) ;
   PROLOG_STATE m_prologState ;
   Processor *m_processor ;
   enum XML_Error m_errorCode ;
   char const   *m_eventPtr ;
   char const   *m_eventEndPtr ;
   char const   *m_positionPtr ;
   OPEN_INTERNAL_ENTITY *m_openInternalEntities ;
   OPEN_INTERNAL_ENTITY *m_freeInternalEntities ;
   XML_Bool m_defaultExpandInternalEntities ;
   int m_tagLevel ;
   ENTITY *m_declEntity ;
   XML_Char const   *m_doctypeName ;
   XML_Char const   *m_doctypeSysid ;
   XML_Char const   *m_doctypePubid ;
   XML_Char const   *m_declAttributeType ;
   XML_Char const   *m_declNotationName ;
   XML_Char const   *m_declNotationPublicId ;
   ELEMENT_TYPE *m_declElementType ;
   ATTRIBUTE_ID *m_declAttributeId ;
   XML_Bool m_declAttributeIsCdata ;
   XML_Bool m_declAttributeIsId ;
   DTD *m_dtd ;
   XML_Char const   *m_curBase ;
   TAG *m_tagStack ;
   TAG *m_freeTagList ;
   BINDING *m_inheritedBindings ;
   BINDING *m_freeBindingList ;
   int m_attsSize ;
   int m_nSpecifiedAtts ;
   int m_idAttIndex ;
   ATTRIBUTE *m_atts ;
   NS_ATT *m_nsAtts ;
   unsigned long m_nsAttsVersion ;
   unsigned char m_nsAttsPower ;
   POSITION m_position ;
   STRING_POOL m_tempPool ;
   STRING_POOL m_temp2Pool ;
   char *m_groupConnector ;
   unsigned int m_groupSize ;
   XML_Char m_namespaceSeparator ;
   XML_Parser m_parentParser ;
   XML_ParsingStatus m_parsingStatus ;
   XML_Bool m_isParamEntity ;
   XML_Bool m_useForeignDTD ;
   enum XML_ParamEntityParsing m_paramEntityParsing ;
   unsigned long m_hash_secret_salt ;
};
#line 176 "xmltok.c"
struct normal_encoding {
   ENCODING enc ;
   unsigned char type[256] ;
   int (*isName2)(ENCODING const   * , char const   * ) ;
   int (*isName3)(ENCODING const   * , char const   * ) ;
   int (*isName4)(ENCODING const   * , char const   * ) ;
   int (*isNmstrt2)(ENCODING const   * , char const   * ) ;
   int (*isNmstrt3)(ENCODING const   * , char const   * ) ;
   int (*isNmstrt4)(ENCODING const   * , char const   * ) ;
   int (*isInvalid2)(ENCODING const   * , char const   * ) ;
   int (*isInvalid3)(ENCODING const   * , char const   * ) ;
   int (*isInvalid4)(ENCODING const   * , char const   * ) ;
};
#line 1434 "xmltok_impl.c"
enum __anonenum_state_81194955 {
    other = 0,
    inName = 1,
    inValue = 2
} ;
#line 1434
enum __anonenum_state_1045544529 {
    other___0 = 0,
    inName___0 = 1,
    inValue___0 = 2
} ;
#line 1434
enum __anonenum_state_1045544530 {
    other___1 = 0,
    inName___1 = 1,
    inValue___1 = 2
} ;
#line 1247 "xmltok.c"
struct unknown_encoding {
   struct normal_encoding normal ;
   int (*convert)(void *userData , char const   *p ) ;
   void *userData ;
   unsigned short utf16[256] ;
   char utf8[256][4] ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE ;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 150 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 156 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 241 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 1 "xmlparse.o"
#pragma merger("0","./xmlparse.i","-std=gnu99,-g,-O0,-Wall,-Wmissing-prototypes,-Wstrict-prototypes,-fexceptions")
#line 200 "../../../include/crest.h"
extern void __CrestChar(char *x )  __attribute__((__crest_skip__)) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 62
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 65
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *Ptr1 ,
                                                                                        void const   *Ptr2 ,
                                                                                        size_t Count )  __attribute__((__pure__)) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 154 "expat.h"
void XML_SetElementDeclHandler(XML_Parser parser , void (*eldecl)(void *userData ,
                                                                  XML_Char const   *name ,
                                                                  XML_Content *model ) ) ;
#line 174
void XML_SetAttlistDeclHandler(XML_Parser parser , void (*attdecl)(void *userData ,
                                                                   XML_Char const   *elname ,
                                                                   XML_Char const   *attname ,
                                                                   XML_Char const   *att_type ,
                                                                   XML_Char const   *dflt ,
                                                                   int isrequired ) ) ;
#line 191
void XML_SetXmlDeclHandler(XML_Parser parser , void (*handler)(void *userData , XML_Char const   *version ,
                                                               XML_Char const   *encoding ,
                                                               int standalone ) ) ;
#line 205
XML_Parser XML_ParserCreate(XML_Char const   *encodingName ) ;
#line 219
XML_Parser XML_ParserCreateNS(XML_Char const   *encodingName , XML_Char nsSep ) ;
#line 232
XML_Parser XML_ParserCreate_MM(XML_Char const   *encodingName , XML_Memory_Handling_Suite const   *memsuite ,
                               XML_Char const   *nameSep ) ;
#line 246
XML_Bool XML_ParserReset(XML_Parser parser , XML_Char const   *encodingName ) ;
#line 340
void XML_SetEntityDeclHandler(XML_Parser parser , void (*handler)(void *userData ,
                                                                  XML_Char const   *entityName ,
                                                                  int is_parameter_entity ,
                                                                  XML_Char const   *value ,
                                                                  int value_length ,
                                                                  XML_Char const   *base ,
                                                                  XML_Char const   *systemId ,
                                                                  XML_Char const   *publicId ,
                                                                  XML_Char const   *notationName ) ) ;
#line 533
void XML_SetElementHandler(XML_Parser parser , void (*start)(void *userData , XML_Char const   *name ,
                                                             XML_Char const   **atts ) ,
                           void (*end)(void *userData , XML_Char const   *name ) ) ;
#line 538
void XML_SetStartElementHandler(XML_Parser parser , void (*start)(void *userData ,
                                                                  XML_Char const   *name ,
                                                                  XML_Char const   **atts ) ) ;
#line 542
void XML_SetEndElementHandler(XML_Parser parser , void (*end)(void *userData , XML_Char const   *name ) ) ;
#line 546
void XML_SetCharacterDataHandler(XML_Parser parser , void (*handler)(void *userData ,
                                                                     XML_Char const   *s ,
                                                                     int len ) ) ;
#line 550
void XML_SetProcessingInstructionHandler(XML_Parser parser , void (*handler)(void *userData ,
                                                                             XML_Char const   *target ,
                                                                             XML_Char const   *data ) ) ;
#line 553
void XML_SetCommentHandler(XML_Parser parser , void (*handler)(void *userData , XML_Char const   *data ) ) ;
#line 557
void XML_SetCdataSectionHandler(XML_Parser parser , void (*start)(void *userData ) ,
                                void (*end)(void *userData ) ) ;
#line 562
void XML_SetStartCdataSectionHandler(XML_Parser parser , void (*start)(void *userData ) ) ;
#line 566
void XML_SetEndCdataSectionHandler(XML_Parser parser , void (*end)(void *userData ) ) ;
#line 574
void XML_SetDefaultHandler(XML_Parser parser , void (*handler)(void *userData , XML_Char const   *s ,
                                                               int len ) ) ;
#line 582
void XML_SetDefaultHandlerExpand(XML_Parser parser , void (*handler)(void *userData ,
                                                                     XML_Char const   *s ,
                                                                     int len ) ) ;
#line 586
void XML_SetDoctypeDeclHandler(XML_Parser parser , void (*start)(void *userData ,
                                                                 XML_Char const   *doctypeName ,
                                                                 XML_Char const   *sysid ,
                                                                 XML_Char const   *pubid ,
                                                                 int has_internal_subset ) ,
                               void (*end)(void *userData ) ) ;
#line 591
void XML_SetStartDoctypeDeclHandler(XML_Parser parser , void (*start)(void *userData ,
                                                                      XML_Char const   *doctypeName ,
                                                                      XML_Char const   *sysid ,
                                                                      XML_Char const   *pubid ,
                                                                      int has_internal_subset ) ) ;
#line 595
void XML_SetEndDoctypeDeclHandler(XML_Parser parser , void (*end)(void *userData ) ) ;
#line 599
void XML_SetUnparsedEntityDeclHandler(XML_Parser parser , void (*handler)(void *userData ,
                                                                          XML_Char const   *entityName ,
                                                                          XML_Char const   *base ,
                                                                          XML_Char const   *systemId ,
                                                                          XML_Char const   *publicId ,
                                                                          XML_Char const   *notationName ) ) ;
#line 603
void XML_SetNotationDeclHandler(XML_Parser parser , void (*handler)(void *userData ,
                                                                    XML_Char const   *notationName ,
                                                                    XML_Char const   *base ,
                                                                    XML_Char const   *systemId ,
                                                                    XML_Char const   *publicId ) ) ;
#line 607
void XML_SetNamespaceDeclHandler(XML_Parser parser , void (*start)(void *userData ,
                                                                   XML_Char const   *prefix ,
                                                                   XML_Char const   *uri ) ,
                                 void (*end)(void *userData , XML_Char const   *prefix ) ) ;
#line 612
void XML_SetStartNamespaceDeclHandler(XML_Parser parser , void (*start)(void *userData ,
                                                                        XML_Char const   *prefix ,
                                                                        XML_Char const   *uri ) ) ;
#line 616
void XML_SetEndNamespaceDeclHandler(XML_Parser parser , void (*end)(void *userData ,
                                                                    XML_Char const   *prefix ) ) ;
#line 620
void XML_SetNotStandaloneHandler(XML_Parser parser , int (*handler)(void *userData ) ) ;
#line 624
void XML_SetExternalEntityRefHandler(XML_Parser parser , int (*handler)(XML_Parser parser ,
                                                                        XML_Char const   *context ,
                                                                        XML_Char const   *base ,
                                                                        XML_Char const   *systemId ,
                                                                        XML_Char const   *publicId ) ) ;
#line 632
void XML_SetExternalEntityRefHandlerArg(XML_Parser parser , void *arg ) ;
#line 636
void XML_SetSkippedEntityHandler(XML_Parser parser , void (*handler)(void *userData ,
                                                                     XML_Char const   *entityName ,
                                                                     int is_parameter_entity ) ) ;
#line 640
void XML_SetUnknownEncodingHandler(XML_Parser parser , int (*handler)(void *encodingHandlerData ,
                                                                      XML_Char const   *name ,
                                                                      XML_Encoding *info ) ,
                                   void *data ) ;
#line 649
void XML_DefaultCurrent(XML_Parser parser ) ;
#line 666
void XML_SetReturnNSTriplet(XML_Parser parser , int do_nst ) ;
#line 670
void XML_SetUserData(XML_Parser parser , void *p ) ;
#line 682
enum XML_Status XML_SetEncoding(XML_Parser parser , XML_Char const   *encodingName ) ;
#line 689
void XML_UseParserAsHandlerArg(XML_Parser parser ) ;
#line 710
enum XML_Error XML_UseForeignDTD(XML_Parser parser , XML_Bool useDTD ) ;
#line 722
enum XML_Status XML_SetBase(XML_Parser parser , XML_Char const   *p ) ;
#line 725
XML_Char const   *XML_GetBase(XML_Parser parser ) ;
#line 734
int XML_GetSpecifiedAttributeCount(XML_Parser parser ) ;
#line 742
int XML_GetIdAttributeIndex(XML_Parser parser ) ;
#line 777
enum XML_Status XML_Parse(XML_Parser parser , char const   *s , int len , int isFinal ) ;
#line 780
void *XML_GetBuffer(XML_Parser parser , int len ) ;
#line 783
enum XML_Status XML_ParseBuffer(XML_Parser parser , int len , int isFinal ) ;
#line 817
enum XML_Status XML_StopParser(XML_Parser parser , XML_Bool resumable ) ;
#line 832
enum XML_Status XML_ResumeParser(XML_Parser parser ) ;
#line 852
void XML_GetParsingStatus(XML_Parser parser , XML_ParsingStatus *status ) ;
#line 871
XML_Parser XML_ExternalEntityParserCreate(XML_Parser oldParser , XML_Char const   *context ,
                                          XML_Char const   *encodingName ) ;
#line 905
int XML_SetParamEntityParsing(XML_Parser parser , enum XML_ParamEntityParsing peParsing ) ;
#line 914
int XML_SetHashSalt(XML_Parser parser , unsigned long hash_salt ) ;
#line 921
enum XML_Error XML_GetErrorCode(XML_Parser parser ) ;
#line 940
XML_Size XML_GetCurrentLineNumber(XML_Parser parser ) ;
#line 941
XML_Size XML_GetCurrentColumnNumber(XML_Parser parser ) ;
#line 942
XML_Index XML_GetCurrentByteIndex(XML_Parser parser ) ;
#line 947
int XML_GetCurrentByteCount(XML_Parser parser ) ;
#line 960
char const   *XML_GetInputContext(XML_Parser parser , int *offset , int *size ) ;
#line 971
void XML_FreeContentModel(XML_Parser parser , XML_Content *model ) ;
#line 975
void *XML_MemMalloc(XML_Parser parser , size_t size ) ;
#line 978
void *XML_MemRealloc(XML_Parser parser , void *ptr , size_t size ) ;
#line 981
void XML_MemFree(XML_Parser parser , void *ptr ) ;
#line 985
void XML_ParserFree(XML_Parser parser ) ;
#line 989
XML_LChar const   *XML_ErrorString(enum XML_Error code ) ;
#line 993
XML_LChar const   *XML_ExpatVersion(void) ;
#line 1005
XML_Expat_Version XML_ExpatVersionInfo(void) ;
#line 1030
XML_Feature const   *XML_GetFeatureList(void) ;
#line 266 "xmltok.h"
int XmlParseXmlDecl(int isGeneralTextEntity , ENCODING const   *enc , char const   *ptr ,
                    char const   *end , char const   **badPtr , char const   **versionPtr ,
                    char const   **versionEndPtr , char const   **encodingName , ENCODING const   **encoding ,
                    int *standalone ) ;
#line 277
int XmlInitEncoding(INIT_ENCODING *p , ENCODING const   **encPtr , char const   *name ) ;
#line 278
ENCODING const   *XmlGetUtf8InternalEncoding(void) ;
#line 280
int XmlUtf8Encode(int c , char *buf ) ;
#line 282
int XmlSizeOfUnknownEncoding(void) ;
#line 287
ENCODING *XmlInitUnknownEncoding(void *mem , int *table , int (*convert)(void *userData ,
                                                                         char const   *p ) ,
                                 void *userData ) ;
#line 293
int XmlParseXmlDeclNS(int isGeneralTextEntity , ENCODING const   *enc , char const   *ptr ,
                      char const   *end , char const   **badPtr , char const   **versionPtr ,
                      char const   **versionEndPtr , char const   **encodingName ,
                      ENCODING const   **encoding , int *standalone ) ;
#line 304
int XmlInitEncodingNS(INIT_ENCODING *p , ENCODING const   **encPtr , char const   *name ) ;
#line 305
ENCODING const   *XmlGetUtf8InternalEncodingNS(void) ;
#line 307
ENCODING *XmlInitUnknownEncodingNS(void *mem , int *table , int (*convert)(void *userData ,
                                                                           char const   *p ) ,
                                   void *userData ) ;
#line 102 "xmlrole.h"
void XmlPrologStateInit(PROLOG_STATE *state ) ;
#line 104
void XmlPrologStateInitExternalEntity(PROLOG_STATE *state ) ;
#line 306 "xmlparse.c"
static enum XML_Error prologProcessor(XML_Parser parser , char const   *s , char const   *end ,
                                      char const   **nextPtr ) ;
#line 307
static enum XML_Error prologInitProcessor(XML_Parser parser , char const   *s , char const   *end ,
                                          char const   **nextPtr ) ;
#line 308
static enum XML_Error contentProcessor(XML_Parser parser , char const   *start , char const   *end ,
                                       char const   **endPtr ) ;
#line 309
static enum XML_Error cdataSectionProcessor(XML_Parser parser , char const   *start ,
                                            char const   *end , char const   **endPtr ) ;
#line 311
static enum XML_Error ignoreSectionProcessor(XML_Parser parser , char const   *start ,
                                             char const   *end , char const   **endPtr ) ;
#line 312
static enum XML_Error externalParEntProcessor(XML_Parser parser , char const   *s ,
                                              char const   *end , char const   **nextPtr ) ;
#line 313
static enum XML_Error externalParEntInitProcessor(XML_Parser parser , char const   *s ,
                                                  char const   *end , char const   **nextPtr ) ;
#line 314
static enum XML_Error entityValueProcessor(XML_Parser parser , char const   *s , char const   *end ,
                                           char const   **nextPtr ) ;
#line 315
static enum XML_Error entityValueInitProcessor(XML_Parser parser , char const   *s ,
                                               char const   *end , char const   **nextPtr ) ;
#line 317
static enum XML_Error epilogProcessor(XML_Parser parser , char const   *s , char const   *end ,
                                      char const   **nextPtr ) ;
#line 318
static enum XML_Error errorProcessor(XML_Parser parser , char const   *s , char const   *end ,
                                     char const   **nextPtr ) ;
#line 319
static enum XML_Error externalEntityInitProcessor(XML_Parser parser , char const   *start ,
                                                  char const   *end , char const   **endPtr ) ;
#line 320
static enum XML_Error externalEntityInitProcessor2(XML_Parser parser , char const   *start ,
                                                   char const   *end , char const   **endPtr ) ;
#line 321
static enum XML_Error externalEntityInitProcessor3(XML_Parser parser , char const   *start ,
                                                   char const   *end , char const   **endPtr ) ;
#line 322
static enum XML_Error externalEntityContentProcessor(XML_Parser parser , char const   *start ,
                                                     char const   *end , char const   **endPtr ) ;
#line 323
static enum XML_Error internalEntityProcessor(XML_Parser parser , char const   *s ,
                                              char const   *end , char const   **nextPtr ) ;
#line 325
static enum XML_Error handleUnknownEncoding(XML_Parser parser , XML_Char const   *encodingName ) ;
#line 327
static enum XML_Error processXmlDecl(XML_Parser parser , int isGeneralTextEntity ,
                                     char const   *s , char const   *next ) ;
#line 330
static enum XML_Error initializeEncoding(XML_Parser parser ) ;
#line 332
static enum XML_Error doProlog(XML_Parser parser , ENCODING const   *enc , char const   *s ,
                               char const   *end , int tok , char const   *next ,
                               char const   **nextPtr , XML_Bool haveMore ) ;
#line 336
static enum XML_Error processInternalEntity(XML_Parser parser , ENTITY *entity , XML_Bool betweenDecl ) ;
#line 339
static enum XML_Error doContent(XML_Parser parser , int startTagLevel , ENCODING const   *enc ,
                                char const   *s , char const   *end , char const   **nextPtr ,
                                XML_Bool haveMore ) ;
#line 343
static enum XML_Error doCdataSection(XML_Parser parser , ENCODING const   *enc , char const   **startPtr ,
                                     char const   *end , char const   **nextPtr ,
                                     XML_Bool haveMore ) ;
#line 347
static enum XML_Error doIgnoreSection(XML_Parser parser , ENCODING const   *enc ,
                                      char const   **startPtr , char const   *end ,
                                      char const   **nextPtr , XML_Bool haveMore ) ;
#line 352
static enum XML_Error storeAtts(XML_Parser parser , ENCODING const   *enc , char const   *attStr ,
                                TAG_NAME *tagNamePtr , BINDING **bindingsPtr ) ;
#line 355
static enum XML_Error addBinding(XML_Parser parser , PREFIX *prefix , ATTRIBUTE_ID const   *attId ,
                                 XML_Char const   *uri , BINDING **bindingsPtr ) ;
#line 358
static int defineAttribute(ELEMENT_TYPE *type , ATTRIBUTE_ID *attId , XML_Bool isCdata ,
                           XML_Bool isId , XML_Char const   *value , XML_Parser parser ) ;
#line 361
static enum XML_Error storeAttributeValue(XML_Parser parser , ENCODING const   *enc ,
                                          XML_Bool isCdata , char const   *ptr , char const   *end ,
                                          STRING_POOL *pool ) ;
#line 364
static enum XML_Error appendAttributeValue(XML_Parser parser , ENCODING const   *enc ,
                                           XML_Bool isCdata , char const   *ptr ,
                                           char const   *end , STRING_POOL *pool ) ;
#line 367
static ATTRIBUTE_ID *getAttributeId(XML_Parser parser , ENCODING const   *enc , char const   *start ,
                                    char const   *end ) ;
#line 370
static int setElementTypePrefix(XML_Parser parser , ELEMENT_TYPE *elementType ) ;
#line 372
static enum XML_Error storeEntityValue(XML_Parser parser , ENCODING const   *enc ,
                                       char const   *entityTextPtr , char const   *entityTextEnd ) ;
#line 375
static int reportProcessingInstruction(XML_Parser parser , ENCODING const   *enc ,
                                       char const   *start , char const   *end ) ;
#line 378
static int reportComment(XML_Parser parser , ENCODING const   *enc , char const   *start ,
                         char const   *end ) ;
#line 381
static void reportDefault(XML_Parser parser , ENCODING const   *enc , char const   *s ,
                          char const   *end ) ;
#line 385
static XML_Char const   *getContext(XML_Parser parser ) ;
#line 386
static XML_Bool setContext(XML_Parser parser , XML_Char const   *context ) ;
#line 389
static void normalizePublicId(XML_Char *publicId ) ;
#line 391
static DTD *dtdCreate(XML_Memory_Handling_Suite const   *ms ) ;
#line 393
static void dtdReset(DTD *p , XML_Memory_Handling_Suite const   *ms ) ;
#line 394
static void dtdDestroy(DTD *p , XML_Bool isDocEntity , XML_Memory_Handling_Suite const   *ms ) ;
#line 396
static int dtdCopy(XML_Parser oldParser , DTD *newDtd , DTD const   *oldDtd , XML_Memory_Handling_Suite const   *ms ) ;
#line 399
static int copyEntityTable(XML_Parser oldParser , HASH_TABLE *newTable , STRING_POOL *newPool ,
                           HASH_TABLE const   *oldTable ) ;
#line 402
static NAMED *lookup(XML_Parser parser , HASH_TABLE *table , KEY name , size_t createSize ) ;
#line 404
static void hashTableInit(HASH_TABLE *p , XML_Memory_Handling_Suite const   *ms ) ;
#line 406
static void hashTableClear(HASH_TABLE *table ) ;
#line 407
static void hashTableDestroy(HASH_TABLE *table ) ;
#line 408
static void hashTableIterInit(HASH_TABLE_ITER *iter , HASH_TABLE const   *table ) ;
#line 410
static NAMED *hashTableIterNext(HASH_TABLE_ITER *iter ) ;
#line 412
static void poolInit(STRING_POOL *pool , XML_Memory_Handling_Suite const   *ms ) ;
#line 414
static void poolClear(STRING_POOL *pool ) ;
#line 415
static void poolDestroy(STRING_POOL *pool ) ;
#line 416
static XML_Char *poolAppend(STRING_POOL *pool , ENCODING const   *enc , char const   *ptr ,
                            char const   *end ) ;
#line 419
static XML_Char *poolStoreString(STRING_POOL *pool , ENCODING const   *enc , char const   *ptr ,
                                 char const   *end ) ;
#line 422
static XML_Bool poolGrow(STRING_POOL *pool ) ;
#line 423
static XML_Char const   *poolCopyString(STRING_POOL *pool , XML_Char const   *s ) ;
#line 425
static XML_Char const   *poolCopyStringN(STRING_POOL *pool , XML_Char const   *s ,
                                         int n ) ;
#line 427
static XML_Char const   *poolAppendString(STRING_POOL *pool , XML_Char const   *s ) ;
#line 430
static int nextScaffoldPart(XML_Parser parser ) ;
#line 431
static XML_Content *build_model(XML_Parser parser ) ;
#line 432
static ELEMENT_TYPE *getElementType(XML_Parser parser , ENCODING const   *enc , char const   *ptr ,
                                    char const   *end ) ;
#line 436
static unsigned long generate_hash_secret_salt(void) ;
#line 437
static XML_Bool startParsing(XML_Parser parser ) ;
#line 439
static XML_Parser parserCreate(XML_Char const   *encodingName , XML_Memory_Handling_Suite const   *memsuite ,
                               XML_Char const   *nameSep , DTD *dtd ) ;
#line 445
static void parserInit(XML_Parser parser , XML_Char const   *encodingName ) ;
#line 671 "xmlparse.c"
XML_Parser XML_ParserCreate(XML_Char const   *encodingName ) 
{ 
  XML_Parser tmp ;

  {
#line 674
  tmp = XML_ParserCreate_MM(encodingName, (XML_Memory_Handling_Suite const   *)((void *)0),
                            (XML_Char const   *)((void *)0));
#line 674
  return (tmp);
}
}
#line 677 "xmlparse.c"
XML_Parser XML_ParserCreateNS(XML_Char const   *encodingName , XML_Char nsSep ) 
{ 
  XML_Char tmp[2] ;
  XML_Parser tmp___0 ;

  {
#line 681
  tmp[0] = nsSep;
#line 682
  tmp___0 = XML_ParserCreate_MM(encodingName, (XML_Memory_Handling_Suite const   *)((void *)0),
                                (XML_Char const   *)(tmp));
#line 682
  return (tmp___0);
}
}
#line 685 "xmlparse.c"
static XML_Char const   implicitContext[41]  = 
#line 685
  {      (XML_Char const   )120,      (XML_Char const   )109,      (XML_Char const   )108,      (XML_Char const   )61, 
        (XML_Char const   )104,      (XML_Char const   )116,      (XML_Char const   )116,      (XML_Char const   )112, 
        (XML_Char const   )58,      (XML_Char const   )47,      (XML_Char const   )47,      (XML_Char const   )119, 
        (XML_Char const   )119,      (XML_Char const   )119,      (XML_Char const   )46,      (XML_Char const   )119, 
        (XML_Char const   )51,      (XML_Char const   )46,      (XML_Char const   )111,      (XML_Char const   )114, 
        (XML_Char const   )103,      (XML_Char const   )47,      (XML_Char const   )88,      (XML_Char const   )77, 
        (XML_Char const   )76,      (XML_Char const   )47,      (XML_Char const   )49,      (XML_Char const   )57, 
        (XML_Char const   )57,      (XML_Char const   )56,      (XML_Char const   )47,      (XML_Char const   )110, 
        (XML_Char const   )97,      (XML_Char const   )109,      (XML_Char const   )101,      (XML_Char const   )115, 
        (XML_Char const   )112,      (XML_Char const   )97,      (XML_Char const   )99,      (XML_Char const   )101, 
        (XML_Char const   )'\000'};
#line 694 "xmlparse.c"
static unsigned long generate_hash_secret_salt(void) 
{ 
  unsigned int seed ;
  time_t tmp ;
  int tmp___0 ;

  {
#line 697
  tmp = time((time_t *)((void *)0));
#line 697
  seed = (unsigned int )(tmp % 4294967295L);
#line 698
  srand(seed);
#line 699
  tmp___0 = rand();
#line 699
  return ((unsigned long )tmp___0);
}
}
#line 702 "xmlparse.c"
static XML_Bool startParsing(XML_Parser parser ) 
{ 
  XML_Bool tmp ;

  {
#line 706
  if (parser->m_hash_secret_salt == 0UL) {
#line 707
    parser->m_hash_secret_salt = generate_hash_secret_salt();
  }
#line 708
  if (parser->m_ns) {
#line 712
    tmp = setContext(parser, implicitContext);
#line 712
    return (tmp);
  }
#line 714
  return ((XML_Bool )1);
}
}
#line 717 "xmlparse.c"
XML_Parser XML_ParserCreate_MM(XML_Char const   *encodingName , XML_Memory_Handling_Suite const   *memsuite ,
                               XML_Char const   *nameSep ) 
{ 
  XML_Parser tmp ;

  {
#line 722
  tmp = parserCreate(encodingName, memsuite, nameSep, (DTD *)((void *)0));
#line 722
  return (tmp);
}
}
#line 725 "xmlparse.c"
static XML_Parser parserCreate(XML_Char const   *encodingName , XML_Memory_Handling_Suite const   *memsuite ,
                               XML_Char const   *nameSep , DTD *dtd ) 
{ 
  XML_Parser parser ;
  XML_Memory_Handling_Suite *mtemp ;
  void *tmp ;
  XML_Memory_Handling_Suite *mtemp___0 ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 733
  if (memsuite) {
#line 735
    tmp = (*(memsuite->malloc_fcn))(sizeof(struct XML_ParserStruct ));
#line 735
    parser = (XML_Parser )tmp;
#line 737
    if ((unsigned long )parser != (unsigned long )((void *)0)) {
#line 738
      mtemp = (XML_Memory_Handling_Suite *)(& parser->m_mem);
#line 739
      mtemp->malloc_fcn = (void *(*)(size_t size ))memsuite->malloc_fcn;
#line 740
      mtemp->realloc_fcn = (void *(*)(void *ptr , size_t size ))memsuite->realloc_fcn;
#line 741
      mtemp->free_fcn = (void (*)(void *ptr ))memsuite->free_fcn;
    }
  } else {
#line 746
    tmp___0 = malloc(sizeof(struct XML_ParserStruct ));
#line 746
    parser = (XML_Parser )tmp___0;
#line 747
    if ((unsigned long )parser != (unsigned long )((void *)0)) {
#line 748
      mtemp___0 = (XML_Memory_Handling_Suite *)(& parser->m_mem);
#line 749
      mtemp___0->malloc_fcn = (void *(*)(size_t size ))(& malloc);
#line 750
      mtemp___0->realloc_fcn = (void *(*)(void *ptr , size_t size ))(& realloc);
#line 751
      mtemp___0->free_fcn = (void (*)(void *ptr ))(& free);
    }
  }
#line 755
  if (! parser) {
#line 756
    return (parser);
  }
#line 758
  parser->m_buffer = (char *)((void *)0);
#line 759
  parser->m_bufferLim = (char const   *)((void *)0);
#line 761
  parser->m_attsSize = 16;
#line 762
  tmp___1 = (*(parser->m_mem.malloc_fcn))((unsigned long )parser->m_attsSize * sizeof(ATTRIBUTE ));
#line 762
  parser->m_atts = (ATTRIBUTE *)tmp___1;
#line 763
  if ((unsigned long )parser->m_atts == (unsigned long )((void *)0)) {
#line 764
    (*(parser->m_mem.free_fcn))((void *)parser);
#line 765
    return ((XML_Parser )((void *)0));
  }
#line 775
  tmp___2 = (*(parser->m_mem.malloc_fcn))(1024UL * sizeof(XML_Char ));
#line 775
  parser->m_dataBuf = (XML_Char *)tmp___2;
#line 776
  if ((unsigned long )parser->m_dataBuf == (unsigned long )((void *)0)) {
#line 777
    (*(parser->m_mem.free_fcn))((void *)parser->m_atts);
#line 781
    (*(parser->m_mem.free_fcn))((void *)parser);
#line 782
    return ((XML_Parser )((void *)0));
  }
#line 784
  parser->m_dataBufEnd = parser->m_dataBuf + 1024;
#line 786
  if (dtd) {
#line 787
    parser->m_dtd = dtd;
  } else {
#line 789
    parser->m_dtd = dtdCreate(& parser->m_mem);
#line 790
    if ((unsigned long )parser->m_dtd == (unsigned long )((void *)0)) {
#line 791
      (*(parser->m_mem.free_fcn))((void *)parser->m_dataBuf);
#line 792
      (*(parser->m_mem.free_fcn))((void *)parser->m_atts);
#line 796
      (*(parser->m_mem.free_fcn))((void *)parser);
#line 797
      return ((XML_Parser )((void *)0));
    }
  }
#line 801
  parser->m_freeBindingList = (BINDING *)((void *)0);
#line 802
  parser->m_freeTagList = (TAG *)((void *)0);
#line 803
  parser->m_freeInternalEntities = (OPEN_INTERNAL_ENTITY *)((void *)0);
#line 805
  parser->m_groupSize = 0U;
#line 806
  parser->m_groupConnector = (char *)((void *)0);
#line 808
  parser->m_unknownEncodingHandler = (int (*)(void *encodingHandlerData , XML_Char const   *name ,
                                              XML_Encoding *info ))((void *)0);
#line 809
  parser->m_unknownEncodingHandlerData = (void *)0;
#line 811
  parser->m_namespaceSeparator = (XML_Char )33;
#line 812
  parser->m_ns = (XML_Bool )0;
#line 813
  parser->m_ns_triplets = (XML_Bool )0;
#line 815
  parser->m_nsAtts = (NS_ATT *)((void *)0);
#line 816
  parser->m_nsAttsVersion = 0UL;
#line 817
  parser->m_nsAttsPower = (unsigned char)0;
#line 819
  poolInit(& parser->m_tempPool, & parser->m_mem);
#line 820
  poolInit(& parser->m_temp2Pool, & parser->m_mem);
#line 821
  parserInit(parser, encodingName);
#line 823
  if (encodingName) {
#line 823
    if (! parser->m_protocolEncodingName) {
#line 824
      XML_ParserFree(parser);
#line 825
      return ((XML_Parser )((void *)0));
    }
  }
#line 828
  if (nameSep) {
#line 829
    parser->m_ns = (XML_Bool )1;
#line 830
    parser->m_internalEncoding = XmlGetUtf8InternalEncodingNS();
#line 831
    parser->m_namespaceSeparator = (XML_Char )*nameSep;
  } else {
#line 834
    parser->m_internalEncoding = XmlGetUtf8InternalEncoding();
  }
#line 837
  return (parser);
}
}
#line 840 "xmlparse.c"
static void parserInit(XML_Parser parser , XML_Char const   *encodingName ) 
{ 
  XML_Char const   *tmp ;

  {
#line 843
  parser->m_processor = & prologInitProcessor;
#line 844
  XmlPrologStateInit(& parser->m_prologState);
#line 845
  if ((unsigned long )encodingName != (unsigned long )((void *)0)) {
#line 845
    tmp = poolCopyString(& parser->m_tempPool, encodingName);
#line 845
    parser->m_protocolEncodingName = tmp;
  } else {
#line 845
    parser->m_protocolEncodingName = (XML_Char const   *)((void *)0);
  }
#line 848
  parser->m_curBase = (XML_Char const   *)((void *)0);
#line 849
  XmlInitEncoding(& parser->m_initEncoding, & parser->m_encoding, (char const   *)0);
#line 850
  parser->m_userData = (void *)0;
#line 851
  parser->m_handlerArg = (void *)0;
#line 852
  parser->m_startElementHandler = (void (*)(void *userData , XML_Char const   *name ,
                                            XML_Char const   **atts ))((void *)0);
#line 853
  parser->m_endElementHandler = (void (*)(void *userData , XML_Char const   *name ))((void *)0);
#line 854
  parser->m_characterDataHandler = (void (*)(void *userData , XML_Char const   *s ,
                                             int len ))((void *)0);
#line 855
  parser->m_processingInstructionHandler = (void (*)(void *userData , XML_Char const   *target ,
                                                     XML_Char const   *data ))((void *)0);
#line 856
  parser->m_commentHandler = (void (*)(void *userData , XML_Char const   *data ))((void *)0);
#line 857
  parser->m_startCdataSectionHandler = (void (*)(void *userData ))((void *)0);
#line 858
  parser->m_endCdataSectionHandler = (void (*)(void *userData ))((void *)0);
#line 859
  parser->m_defaultHandler = (void (*)(void *userData , XML_Char const   *s , int len ))((void *)0);
#line 860
  parser->m_startDoctypeDeclHandler = (void (*)(void *userData , XML_Char const   *doctypeName ,
                                                XML_Char const   *sysid , XML_Char const   *pubid ,
                                                int has_internal_subset ))((void *)0);
#line 861
  parser->m_endDoctypeDeclHandler = (void (*)(void *userData ))((void *)0);
#line 862
  parser->m_unparsedEntityDeclHandler = (void (*)(void *userData , XML_Char const   *entityName ,
                                                  XML_Char const   *base , XML_Char const   *systemId ,
                                                  XML_Char const   *publicId , XML_Char const   *notationName ))((void *)0);
#line 863
  parser->m_notationDeclHandler = (void (*)(void *userData , XML_Char const   *notationName ,
                                            XML_Char const   *base , XML_Char const   *systemId ,
                                            XML_Char const   *publicId ))((void *)0);
#line 864
  parser->m_startNamespaceDeclHandler = (void (*)(void *userData , XML_Char const   *prefix ,
                                                  XML_Char const   *uri ))((void *)0);
#line 865
  parser->m_endNamespaceDeclHandler = (void (*)(void *userData , XML_Char const   *prefix ))((void *)0);
#line 866
  parser->m_notStandaloneHandler = (int (*)(void *userData ))((void *)0);
#line 867
  parser->m_externalEntityRefHandler = (int (*)(XML_Parser parser , XML_Char const   *context ,
                                                XML_Char const   *base , XML_Char const   *systemId ,
                                                XML_Char const   *publicId ))((void *)0);
#line 868
  parser->m_externalEntityRefHandlerArg = parser;
#line 869
  parser->m_skippedEntityHandler = (void (*)(void *userData , XML_Char const   *entityName ,
                                             int is_parameter_entity ))((void *)0);
#line 870
  parser->m_elementDeclHandler = (void (*)(void *userData , XML_Char const   *name ,
                                           XML_Content *model ))((void *)0);
#line 871
  parser->m_attlistDeclHandler = (void (*)(void *userData , XML_Char const   *elname ,
                                           XML_Char const   *attname , XML_Char const   *att_type ,
                                           XML_Char const   *dflt , int isrequired ))((void *)0);
#line 872
  parser->m_entityDeclHandler = (void (*)(void *userData , XML_Char const   *entityName ,
                                          int is_parameter_entity , XML_Char const   *value ,
                                          int value_length , XML_Char const   *base ,
                                          XML_Char const   *systemId , XML_Char const   *publicId ,
                                          XML_Char const   *notationName ))((void *)0);
#line 873
  parser->m_xmlDeclHandler = (void (*)(void *userData , XML_Char const   *version ,
                                       XML_Char const   *encoding , int standalone ))((void *)0);
#line 874
  parser->m_bufferPtr = (char const   *)parser->m_buffer;
#line 875
  parser->m_bufferEnd = parser->m_buffer;
#line 876
  parser->m_parseEndByteIndex = (XML_Index )0;
#line 877
  parser->m_parseEndPtr = (char const   *)((void *)0);
#line 878
  parser->m_declElementType = (ELEMENT_TYPE *)((void *)0);
#line 879
  parser->m_declAttributeId = (ATTRIBUTE_ID *)((void *)0);
#line 880
  parser->m_declEntity = (ENTITY *)((void *)0);
#line 881
  parser->m_doctypeName = (XML_Char const   *)((void *)0);
#line 882
  parser->m_doctypeSysid = (XML_Char const   *)((void *)0);
#line 883
  parser->m_doctypePubid = (XML_Char const   *)((void *)0);
#line 884
  parser->m_declAttributeType = (XML_Char const   *)((void *)0);
#line 885
  parser->m_declNotationName = (XML_Char const   *)((void *)0);
#line 886
  parser->m_declNotationPublicId = (XML_Char const   *)((void *)0);
#line 887
  parser->m_declAttributeIsCdata = (XML_Bool )0;
#line 888
  parser->m_declAttributeIsId = (XML_Bool )0;
#line 889
  memset((void *)(& parser->m_position), 0, sizeof(POSITION ));
#line 890
  parser->m_errorCode = (enum XML_Error )0;
#line 891
  parser->m_eventPtr = (char const   *)((void *)0);
#line 892
  parser->m_eventEndPtr = (char const   *)((void *)0);
#line 893
  parser->m_positionPtr = (char const   *)((void *)0);
#line 894
  parser->m_openInternalEntities = (OPEN_INTERNAL_ENTITY *)((void *)0);
#line 895
  parser->m_defaultExpandInternalEntities = (XML_Bool )1;
#line 896
  parser->m_tagLevel = 0;
#line 897
  parser->m_tagStack = (TAG *)((void *)0);
#line 898
  parser->m_inheritedBindings = (BINDING *)((void *)0);
#line 899
  parser->m_nSpecifiedAtts = 0;
#line 900
  parser->m_unknownEncodingMem = (void *)0;
#line 901
  parser->m_unknownEncodingRelease = (void (*)(void * ))((void *)0);
#line 902
  parser->m_unknownEncodingData = (void *)0;
#line 903
  parser->m_parentParser = (XML_Parser )((void *)0);
#line 904
  parser->m_parsingStatus.parsing = (enum XML_Parsing )0;
#line 906
  parser->m_isParamEntity = (XML_Bool )0;
#line 907
  parser->m_useForeignDTD = (XML_Bool )0;
#line 908
  parser->m_paramEntityParsing = (enum XML_ParamEntityParsing )0;
#line 910
  parser->m_hash_secret_salt = 0UL;
#line 911
  return;
}
}
#line 914 "xmlparse.c"
static void moveToFreeBindingList(XML_Parser parser , BINDING *bindings ) 
{ 
  BINDING *b ;

  {
#line 917
  while (bindings) {
#line 918
    b = bindings;
#line 919
    bindings = bindings->nextTagBinding;
#line 920
    b->nextTagBinding = parser->m_freeBindingList;
#line 921
    parser->m_freeBindingList = b;
  }
#line 923
  return;
}
}
#line 925 "xmlparse.c"
XML_Bool XML_ParserReset(XML_Parser parser , XML_Char const   *encodingName ) 
{ 
  TAG *tStk ;
  OPEN_INTERNAL_ENTITY *openEntityList ;
  TAG *tag ;
  OPEN_INTERNAL_ENTITY *openEntity ;

  {
#line 930
  if (parser->m_parentParser) {
#line 931
    return ((XML_Bool )0);
  }
#line 933
  tStk = parser->m_tagStack;
#line 934
  while (tStk) {
#line 935
    tag = tStk;
#line 936
    tStk = tStk->parent;
#line 937
    tag->parent = parser->m_freeTagList;
#line 938
    moveToFreeBindingList(parser, tag->bindings);
#line 939
    tag->bindings = (BINDING *)((void *)0);
#line 940
    parser->m_freeTagList = tag;
  }
#line 943
  openEntityList = parser->m_openInternalEntities;
#line 944
  while (openEntityList) {
#line 945
    openEntity = openEntityList;
#line 946
    openEntityList = openEntity->next;
#line 947
    openEntity->next = parser->m_freeInternalEntities;
#line 948
    parser->m_freeInternalEntities = openEntity;
  }
#line 950
  moveToFreeBindingList(parser, parser->m_inheritedBindings);
#line 951
  (*(parser->m_mem.free_fcn))(parser->m_unknownEncodingMem);
#line 952
  if (parser->m_unknownEncodingRelease) {
#line 953
    (*(parser->m_unknownEncodingRelease))(parser->m_unknownEncodingData);
  }
#line 954
  poolClear(& parser->m_tempPool);
#line 955
  poolClear(& parser->m_temp2Pool);
#line 956
  parserInit(parser, encodingName);
#line 957
  dtdReset(parser->m_dtd, & parser->m_mem);
#line 958
  return ((XML_Bool )1);
}
}
#line 961 "xmlparse.c"
enum XML_Status XML_SetEncoding(XML_Parser parser , XML_Char const   *encodingName ) 
{ 


  {
#line 968
  if ((unsigned int )parser->m_parsingStatus.parsing == 1U) {
#line 969
    return ((enum XML_Status )0);
  } else
#line 968
  if ((unsigned int )parser->m_parsingStatus.parsing == 3U) {
#line 969
    return ((enum XML_Status )0);
  }
#line 970
  if ((unsigned long )encodingName == (unsigned long )((void *)0)) {
#line 971
    parser->m_protocolEncodingName = (XML_Char const   *)((void *)0);
  } else {
#line 973
    parser->m_protocolEncodingName = poolCopyString(& parser->m_tempPool, encodingName);
#line 974
    if (! parser->m_protocolEncodingName) {
#line 975
      return ((enum XML_Status )0);
    }
  }
#line 977
  return ((enum XML_Status )1);
}
}
#line 980 "xmlparse.c"
XML_Parser XML_ExternalEntityParserCreate(XML_Parser oldParser , XML_Char const   *context ,
                                          XML_Char const   *encodingName ) 
{ 
  XML_Parser parser ;
  DTD *newDtd ;
  DTD *oldDtd ;
  void (*oldStartElementHandler)(void *userData , XML_Char const   *name , XML_Char const   **atts ) ;
  void (*oldEndElementHandler)(void *userData , XML_Char const   *name ) ;
  void (*oldCharacterDataHandler)(void *userData , XML_Char const   *s , int len ) ;
  void (*oldProcessingInstructionHandler)(void *userData , XML_Char const   *target ,
                                          XML_Char const   *data ) ;
  void (*oldCommentHandler)(void *userData , XML_Char const   *data ) ;
  void (*oldStartCdataSectionHandler)(void *userData ) ;
  void (*oldEndCdataSectionHandler)(void *userData ) ;
  void (*oldDefaultHandler)(void *userData , XML_Char const   *s , int len ) ;
  void (*oldUnparsedEntityDeclHandler)(void *userData , XML_Char const   *entityName ,
                                       XML_Char const   *base , XML_Char const   *systemId ,
                                       XML_Char const   *publicId , XML_Char const   *notationName ) ;
  void (*oldNotationDeclHandler)(void *userData , XML_Char const   *notationName ,
                                 XML_Char const   *base , XML_Char const   *systemId ,
                                 XML_Char const   *publicId ) ;
  void (*oldStartNamespaceDeclHandler)(void *userData , XML_Char const   *prefix ,
                                       XML_Char const   *uri ) ;
  void (*oldEndNamespaceDeclHandler)(void *userData , XML_Char const   *prefix ) ;
  int (*oldNotStandaloneHandler)(void *userData ) ;
  int (*oldExternalEntityRefHandler)(XML_Parser parser , XML_Char const   *context ,
                                     XML_Char const   *base , XML_Char const   *systemId ,
                                     XML_Char const   *publicId ) ;
  void (*oldSkippedEntityHandler)(void *userData , XML_Char const   *entityName ,
                                  int is_parameter_entity ) ;
  int (*oldUnknownEncodingHandler)(void *encodingHandlerData , XML_Char const   *name ,
                                   XML_Encoding *info ) ;
  void (*oldElementDeclHandler)(void *userData , XML_Char const   *name , XML_Content *model ) ;
  void (*oldAttlistDeclHandler)(void *userData , XML_Char const   *elname , XML_Char const   *attname ,
                                XML_Char const   *att_type , XML_Char const   *dflt ,
                                int isrequired ) ;
  void (*oldEntityDeclHandler)(void *userData , XML_Char const   *entityName , int is_parameter_entity ,
                               XML_Char const   *value , int value_length , XML_Char const   *base ,
                               XML_Char const   *systemId , XML_Char const   *publicId ,
                               XML_Char const   *notationName ) ;
  void (*oldXmlDeclHandler)(void *userData , XML_Char const   *version , XML_Char const   *encoding ,
                            int standalone ) ;
  ELEMENT_TYPE *oldDeclElementType ;
  void *oldUserData ;
  void *oldHandlerArg ;
  XML_Bool oldDefaultExpandInternalEntities ;
  XML_Parser oldExternalEntityRefHandlerArg ;
  enum XML_ParamEntityParsing oldParamEntityParsing ;
  int oldInEntityValue ;
  XML_Bool oldns_triplets ;
  unsigned long oldhash_secret_salt ;
  XML_Char tmp[2] ;
  int tmp___0 ;
  XML_Bool tmp___1 ;

  {
#line 985
  parser = oldParser;
#line 986
  newDtd = (DTD *)((void *)0);
#line 987
  oldDtd = parser->m_dtd;
#line 988
  oldStartElementHandler = parser->m_startElementHandler;
#line 989
  oldEndElementHandler = parser->m_endElementHandler;
#line 990
  oldCharacterDataHandler = parser->m_characterDataHandler;
#line 991
  oldProcessingInstructionHandler = parser->m_processingInstructionHandler;
#line 993
  oldCommentHandler = parser->m_commentHandler;
#line 994
  oldStartCdataSectionHandler = parser->m_startCdataSectionHandler;
#line 996
  oldEndCdataSectionHandler = parser->m_endCdataSectionHandler;
#line 998
  oldDefaultHandler = parser->m_defaultHandler;
#line 999
  oldUnparsedEntityDeclHandler = parser->m_unparsedEntityDeclHandler;
#line 1001
  oldNotationDeclHandler = parser->m_notationDeclHandler;
#line 1002
  oldStartNamespaceDeclHandler = parser->m_startNamespaceDeclHandler;
#line 1004
  oldEndNamespaceDeclHandler = parser->m_endNamespaceDeclHandler;
#line 1006
  oldNotStandaloneHandler = parser->m_notStandaloneHandler;
#line 1007
  oldExternalEntityRefHandler = parser->m_externalEntityRefHandler;
#line 1009
  oldSkippedEntityHandler = parser->m_skippedEntityHandler;
#line 1010
  oldUnknownEncodingHandler = parser->m_unknownEncodingHandler;
#line 1012
  oldElementDeclHandler = parser->m_elementDeclHandler;
#line 1013
  oldAttlistDeclHandler = parser->m_attlistDeclHandler;
#line 1014
  oldEntityDeclHandler = parser->m_entityDeclHandler;
#line 1015
  oldXmlDeclHandler = parser->m_xmlDeclHandler;
#line 1016
  oldDeclElementType = parser->m_declElementType;
#line 1018
  oldUserData = parser->m_userData;
#line 1019
  oldHandlerArg = parser->m_handlerArg;
#line 1020
  oldDefaultExpandInternalEntities = parser->m_defaultExpandInternalEntities;
#line 1021
  oldExternalEntityRefHandlerArg = parser->m_externalEntityRefHandlerArg;
#line 1023
  oldParamEntityParsing = parser->m_paramEntityParsing;
#line 1024
  oldInEntityValue = parser->m_prologState.inEntityValue;
#line 1026
  oldns_triplets = parser->m_ns_triplets;
#line 1032
  oldhash_secret_salt = parser->m_hash_secret_salt;
#line 1035
  if (! context) {
#line 1036
    newDtd = oldDtd;
  }
#line 1044
  if (parser->m_ns) {
#line 1046
    tmp[0] = parser->m_namespaceSeparator;
#line 1047
    parser = parserCreate(encodingName, & parser->m_mem, (XML_Char const   *)(tmp),
                          newDtd);
  } else {
#line 1050
    parser = parserCreate(encodingName, & parser->m_mem, (XML_Char const   *)((void *)0),
                          newDtd);
  }
#line 1053
  if (! parser) {
#line 1054
    return ((XML_Parser )((void *)0));
  }
#line 1056
  parser->m_startElementHandler = oldStartElementHandler;
#line 1057
  parser->m_endElementHandler = oldEndElementHandler;
#line 1058
  parser->m_characterDataHandler = oldCharacterDataHandler;
#line 1059
  parser->m_processingInstructionHandler = oldProcessingInstructionHandler;
#line 1060
  parser->m_commentHandler = oldCommentHandler;
#line 1061
  parser->m_startCdataSectionHandler = oldStartCdataSectionHandler;
#line 1062
  parser->m_endCdataSectionHandler = oldEndCdataSectionHandler;
#line 1063
  parser->m_defaultHandler = oldDefaultHandler;
#line 1064
  parser->m_unparsedEntityDeclHandler = oldUnparsedEntityDeclHandler;
#line 1065
  parser->m_notationDeclHandler = oldNotationDeclHandler;
#line 1066
  parser->m_startNamespaceDeclHandler = oldStartNamespaceDeclHandler;
#line 1067
  parser->m_endNamespaceDeclHandler = oldEndNamespaceDeclHandler;
#line 1068
  parser->m_notStandaloneHandler = oldNotStandaloneHandler;
#line 1069
  parser->m_externalEntityRefHandler = oldExternalEntityRefHandler;
#line 1070
  parser->m_skippedEntityHandler = oldSkippedEntityHandler;
#line 1071
  parser->m_unknownEncodingHandler = oldUnknownEncodingHandler;
#line 1072
  parser->m_elementDeclHandler = oldElementDeclHandler;
#line 1073
  parser->m_attlistDeclHandler = oldAttlistDeclHandler;
#line 1074
  parser->m_entityDeclHandler = oldEntityDeclHandler;
#line 1075
  parser->m_xmlDeclHandler = oldXmlDeclHandler;
#line 1076
  parser->m_declElementType = oldDeclElementType;
#line 1077
  parser->m_userData = oldUserData;
#line 1078
  if ((unsigned long )oldUserData == (unsigned long )oldHandlerArg) {
#line 1079
    parser->m_handlerArg = parser->m_userData;
  } else {
#line 1081
    parser->m_handlerArg = (void *)parser;
  }
#line 1082
  if ((unsigned long )oldExternalEntityRefHandlerArg != (unsigned long )oldParser) {
#line 1083
    parser->m_externalEntityRefHandlerArg = oldExternalEntityRefHandlerArg;
  }
#line 1084
  parser->m_defaultExpandInternalEntities = oldDefaultExpandInternalEntities;
#line 1085
  parser->m_ns_triplets = oldns_triplets;
#line 1086
  parser->m_hash_secret_salt = oldhash_secret_salt;
#line 1087
  parser->m_parentParser = oldParser;
#line 1089
  parser->m_paramEntityParsing = oldParamEntityParsing;
#line 1090
  parser->m_prologState.inEntityValue = oldInEntityValue;
#line 1091
  if (context) {
#line 1093
    tmp___0 = dtdCopy(oldParser, parser->m_dtd, (DTD const   *)oldDtd, & parser->m_mem);
#line 1093
    if (tmp___0) {
#line 1093
      tmp___1 = setContext(parser, context);
#line 1093
      if (! tmp___1) {
#line 1095
        XML_ParserFree(parser);
#line 1096
        return ((XML_Parser )((void *)0));
      }
    } else {
#line 1095
      XML_ParserFree(parser);
#line 1096
      return ((XML_Parser )((void *)0));
    }
#line 1098
    parser->m_processor = & externalEntityInitProcessor;
  } else {
#line 1109
    parser->m_isParamEntity = (XML_Bool )1;
#line 1110
    XmlPrologStateInitExternalEntity(& parser->m_prologState);
#line 1111
    parser->m_processor = & externalParEntInitProcessor;
  }
#line 1114
  return (parser);
}
}
#line 1117 "xmlparse.c"
static void destroyBindings(BINDING *bindings , XML_Parser parser ) 
{ 
  BINDING *b ;

  {
#line 1120
  while (1) {
#line 1121
    b = bindings;
#line 1122
    if (! b) {
#line 1123
      break;
    }
#line 1124
    bindings = b->nextTagBinding;
#line 1125
    (*(parser->m_mem.free_fcn))((void *)b->uri);
#line 1126
    (*(parser->m_mem.free_fcn))((void *)b);
  }
#line 1128
  return;
}
}
#line 1130 "xmlparse.c"
void XML_ParserFree(XML_Parser parser ) 
{ 
  TAG *tagList ;
  OPEN_INTERNAL_ENTITY *entityList ;
  TAG *p ;
  OPEN_INTERNAL_ENTITY *openEntity ;

  {
#line 1135
  if ((unsigned long )parser == (unsigned long )((void *)0)) {
#line 1136
    return;
  }
#line 1138
  tagList = parser->m_tagStack;
#line 1139
  while (1) {
#line 1141
    if ((unsigned long )tagList == (unsigned long )((void *)0)) {
#line 1142
      if ((unsigned long )parser->m_freeTagList == (unsigned long )((void *)0)) {
#line 1143
        break;
      }
#line 1144
      tagList = parser->m_freeTagList;
#line 1145
      parser->m_freeTagList = (TAG *)((void *)0);
    }
#line 1147
    p = tagList;
#line 1148
    tagList = tagList->parent;
#line 1149
    (*(parser->m_mem.free_fcn))((void *)p->buf);
#line 1150
    destroyBindings(p->bindings, parser);
#line 1151
    (*(parser->m_mem.free_fcn))((void *)p);
  }
#line 1154
  entityList = parser->m_openInternalEntities;
#line 1155
  while (1) {
#line 1157
    if ((unsigned long )entityList == (unsigned long )((void *)0)) {
#line 1158
      if ((unsigned long )parser->m_freeInternalEntities == (unsigned long )((void *)0)) {
#line 1159
        break;
      }
#line 1160
      entityList = parser->m_freeInternalEntities;
#line 1161
      parser->m_freeInternalEntities = (OPEN_INTERNAL_ENTITY *)((void *)0);
    }
#line 1163
    openEntity = entityList;
#line 1164
    entityList = entityList->next;
#line 1165
    (*(parser->m_mem.free_fcn))((void *)openEntity);
  }
#line 1168
  destroyBindings(parser->m_freeBindingList, parser);
#line 1169
  destroyBindings(parser->m_inheritedBindings, parser);
#line 1170
  poolDestroy(& parser->m_tempPool);
#line 1171
  poolDestroy(& parser->m_temp2Pool);
#line 1176
  if (! parser->m_isParamEntity) {
#line 1176
    if (parser->m_dtd) {
#line 1180
      dtdDestroy(parser->m_dtd, (XML_Bool )(! parser->m_parentParser), & parser->m_mem);
    }
  }
#line 1181
  (*(parser->m_mem.free_fcn))((void *)parser->m_atts);
#line 1185
  (*(parser->m_mem.free_fcn))((void *)parser->m_groupConnector);
#line 1186
  (*(parser->m_mem.free_fcn))((void *)parser->m_buffer);
#line 1187
  (*(parser->m_mem.free_fcn))((void *)parser->m_dataBuf);
#line 1188
  (*(parser->m_mem.free_fcn))((void *)parser->m_nsAtts);
#line 1189
  (*(parser->m_mem.free_fcn))(parser->m_unknownEncodingMem);
#line 1190
  if (parser->m_unknownEncodingRelease) {
#line 1191
    (*(parser->m_unknownEncodingRelease))(parser->m_unknownEncodingData);
  }
#line 1192
  (*(parser->m_mem.free_fcn))((void *)parser);
#line 1193
  return;
}
}
#line 1195 "xmlparse.c"
void XML_UseParserAsHandlerArg(XML_Parser parser ) 
{ 


  {
#line 1198
  parser->m_handlerArg = (void *)parser;
#line 1199
  return;
}
}
#line 1201 "xmlparse.c"
enum XML_Error XML_UseForeignDTD(XML_Parser parser , XML_Bool useDTD ) 
{ 


  {
#line 1206
  if ((unsigned int )parser->m_parsingStatus.parsing == 1U) {
#line 1207
    return ((enum XML_Error )26);
  } else
#line 1206
  if ((unsigned int )parser->m_parsingStatus.parsing == 3U) {
#line 1207
    return ((enum XML_Error )26);
  }
#line 1208
  parser->m_useForeignDTD = useDTD;
#line 1209
  return ((enum XML_Error )0);
}
}
#line 1215 "xmlparse.c"
void XML_SetReturnNSTriplet(XML_Parser parser , int do_nst ) 
{ 


  {
#line 1219
  if ((unsigned int )parser->m_parsingStatus.parsing == 1U) {
#line 1220
    return;
  } else
#line 1219
  if ((unsigned int )parser->m_parsingStatus.parsing == 3U) {
#line 1220
    return;
  }
#line 1221
  if (do_nst) {
#line 1221
    parser->m_ns_triplets = (XML_Bool )1;
  } else {
#line 1221
    parser->m_ns_triplets = (XML_Bool )0;
  }
#line 1222
  return;
}
}
#line 1224 "xmlparse.c"
void XML_SetUserData(XML_Parser parser , void *p ) 
{ 
  void *tmp ;

  {
#line 1227
  if ((unsigned long )parser->m_handlerArg == (unsigned long )parser->m_userData) {
#line 1228
    tmp = p;
#line 1228
    parser->m_userData = tmp;
#line 1228
    parser->m_handlerArg = tmp;
  } else {
#line 1230
    parser->m_userData = p;
  }
#line 1231
  return;
}
}
#line 1233 "xmlparse.c"
enum XML_Status XML_SetBase(XML_Parser parser , XML_Char const   *p ) 
{ 


  {
#line 1236
  if (p) {
#line 1237
    p = poolCopyString(& (parser->m_dtd)->pool, p);
#line 1238
    if (! p) {
#line 1239
      return ((enum XML_Status )0);
    }
#line 1240
    parser->m_curBase = p;
  } else {
#line 1243
    parser->m_curBase = (XML_Char const   *)((void *)0);
  }
#line 1244
  return ((enum XML_Status )1);
}
}
#line 1247 "xmlparse.c"
XML_Char const   *XML_GetBase(XML_Parser parser ) 
{ 


  {
#line 1250
  return (parser->m_curBase);
}
}
#line 1253 "xmlparse.c"
int XML_GetSpecifiedAttributeCount(XML_Parser parser ) 
{ 


  {
#line 1256
  return (parser->m_nSpecifiedAtts);
}
}
#line 1259 "xmlparse.c"
int XML_GetIdAttributeIndex(XML_Parser parser ) 
{ 


  {
#line 1262
  return (parser->m_idAttIndex);
}
}
#line 1273 "xmlparse.c"
void XML_SetElementHandler(XML_Parser parser , void (*start)(void *userData , XML_Char const   *name ,
                                                             XML_Char const   **atts ) ,
                           void (*end)(void *userData , XML_Char const   *name ) ) 
{ 


  {
#line 1278
  parser->m_startElementHandler = start;
#line 1279
  parser->m_endElementHandler = end;
#line 1280
  return;
}
}
#line 1282 "xmlparse.c"
void XML_SetStartElementHandler(XML_Parser parser , void (*start)(void *userData ,
                                                                  XML_Char const   *name ,
                                                                  XML_Char const   **atts ) ) 
{ 


  {
#line 1285
  parser->m_startElementHandler = start;
#line 1286
  return;
}
}
#line 1288 "xmlparse.c"
void XML_SetEndElementHandler(XML_Parser parser , void (*end)(void *userData , XML_Char const   *name ) ) 
{ 


  {
#line 1291
  parser->m_endElementHandler = end;
#line 1292
  return;
}
}
#line 1294 "xmlparse.c"
void XML_SetCharacterDataHandler(XML_Parser parser , void (*handler)(void *userData ,
                                                                     XML_Char const   *s ,
                                                                     int len ) ) 
{ 


  {
#line 1298
  parser->m_characterDataHandler = handler;
#line 1299
  return;
}
}
#line 1301 "xmlparse.c"
void XML_SetProcessingInstructionHandler(XML_Parser parser , void (*handler)(void *userData ,
                                                                             XML_Char const   *target ,
                                                                             XML_Char const   *data ) ) 
{ 


  {
#line 1305
  parser->m_processingInstructionHandler = handler;
#line 1306
  return;
}
}
#line 1308 "xmlparse.c"
void XML_SetCommentHandler(XML_Parser parser , void (*handler)(void *userData , XML_Char const   *data ) ) 
{ 


  {
#line 1312
  parser->m_commentHandler = handler;
#line 1313
  return;
}
}
#line 1315 "xmlparse.c"
void XML_SetCdataSectionHandler(XML_Parser parser , void (*start)(void *userData ) ,
                                void (*end)(void *userData ) ) 
{ 


  {
#line 1320
  parser->m_startCdataSectionHandler = start;
#line 1321
  parser->m_endCdataSectionHandler = end;
#line 1322
  return;
}
}
#line 1324 "xmlparse.c"
void XML_SetStartCdataSectionHandler(XML_Parser parser , void (*start)(void *userData ) ) 
{ 


  {
#line 1327
  parser->m_startCdataSectionHandler = start;
#line 1328
  return;
}
}
#line 1330 "xmlparse.c"
void XML_SetEndCdataSectionHandler(XML_Parser parser , void (*end)(void *userData ) ) 
{ 


  {
#line 1333
  parser->m_endCdataSectionHandler = end;
#line 1334
  return;
}
}
#line 1336 "xmlparse.c"
void XML_SetDefaultHandler(XML_Parser parser , void (*handler)(void *userData , XML_Char const   *s ,
                                                               int len ) ) 
{ 


  {
#line 1340
  parser->m_defaultHandler = handler;
#line 1341
  parser->m_defaultExpandInternalEntities = (XML_Bool )0;
#line 1342
  return;
}
}
#line 1344 "xmlparse.c"
void XML_SetDefaultHandlerExpand(XML_Parser parser , void (*handler)(void *userData ,
                                                                     XML_Char const   *s ,
                                                                     int len ) ) 
{ 


  {
#line 1348
  parser->m_defaultHandler = handler;
#line 1349
  parser->m_defaultExpandInternalEntities = (XML_Bool )1;
#line 1350
  return;
}
}
#line 1352 "xmlparse.c"
void XML_SetDoctypeDeclHandler(XML_Parser parser , void (*start)(void *userData ,
                                                                 XML_Char const   *doctypeName ,
                                                                 XML_Char const   *sysid ,
                                                                 XML_Char const   *pubid ,
                                                                 int has_internal_subset ) ,
                               void (*end)(void *userData ) ) 
{ 


  {
#line 1357
  parser->m_startDoctypeDeclHandler = start;
#line 1358
  parser->m_endDoctypeDeclHandler = end;
#line 1359
  return;
}
}
#line 1361 "xmlparse.c"
void XML_SetStartDoctypeDeclHandler(XML_Parser parser , void (*start)(void *userData ,
                                                                      XML_Char const   *doctypeName ,
                                                                      XML_Char const   *sysid ,
                                                                      XML_Char const   *pubid ,
                                                                      int has_internal_subset ) ) 
{ 


  {
#line 1364
  parser->m_startDoctypeDeclHandler = start;
#line 1365
  return;
}
}
#line 1367 "xmlparse.c"
void XML_SetEndDoctypeDeclHandler(XML_Parser parser , void (*end)(void *userData ) ) 
{ 


  {
#line 1370
  parser->m_endDoctypeDeclHandler = end;
#line 1371
  return;
}
}
#line 1373 "xmlparse.c"
void XML_SetUnparsedEntityDeclHandler(XML_Parser parser , void (*handler)(void *userData ,
                                                                          XML_Char const   *entityName ,
                                                                          XML_Char const   *base ,
                                                                          XML_Char const   *systemId ,
                                                                          XML_Char const   *publicId ,
                                                                          XML_Char const   *notationName ) ) 
{ 


  {
#line 1377
  parser->m_unparsedEntityDeclHandler = handler;
#line 1378
  return;
}
}
#line 1380 "xmlparse.c"
void XML_SetNotationDeclHandler(XML_Parser parser , void (*handler)(void *userData ,
                                                                    XML_Char const   *notationName ,
                                                                    XML_Char const   *base ,
                                                                    XML_Char const   *systemId ,
                                                                    XML_Char const   *publicId ) ) 
{ 


  {
#line 1384
  parser->m_notationDeclHandler = handler;
#line 1385
  return;
}
}
#line 1387 "xmlparse.c"
void XML_SetNamespaceDeclHandler(XML_Parser parser , void (*start)(void *userData ,
                                                                   XML_Char const   *prefix ,
                                                                   XML_Char const   *uri ) ,
                                 void (*end)(void *userData , XML_Char const   *prefix ) ) 
{ 


  {
#line 1392
  parser->m_startNamespaceDeclHandler = start;
#line 1393
  parser->m_endNamespaceDeclHandler = end;
#line 1394
  return;
}
}
#line 1396 "xmlparse.c"
void XML_SetStartNamespaceDeclHandler(XML_Parser parser , void (*start)(void *userData ,
                                                                        XML_Char const   *prefix ,
                                                                        XML_Char const   *uri ) ) 
{ 


  {
#line 1399
  parser->m_startNamespaceDeclHandler = start;
#line 1400
  return;
}
}
#line 1402 "xmlparse.c"
void XML_SetEndNamespaceDeclHandler(XML_Parser parser , void (*end)(void *userData ,
                                                                    XML_Char const   *prefix ) ) 
{ 


  {
#line 1405
  parser->m_endNamespaceDeclHandler = end;
#line 1406
  return;
}
}
#line 1408 "xmlparse.c"
void XML_SetNotStandaloneHandler(XML_Parser parser , int (*handler)(void *userData ) ) 
{ 


  {
#line 1412
  parser->m_notStandaloneHandler = handler;
#line 1413
  return;
}
}
#line 1415 "xmlparse.c"
void XML_SetExternalEntityRefHandler(XML_Parser parser , int (*handler)(XML_Parser parser ,
                                                                        XML_Char const   *context ,
                                                                        XML_Char const   *base ,
                                                                        XML_Char const   *systemId ,
                                                                        XML_Char const   *publicId ) ) 
{ 


  {
#line 1419
  parser->m_externalEntityRefHandler = handler;
#line 1420
  return;
}
}
#line 1422 "xmlparse.c"
void XML_SetExternalEntityRefHandlerArg(XML_Parser parser , void *arg ) 
{ 


  {
#line 1425
  if (arg) {
#line 1426
    parser->m_externalEntityRefHandlerArg = (XML_Parser )arg;
  } else {
#line 1428
    parser->m_externalEntityRefHandlerArg = parser;
  }
#line 1429
  return;
}
}
#line 1431 "xmlparse.c"
void XML_SetSkippedEntityHandler(XML_Parser parser , void (*handler)(void *userData ,
                                                                     XML_Char const   *entityName ,
                                                                     int is_parameter_entity ) ) 
{ 


  {
#line 1435
  parser->m_skippedEntityHandler = handler;
#line 1436
  return;
}
}
#line 1438 "xmlparse.c"
void XML_SetUnknownEncodingHandler(XML_Parser parser , int (*handler)(void *encodingHandlerData ,
                                                                      XML_Char const   *name ,
                                                                      XML_Encoding *info ) ,
                                   void *data ) 
{ 


  {
#line 1443
  parser->m_unknownEncodingHandler = handler;
#line 1444
  parser->m_unknownEncodingHandlerData = data;
#line 1445
  return;
}
}
#line 1447 "xmlparse.c"
void XML_SetElementDeclHandler(XML_Parser parser , void (*eldecl)(void *userData ,
                                                                  XML_Char const   *name ,
                                                                  XML_Content *model ) ) 
{ 


  {
#line 1451
  parser->m_elementDeclHandler = eldecl;
#line 1452
  return;
}
}
#line 1454 "xmlparse.c"
void XML_SetAttlistDeclHandler(XML_Parser parser , void (*attdecl)(void *userData ,
                                                                   XML_Char const   *elname ,
                                                                   XML_Char const   *attname ,
                                                                   XML_Char const   *att_type ,
                                                                   XML_Char const   *dflt ,
                                                                   int isrequired ) ) 
{ 


  {
#line 1458
  parser->m_attlistDeclHandler = attdecl;
#line 1459
  return;
}
}
#line 1461 "xmlparse.c"
void XML_SetEntityDeclHandler(XML_Parser parser , void (*handler)(void *userData ,
                                                                  XML_Char const   *entityName ,
                                                                  int is_parameter_entity ,
                                                                  XML_Char const   *value ,
                                                                  int value_length ,
                                                                  XML_Char const   *base ,
                                                                  XML_Char const   *systemId ,
                                                                  XML_Char const   *publicId ,
                                                                  XML_Char const   *notationName ) ) 
{ 


  {
#line 1465
  parser->m_entityDeclHandler = handler;
#line 1466
  return;
}
}
#line 1468 "xmlparse.c"
void XML_SetXmlDeclHandler(XML_Parser parser , void (*handler)(void *userData , XML_Char const   *version ,
                                                               XML_Char const   *encoding ,
                                                               int standalone ) ) 
{ 


  {
#line 1471
  parser->m_xmlDeclHandler = handler;
#line 1472
  return;
}
}
#line 1474 "xmlparse.c"
int XML_SetParamEntityParsing(XML_Parser parser , enum XML_ParamEntityParsing peParsing ) 
{ 


  {
#line 1479
  if ((unsigned int )parser->m_parsingStatus.parsing == 1U) {
#line 1480
    return (0);
  } else
#line 1479
  if ((unsigned int )parser->m_parsingStatus.parsing == 3U) {
#line 1480
    return (0);
  }
#line 1482
  parser->m_paramEntityParsing = peParsing;
#line 1483
  return (1);
}
}
#line 1489 "xmlparse.c"
int XML_SetHashSalt(XML_Parser parser , unsigned long hash_salt ) 
{ 


  {
#line 1494
  if ((unsigned int )parser->m_parsingStatus.parsing == 1U) {
#line 1495
    return (0);
  } else
#line 1494
  if ((unsigned int )parser->m_parsingStatus.parsing == 3U) {
#line 1495
    return (0);
  }
#line 1496
  parser->m_hash_secret_salt = hash_salt;
#line 1497
  return (1);
}
}
#line 1500 "xmlparse.c"
enum XML_Status XML_Parse(XML_Parser parser , char const   *s , int len , int isFinal ) 
{ 
  XML_Bool tmp ;
  void *buff ;
  void *tmp___0 ;
  char *tmp___1 ;
  int i ;
  enum XML_Status tmp___2 ;

  {
#line 1503
  switch ((unsigned int )parser->m_parsingStatus.parsing) {
  case 3U: 
#line 1505
  parser->m_errorCode = (enum XML_Error )33;
#line 1506
  return ((enum XML_Status )0);
  case 2U: 
#line 1508
  parser->m_errorCode = (enum XML_Error )36;
#line 1509
  return ((enum XML_Status )0);
  case 0U: 
#line 1511
  if ((unsigned long )parser->m_parentParser == (unsigned long )((void *)0)) {
#line 1511
    tmp = startParsing(parser);
#line 1511
    if (! tmp) {
#line 1512
      parser->m_errorCode = (enum XML_Error )1;
#line 1513
      return ((enum XML_Status )0);
    }
  }
  default: 
#line 1516
  parser->m_parsingStatus.parsing = (enum XML_Parsing )1;
  }
#line 1519
  if (len == 0) {
#line 1520
    parser->m_parsingStatus.finalBuffer = (XML_Bool )isFinal;
#line 1521
    if (! isFinal) {
#line 1522
      return ((enum XML_Status )1);
    }
#line 1523
    parser->m_positionPtr = parser->m_bufferPtr;
#line 1524
    parser->m_parseEndPtr = (char const   *)parser->m_bufferEnd;
#line 1530
    parser->m_errorCode = (*(parser->m_processor))(parser, parser->m_bufferPtr, parser->m_parseEndPtr,
                                                   & parser->m_bufferPtr);
#line 1532
    if ((unsigned int )parser->m_errorCode == 0U) {
#line 1533
      switch ((unsigned int )parser->m_parsingStatus.parsing) {
      case 3U: 
#line 1535
      (*((parser->m_encoding)->updatePosition))(parser->m_encoding, parser->m_positionPtr,
                                                parser->m_bufferPtr, & parser->m_position);
#line 1536
      parser->m_positionPtr = parser->m_bufferPtr;
#line 1537
      return ((enum XML_Status )2);
      case 1U: 
      case 0U: 
#line 1540
      parser->m_parsingStatus.parsing = (enum XML_Parsing )2;
      default: 
#line 1543
      return ((enum XML_Status )1);
      }
    }
#line 1546
    parser->m_eventEndPtr = parser->m_eventPtr;
#line 1547
    parser->m_processor = & errorProcessor;
#line 1548
    return ((enum XML_Status )0);
  } else {
#line 1613
    tmp___0 = XML_GetBuffer(parser, len);
#line 1613
    buff = tmp___0;
#line 1615
    if ((unsigned long )buff == (unsigned long )((void *)0)) {
#line 1616
      return ((enum XML_Status )0);
    } else {
#line 1620
      tmp___1 = (char *)buff;
#line 1621
      i = 0;
#line 1621
      while (i < len) {
#line 1622
        __CrestChar(tmp___1 + i);
#line 1621
        i ++;
      }
#line 1624
      tmp___2 = XML_ParseBuffer(parser, len, isFinal);
#line 1624
      return (tmp___2);
    }
  }
}
}
#line 1629 "xmlparse.c"
enum XML_Status XML_ParseBuffer(XML_Parser parser , int len , int isFinal ) 
{ 
  char const   *start ;
  enum XML_Status result ;
  XML_Bool tmp ;

  {
#line 1633
  result = (enum XML_Status )1;
#line 1635
  switch ((unsigned int )parser->m_parsingStatus.parsing) {
  case 3U: 
#line 1637
  parser->m_errorCode = (enum XML_Error )33;
#line 1638
  return ((enum XML_Status )0);
  case 2U: 
#line 1640
  parser->m_errorCode = (enum XML_Error )36;
#line 1641
  return ((enum XML_Status )0);
  case 0U: 
#line 1643
  if ((unsigned long )parser->m_parentParser == (unsigned long )((void *)0)) {
#line 1643
    tmp = startParsing(parser);
#line 1643
    if (! tmp) {
#line 1644
      parser->m_errorCode = (enum XML_Error )1;
#line 1645
      return ((enum XML_Status )0);
    }
  }
  default: 
#line 1648
  parser->m_parsingStatus.parsing = (enum XML_Parsing )1;
  }
#line 1651
  start = parser->m_bufferPtr;
#line 1652
  parser->m_positionPtr = start;
#line 1653
  parser->m_bufferEnd += len;
#line 1654
  parser->m_parseEndPtr = (char const   *)parser->m_bufferEnd;
#line 1655
  parser->m_parseEndByteIndex += (XML_Index )len;
#line 1656
  parser->m_parsingStatus.finalBuffer = (XML_Bool )isFinal;
#line 1658
  parser->m_errorCode = (*(parser->m_processor))(parser, start, parser->m_parseEndPtr,
                                                 & parser->m_bufferPtr);
#line 1660
  if ((unsigned int )parser->m_errorCode != 0U) {
#line 1661
    parser->m_eventEndPtr = parser->m_eventPtr;
#line 1662
    parser->m_processor = & errorProcessor;
#line 1663
    return ((enum XML_Status )0);
  } else {
#line 1666
    switch ((unsigned int )parser->m_parsingStatus.parsing) {
    case 3U: 
#line 1668
    result = (enum XML_Status )2;
#line 1669
    break;
    case 1U: 
    case 0U: 
#line 1672
    if (isFinal) {
#line 1673
      parser->m_parsingStatus.parsing = (enum XML_Parsing )2;
#line 1674
      return (result);
    }
    default: ;
    }
  }
#line 1680
  (*((parser->m_encoding)->updatePosition))(parser->m_encoding, parser->m_positionPtr,
                                            parser->m_bufferPtr, & parser->m_position);
#line 1681
  parser->m_positionPtr = parser->m_bufferPtr;
#line 1682
  return (result);
}
}
#line 1741
void *sym_memcpy(void *dst , void const   *src , size_t len ) ;
#line 1685 "xmlparse.c"
void *XML_GetBuffer(XML_Parser parser , int len ) 
{ 
  int neededSize ;
  int keep ;
  int offset ;
  char *newBuf ;
  int bufferSize ;
  void *tmp ;
  int keep___0 ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 1688
  switch ((unsigned int )parser->m_parsingStatus.parsing) {
  case 3U: 
#line 1690
  parser->m_errorCode = (enum XML_Error )33;
#line 1691
  return ((void *)0);
  case 2U: 
#line 1693
  parser->m_errorCode = (enum XML_Error )36;
#line 1694
  return ((void *)0);
  default: ;
  }
#line 1698
  if ((long )len > parser->m_bufferLim - (char const   *)parser->m_bufferEnd) {
#line 1700
    neededSize = len + (int )(parser->m_bufferEnd - (char *)parser->m_bufferPtr);
#line 1702
    keep = (int )(parser->m_bufferPtr - (char const   *)parser->m_buffer);
#line 1704
    if (keep > 1024) {
#line 1705
      keep = 1024;
    }
#line 1706
    neededSize += keep;
#line 1708
    if ((long )neededSize <= parser->m_bufferLim - (char const   *)parser->m_buffer) {
#line 1710
      if ((long )keep < parser->m_bufferPtr - (char const   *)parser->m_buffer) {
#line 1711
        offset = (int )(parser->m_bufferPtr - (char const   *)parser->m_buffer) - keep;
#line 1712
        memmove((void *)parser->m_buffer, (void const   *)(parser->m_buffer + offset),
                (size_t )((parser->m_bufferEnd - (char *)parser->m_bufferPtr) + (long )keep));
#line 1713
        parser->m_bufferEnd -= offset;
#line 1714
        parser->m_bufferPtr -= offset;
      }
    } else {
#line 1724
      bufferSize = (int )(parser->m_bufferLim - parser->m_bufferPtr);
#line 1725
      if (bufferSize == 0) {
#line 1726
        bufferSize = 1024;
      }
#line 1727
      while (1) {
#line 1728
        bufferSize *= 2;
#line 1727
        if (! (bufferSize < neededSize)) {
#line 1727
          break;
        }
      }
#line 1730
      tmp = (*(parser->m_mem.malloc_fcn))((size_t )bufferSize);
#line 1730
      newBuf = (char *)tmp;
#line 1731
      if ((unsigned long )newBuf == (unsigned long )((char *)0)) {
#line 1732
        parser->m_errorCode = (enum XML_Error )1;
#line 1733
        return ((void *)0);
      }
#line 1735
      parser->m_bufferLim = (char const   *)(newBuf + bufferSize);
#line 1737
      if (parser->m_bufferPtr) {
#line 1738
        keep___0 = (int )(parser->m_bufferPtr - (char const   *)parser->m_buffer);
#line 1739
        if (keep___0 > 1024) {
#line 1740
          keep___0 = 1024;
        }
#line 1741
        sym_memcpy(newBuf, parser->m_bufferPtr + - keep___0, (parser->m_bufferEnd - (char *)parser->m_bufferPtr) + (long )keep___0);
#line 1742
        (*(parser->m_mem.free_fcn))((void *)parser->m_buffer);
#line 1743
        parser->m_buffer = newBuf;
#line 1744
        parser->m_bufferEnd = (parser->m_buffer + (parser->m_bufferEnd - (char *)parser->m_bufferPtr)) + keep___0;
#line 1745
        parser->m_bufferPtr = (char const   *)(parser->m_buffer + keep___0);
      } else {
#line 1748
        parser->m_bufferEnd = newBuf + (parser->m_bufferEnd - (char *)parser->m_bufferPtr);
#line 1749
        tmp___0 = newBuf;
#line 1749
        parser->m_buffer = tmp___0;
#line 1749
        parser->m_bufferPtr = (char const   *)tmp___0;
      }
    }
#line 1760
    tmp___1 = (char const   *)((void *)0);
#line 1760
    parser->m_eventEndPtr = tmp___1;
#line 1760
    parser->m_eventPtr = tmp___1;
#line 1761
    parser->m_positionPtr = (char const   *)((void *)0);
  }
#line 1763
  return ((void *)parser->m_bufferEnd);
}
}
#line 1766 "xmlparse.c"
enum XML_Status XML_StopParser(XML_Parser parser , XML_Bool resumable ) 
{ 


  {
#line 1769
  switch ((unsigned int )parser->m_parsingStatus.parsing) {
  case 3U: 
#line 1771
  if (resumable) {
#line 1772
    parser->m_errorCode = (enum XML_Error )33;
#line 1773
    return ((enum XML_Status )0);
  }
#line 1775
  parser->m_parsingStatus.parsing = (enum XML_Parsing )2;
#line 1776
  break;
  case 2U: 
#line 1778
  parser->m_errorCode = (enum XML_Error )36;
#line 1779
  return ((enum XML_Status )0);
  default: 
#line 1781
  if (resumable) {
#line 1783
    if (parser->m_isParamEntity) {
#line 1784
      parser->m_errorCode = (enum XML_Error )37;
#line 1785
      return ((enum XML_Status )0);
    }
#line 1788
    parser->m_parsingStatus.parsing = (enum XML_Parsing )3;
  } else {
#line 1791
    parser->m_parsingStatus.parsing = (enum XML_Parsing )2;
  }
  }
#line 1793
  return ((enum XML_Status )1);
}
}
#line 1796 "xmlparse.c"
enum XML_Status XML_ResumeParser(XML_Parser parser ) 
{ 
  enum XML_Status result ;

  {
#line 1799
  result = (enum XML_Status )1;
#line 1801
  if ((unsigned int )parser->m_parsingStatus.parsing != 3U) {
#line 1802
    parser->m_errorCode = (enum XML_Error )34;
#line 1803
    return ((enum XML_Status )0);
  }
#line 1805
  parser->m_parsingStatus.parsing = (enum XML_Parsing )1;
#line 1807
  parser->m_errorCode = (*(parser->m_processor))(parser, parser->m_bufferPtr, parser->m_parseEndPtr,
                                                 & parser->m_bufferPtr);
#line 1809
  if ((unsigned int )parser->m_errorCode != 0U) {
#line 1810
    parser->m_eventEndPtr = parser->m_eventPtr;
#line 1811
    parser->m_processor = & errorProcessor;
#line 1812
    return ((enum XML_Status )0);
  } else {
#line 1815
    switch ((unsigned int )parser->m_parsingStatus.parsing) {
    case 3U: 
#line 1817
    result = (enum XML_Status )2;
#line 1818
    break;
    case 1U: 
    case 0U: 
#line 1821
    if (parser->m_parsingStatus.finalBuffer) {
#line 1822
      parser->m_parsingStatus.parsing = (enum XML_Parsing )2;
#line 1823
      return (result);
    }
    default: ;
    }
  }
#line 1829
  (*((parser->m_encoding)->updatePosition))(parser->m_encoding, parser->m_positionPtr,
                                            parser->m_bufferPtr, & parser->m_position);
#line 1830
  parser->m_positionPtr = parser->m_bufferPtr;
#line 1831
  return (result);
}
}
#line 1834 "xmlparse.c"
void XML_GetParsingStatus(XML_Parser parser , XML_ParsingStatus *status ) 
{ 


  {
#line 1837
  if (! ((unsigned long )status != (unsigned long )((void *)0))) {
#line 1837
    __assert_fail("status != NULL", "xmlparse.c", 1837U, "XML_GetParsingStatus");
  }
#line 1838
  *status = parser->m_parsingStatus;
#line 1839
  return;
}
}
#line 1841 "xmlparse.c"
enum XML_Error XML_GetErrorCode(XML_Parser parser ) 
{ 


  {
#line 1844
  return (parser->m_errorCode);
}
}
#line 1847 "xmlparse.c"
XML_Index XML_GetCurrentByteIndex(XML_Parser parser ) 
{ 


  {
#line 1850
  if (parser->m_eventPtr) {
#line 1851
    return (parser->m_parseEndByteIndex - (parser->m_parseEndPtr - parser->m_eventPtr));
  }
#line 1852
  return ((XML_Index )-1);
}
}
#line 1855 "xmlparse.c"
int XML_GetCurrentByteCount(XML_Parser parser ) 
{ 


  {
#line 1858
  if (parser->m_eventEndPtr) {
#line 1858
    if (parser->m_eventPtr) {
#line 1859
      return ((int )(parser->m_eventEndPtr - parser->m_eventPtr));
    }
  }
#line 1860
  return (0);
}
}
#line 1863 "xmlparse.c"
char const   *XML_GetInputContext(XML_Parser parser , int *offset , int *size ) 
{ 


  {
#line 1867
  if (parser->m_eventPtr) {
#line 1867
    if (parser->m_buffer) {
#line 1868
      *offset = (int )(parser->m_eventPtr - (char const   *)parser->m_buffer);
#line 1869
      *size = (int )(parser->m_bufferEnd - parser->m_buffer);
#line 1870
      return ((char const   *)parser->m_buffer);
    }
  }
#line 1873
  return ((char const   *)((char *)0));
}
}
#line 1876 "xmlparse.c"
XML_Size XML_GetCurrentLineNumber(XML_Parser parser ) 
{ 


  {
#line 1879
  if (parser->m_eventPtr) {
#line 1879
    if ((unsigned long )parser->m_eventPtr >= (unsigned long )parser->m_positionPtr) {
#line 1880
      (*((parser->m_encoding)->updatePosition))(parser->m_encoding, parser->m_positionPtr,
                                                parser->m_eventPtr, & parser->m_position);
#line 1881
      parser->m_positionPtr = parser->m_eventPtr;
    }
  }
#line 1883
  return (parser->m_position.lineNumber + 1UL);
}
}
#line 1886 "xmlparse.c"
XML_Size XML_GetCurrentColumnNumber(XML_Parser parser ) 
{ 


  {
#line 1889
  if (parser->m_eventPtr) {
#line 1889
    if ((unsigned long )parser->m_eventPtr >= (unsigned long )parser->m_positionPtr) {
#line 1890
      (*((parser->m_encoding)->updatePosition))(parser->m_encoding, parser->m_positionPtr,
                                                parser->m_eventPtr, & parser->m_position);
#line 1891
      parser->m_positionPtr = parser->m_eventPtr;
    }
  }
#line 1893
  return (parser->m_position.columnNumber);
}
}
#line 1896 "xmlparse.c"
void XML_FreeContentModel(XML_Parser parser , XML_Content *model ) 
{ 


  {
#line 1899
  (*(parser->m_mem.free_fcn))((void *)model);
#line 1900
  return;
}
}
#line 1902 "xmlparse.c"
void *XML_MemMalloc(XML_Parser parser , size_t size ) 
{ 
  void *tmp ;

  {
#line 1905
  tmp = (*(parser->m_mem.malloc_fcn))(size);
#line 1905
  return (tmp);
}
}
#line 1908 "xmlparse.c"
void *XML_MemRealloc(XML_Parser parser , void *ptr , size_t size ) 
{ 
  void *tmp ;

  {
#line 1911
  tmp = (*(parser->m_mem.realloc_fcn))(ptr, size);
#line 1911
  return (tmp);
}
}
#line 1914 "xmlparse.c"
void XML_MemFree(XML_Parser parser , void *ptr ) 
{ 


  {
#line 1917
  (*(parser->m_mem.free_fcn))(ptr);
#line 1918
  return;
}
}
#line 1920 "xmlparse.c"
void XML_DefaultCurrent(XML_Parser parser ) 
{ 


  {
#line 1923
  if (parser->m_defaultHandler) {
#line 1924
    if (parser->m_openInternalEntities) {
#line 1925
      reportDefault(parser, parser->m_internalEncoding, (parser->m_openInternalEntities)->internalEventPtr,
                    (parser->m_openInternalEntities)->internalEventEndPtr);
    } else {
#line 1930
      reportDefault(parser, parser->m_encoding, parser->m_eventPtr, parser->m_eventEndPtr);
    }
  }
#line 1932
  return;
}
}
#line 1937 "xmlparse.c"
static XML_LChar const   * const  message[41]  = 
#line 1937
  {      (XML_LChar const   * const  )0,      (XML_LChar const   * const  )"out of memory",      (XML_LChar const   * const  )"syntax error",      (XML_LChar const   * const  )"no element found", 
        (XML_LChar const   * const  )"not well-formed (invalid token)",      (XML_LChar const   * const  )"unclosed token",      (XML_LChar const   * const  )"partial character",      (XML_LChar const   * const  )"mismatched tag", 
        (XML_LChar const   * const  )"duplicate attribute",      (XML_LChar const   * const  )"junk after document element",      (XML_LChar const   * const  )"illegal parameter entity reference",      (XML_LChar const   * const  )"undefined entity", 
        (XML_LChar const   * const  )"recursive entity reference",      (XML_LChar const   * const  )"asynchronous entity",      (XML_LChar const   * const  )"reference to invalid character number",      (XML_LChar const   * const  )"reference to binary entity", 
        (XML_LChar const   * const  )"reference to external entity in attribute",      (XML_LChar const   * const  )"XML or text declaration not at start of entity",      (XML_LChar const   * const  )"unknown encoding",      (XML_LChar const   * const  )"encoding specified in XML declaration is incorrect", 
        (XML_LChar const   * const  )"unclosed CDATA section",      (XML_LChar const   * const  )"error in processing external entity reference",      (XML_LChar const   * const  )"document is not standalone",      (XML_LChar const   * const  )"unexpected parser state - please send a bug report", 
        (XML_LChar const   * const  )"entity declared in parameter entity",      (XML_LChar const   * const  )"requested feature requires XML_DTD support in Expat",      (XML_LChar const   * const  )"cannot change setting once parsing has begun",      (XML_LChar const   * const  )"unbound prefix", 
        (XML_LChar const   * const  )"must not undeclare prefix",      (XML_LChar const   * const  )"incomplete markup in parameter entity",      (XML_LChar const   * const  )"XML declaration not well-formed",      (XML_LChar const   * const  )"text declaration not well-formed", 
        (XML_LChar const   * const  )"illegal character(s) in public id",      (XML_LChar const   * const  )"parser suspended",      (XML_LChar const   * const  )"parser not suspended",      (XML_LChar const   * const  )"parsing aborted", 
        (XML_LChar const   * const  )"parsing finished",      (XML_LChar const   * const  )"cannot suspend in external parameter entity",      (XML_LChar const   * const  )"reserved prefix (xml) must not be undeclared or bound to another namespace name",      (XML_LChar const   * const  )"reserved prefix (xmlns) must not be declared or undeclared", 
        (XML_LChar const   * const  )"prefix must not be bound to one of the reserved namespace names"};
#line 1934 "xmlparse.c"
XML_LChar const   *XML_ErrorString(enum XML_Error code ) 
{ 


  {
#line 1980
  if ((unsigned int )code > 0U) {
#line 1980
    if ((unsigned long )code < sizeof(message) / sizeof(message[0])) {
#line 1981
      return ((XML_LChar const   *)message[code]);
    }
  }
#line 1982
  return ((XML_LChar const   *)((void *)0));
}
}
#line 1985 "xmlparse.c"
XML_LChar const   *XML_ExpatVersion(void) 
{ 


  {
#line 1999
  return ("expat_2.1.0");
}
}
#line 2005 "xmlparse.c"
XML_Expat_Version XML_ExpatVersionInfo(void) 
{ 
  XML_Expat_Version version ;

  {
#line 2010
  version.major = 2;
#line 2011
  version.minor = 1;
#line 2012
  version.micro = 0;
#line 2014
  return (version);
}
}
#line 2020 "xmlparse.c"
static XML_Feature const   features[6]  = {      {(enum XML_FeatureEnum )6, "sizeof(XML_Char)", (long )sizeof(XML_Char )}, 
        {(enum XML_FeatureEnum )7, "sizeof(XML_LChar)", (long )sizeof(XML_LChar )}, 
        {(enum XML_FeatureEnum )3, "XML_DTD", 0L}, 
        {(enum XML_FeatureEnum )4, "XML_CONTEXT_BYTES", 1024L}, 
        {(enum XML_FeatureEnum )8, "XML_NS", 0L}, 
        {(enum XML_FeatureEnum )0, (XML_LChar const   *)((void *)0), 0L}};
#line 2017 "xmlparse.c"
XML_Feature const   *XML_GetFeatureList(void) 
{ 


  {
#line 2053
  return (features);
}
}
#line 2061 "xmlparse.c"
static XML_Bool storeRawNames(XML_Parser parser ) 
{ 
  TAG *tag ;
  int bufSize ;
  int nameLen ;
  char *rawNameBuf ;
  char *temp ;
  void *tmp ;

  {
#line 2064
  tag = parser->m_tagStack;
#line 2065
  while (tag) {
#line 2067
    nameLen = (int )(sizeof(XML_Char ) * (unsigned long )(tag->name.strLen + 1));
#line 2068
    rawNameBuf = tag->buf + nameLen;
#line 2074
    if ((unsigned long )tag->rawName == (unsigned long )rawNameBuf) {
#line 2075
      break;
    }
#line 2079
    bufSize = (int )((unsigned long )nameLen + (((unsigned long )tag->rawNameLength + (sizeof(XML_Char ) - 1UL)) & ~ (sizeof(XML_Char ) - 1UL)));
#line 2080
    if ((long )bufSize > tag->bufEnd - tag->buf) {
#line 2081
      tmp = (*(parser->m_mem.realloc_fcn))((void *)tag->buf, (size_t )bufSize);
#line 2081
      temp = (char *)tmp;
#line 2082
      if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 2083
        return ((XML_Bool )0);
      }
#line 2087
      if ((unsigned long )tag->name.str == (unsigned long )tag->buf) {
#line 2088
        tag->name.str = (XML_Char const   *)temp;
      }
#line 2092
      if (tag->name.localPart) {
#line 2093
        tag->name.localPart = (XML_Char const   *)(temp + (tag->name.localPart - (XML_Char const   *)tag->buf));
      }
#line 2095
      tag->buf = temp;
#line 2096
      tag->bufEnd = temp + bufSize;
#line 2097
      rawNameBuf = temp + nameLen;
    }
#line 2099
    sym_memcpy(rawNameBuf, tag->rawName, tag->rawNameLength);
#line 2100
    tag->rawName = (char const   *)rawNameBuf;
#line 2101
    tag = tag->parent;
  }
#line 2103
  return ((XML_Bool )1);
}
}
#line 2106 "xmlparse.c"
static enum XML_Error contentProcessor(XML_Parser parser , char const   *start , char const   *end ,
                                       char const   **endPtr ) 
{ 
  enum XML_Error result ;
  enum XML_Error tmp ;
  XML_Bool tmp___0 ;

  {
#line 2112
  tmp = doContent(parser, 0, parser->m_encoding, start, end, endPtr, (XML_Bool )(! parser->m_parsingStatus.finalBuffer));
#line 2112
  result = tmp;
#line 2114
  if ((unsigned int )result == 0U) {
#line 2115
    tmp___0 = storeRawNames(parser);
#line 2115
    if (! tmp___0) {
#line 2116
      return ((enum XML_Error )1);
    }
  }
#line 2118
  return (result);
}
}
#line 2121 "xmlparse.c"
static enum XML_Error externalEntityInitProcessor(XML_Parser parser , char const   *start ,
                                                  char const   *end , char const   **endPtr ) 
{ 
  enum XML_Error result ;
  enum XML_Error tmp ;
  enum XML_Error tmp___0 ;

  {
#line 2127
  tmp = initializeEncoding(parser);
#line 2127
  result = tmp;
#line 2128
  if ((unsigned int )result != 0U) {
#line 2129
    return (result);
  }
#line 2130
  parser->m_processor = & externalEntityInitProcessor2;
#line 2131
  tmp___0 = externalEntityInitProcessor2(parser, start, end, endPtr);
#line 2131
  return (tmp___0);
}
}
#line 2134 "xmlparse.c"
static enum XML_Error externalEntityInitProcessor2(XML_Parser parser , char const   *start ,
                                                   char const   *end , char const   **endPtr ) 
{ 
  char const   *next ;
  int tok ;
  int tmp ;
  enum XML_Error tmp___0 ;

  {
#line 2140
  next = start;
#line 2141
  tmp = (*((parser->m_encoding)->scanners[1]))(parser->m_encoding, start, end, & next);
#line 2141
  tok = tmp;
#line 2142
  switch (tok) {
  case 14: 
#line 2149
  if ((unsigned long )next == (unsigned long )end) {
#line 2149
    if (! parser->m_parsingStatus.finalBuffer) {
#line 2150
      *endPtr = next;
#line 2151
      return ((enum XML_Error )0);
    }
  }
#line 2153
  start = next;
#line 2154
  break;
  case -1: 
#line 2156
  if (! parser->m_parsingStatus.finalBuffer) {
#line 2157
    *endPtr = start;
#line 2158
    return ((enum XML_Error )0);
  }
#line 2160
  parser->m_eventPtr = start;
#line 2161
  return ((enum XML_Error )5);
  case -2: 
#line 2163
  if (! parser->m_parsingStatus.finalBuffer) {
#line 2164
    *endPtr = start;
#line 2165
    return ((enum XML_Error )0);
  }
#line 2167
  parser->m_eventPtr = start;
#line 2168
  return ((enum XML_Error )6);
  }
#line 2170
  parser->m_processor = & externalEntityInitProcessor3;
#line 2171
  tmp___0 = externalEntityInitProcessor3(parser, start, end, endPtr);
#line 2171
  return (tmp___0);
}
}
#line 2174 "xmlparse.c"
static enum XML_Error externalEntityInitProcessor3(XML_Parser parser , char const   *start ,
                                                   char const   *end , char const   **endPtr ) 
{ 
  int tok ;
  char const   *next ;
  enum XML_Error result ;
  enum XML_Error tmp ;

  {
#line 2181
  next = start;
#line 2182
  parser->m_eventPtr = start;
#line 2183
  tok = (*((parser->m_encoding)->scanners[1]))(parser->m_encoding, start, end, & next);
#line 2184
  parser->m_eventEndPtr = next;
#line 2186
  switch (tok) {
  case 12: 
#line 2190
  result = processXmlDecl(parser, 1, start, next);
#line 2191
  if ((unsigned int )result != 0U) {
#line 2192
    return (result);
  }
#line 2193
  switch ((unsigned int )parser->m_parsingStatus.parsing) {
  case 3U: 
#line 2195
  *endPtr = next;
#line 2196
  return ((enum XML_Error )0);
  case 2U: 
#line 2198
  return ((enum XML_Error )35);
  default: 
#line 2200
  start = next;
  }
#line 2203
  break;
  case -1: 
#line 2205
  if (! parser->m_parsingStatus.finalBuffer) {
#line 2206
    *endPtr = start;
#line 2207
    return ((enum XML_Error )0);
  }
#line 2209
  return ((enum XML_Error )5);
  case -2: 
#line 2211
  if (! parser->m_parsingStatus.finalBuffer) {
#line 2212
    *endPtr = start;
#line 2213
    return ((enum XML_Error )0);
  }
#line 2215
  return ((enum XML_Error )6);
  }
#line 2217
  parser->m_processor = & externalEntityContentProcessor;
#line 2218
  parser->m_tagLevel = 1;
#line 2219
  tmp = externalEntityContentProcessor(parser, start, end, endPtr);
#line 2219
  return (tmp);
}
}
#line 2222 "xmlparse.c"
static enum XML_Error externalEntityContentProcessor(XML_Parser parser , char const   *start ,
                                                     char const   *end , char const   **endPtr ) 
{ 
  enum XML_Error result ;
  enum XML_Error tmp ;
  XML_Bool tmp___0 ;

  {
#line 2228
  tmp = doContent(parser, 1, parser->m_encoding, start, end, endPtr, (XML_Bool )(! parser->m_parsingStatus.finalBuffer));
#line 2228
  result = tmp;
#line 2230
  if ((unsigned int )result == 0U) {
#line 2231
    tmp___0 = storeRawNames(parser);
#line 2231
    if (! tmp___0) {
#line 2232
      return ((enum XML_Error )1);
    }
  }
#line 2234
  return (result);
}
}
#line 2237 "xmlparse.c"
static enum XML_Error doContent(XML_Parser parser , int startTagLevel , ENCODING const   *enc ,
                                char const   *s , char const   *end , char const   **nextPtr ,
                                XML_Bool haveMore ) 
{ 
  DTD *dtd ;
  char const   **eventPP ;
  char const   **eventEndPP ;
  char const   *next ;
  int tok ;
  int tmp ;
  XML_Char c ;
  XML_Char const   *name ;
  ENTITY *entity ;
  XML_Char ch ;
  int tmp___0 ;
  XML_Char *tmp___1 ;
  NAMED *tmp___2 ;
  enum XML_Error result ;
  XML_Char const   *context ;
  int tmp___3 ;
  TAG *tag ;
  enum XML_Error result___0 ;
  XML_Char *toPtr ;
  void *tmp___4 ;
  void *tmp___5 ;
  char const   *rawNameEnd ;
  char const   *fromPtr ;
  int bufSize ;
  int convLen ;
  char *temp ;
  void *tmp___6 ;
  char const   *rawName ;
  enum XML_Error result___1 ;
  BINDING *bindings ;
  XML_Bool noElmHandlers ;
  TAG_NAME name___0 ;
  int tmp___7 ;
  XML_Char *tmp___8 ;
  BINDING *b ;
  enum XML_Error tmp___9 ;
  int len ;
  char const   *rawName___0 ;
  TAG *tag___0 ;
  int tmp___10 ;
  XML_Char const   *localPart ;
  XML_Char const   *prefix ;
  XML_Char *uri ;
  XML_Char *tmp___11 ;
  XML_Char const   *tmp___12 ;
  XML_Char *tmp___13 ;
  XML_Char *tmp___14 ;
  XML_Char const   *tmp___15 ;
  BINDING *b___0 ;
  enum XML_Error tmp___16 ;
  int n ;
  int tmp___17 ;
  XML_Char buf[4] ;
  int tmp___18 ;
  XML_Char c___0 ;
  enum XML_Error result___2 ;
  ICHAR *dataPtr ;
  void (*charDataHandler)(void *userData , XML_Char const   *s , int len ) ;
  ICHAR *dataPtr___0 ;
  int tmp___19 ;
  int tmp___20 ;

  {
#line 2247
  dtd = parser->m_dtd;
#line 2251
  if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 2252
    eventPP = & parser->m_eventPtr;
#line 2253
    eventEndPP = & parser->m_eventEndPtr;
  } else {
#line 2256
    eventPP = & (parser->m_openInternalEntities)->internalEventPtr;
#line 2257
    eventEndPP = & (parser->m_openInternalEntities)->internalEventEndPtr;
  }
#line 2259
  *eventPP = s;
#line 2261
  while (1) {
#line 2262
    next = s;
#line 2263
    tmp = (*(enc->scanners[1]))(enc, s, end, & next);
#line 2263
    tok = tmp;
#line 2264
    *eventEndPP = next;
#line 2265
    switch (tok) {
    case -3: 
#line 2267
    if (haveMore) {
#line 2268
      *nextPtr = s;
#line 2269
      return ((enum XML_Error )0);
    }
#line 2271
    *eventEndPP = end;
#line 2272
    if (parser->m_characterDataHandler) {
#line 2273
      c = (XML_Char )10;
#line 2274
      (*(parser->m_characterDataHandler))(parser->m_handlerArg, (XML_Char const   *)(& c),
                                          1);
    } else
#line 2276
    if (parser->m_defaultHandler) {
#line 2277
      reportDefault(parser, enc, s, end);
    }
#line 2281
    if (startTagLevel == 0) {
#line 2282
      return ((enum XML_Error )3);
    }
#line 2283
    if (parser->m_tagLevel != startTagLevel) {
#line 2284
      return ((enum XML_Error )13);
    }
#line 2285
    *nextPtr = end;
#line 2286
    return ((enum XML_Error )0);
    case -4: 
#line 2288
    if (haveMore) {
#line 2289
      *nextPtr = s;
#line 2290
      return ((enum XML_Error )0);
    }
#line 2292
    if (startTagLevel > 0) {
#line 2293
      if (parser->m_tagLevel != startTagLevel) {
#line 2294
        return ((enum XML_Error )13);
      }
#line 2295
      *nextPtr = s;
#line 2296
      return ((enum XML_Error )0);
    }
#line 2298
    return ((enum XML_Error )3);
    case 0: 
#line 2300
    *eventPP = next;
#line 2301
    return ((enum XML_Error )4);
    case -1: 
#line 2303
    if (haveMore) {
#line 2304
      *nextPtr = s;
#line 2305
      return ((enum XML_Error )0);
    }
#line 2307
    return ((enum XML_Error )5);
    case -2: 
#line 2309
    if (haveMore) {
#line 2310
      *nextPtr = s;
#line 2311
      return ((enum XML_Error )0);
    }
#line 2313
    return ((enum XML_Error )6);
    case 9: 
#line 2318
    tmp___0 = (*(enc->predefinedEntityName))(enc, s + enc->minBytesPerChar, next - enc->minBytesPerChar);
#line 2318
    ch = (XML_Char )tmp___0;
#line 2321
    if (ch) {
#line 2322
      if (parser->m_characterDataHandler) {
#line 2323
        (*(parser->m_characterDataHandler))(parser->m_handlerArg, (XML_Char const   *)(& ch),
                                            1);
      } else
#line 2324
      if (parser->m_defaultHandler) {
#line 2325
        reportDefault(parser, enc, s, next);
      }
#line 2326
      break;
    }
#line 2328
    tmp___1 = poolStoreString(& dtd->pool, enc, s + enc->minBytesPerChar, next - enc->minBytesPerChar);
#line 2328
    name = (XML_Char const   *)tmp___1;
#line 2331
    if (! name) {
#line 2332
      return ((enum XML_Error )1);
    }
#line 2333
    tmp___2 = lookup(parser, & dtd->generalEntities, name, (size_t )0);
#line 2333
    entity = (ENTITY *)tmp___2;
#line 2334
    dtd->pool.ptr = dtd->pool.start;
#line 2339
    if (! dtd->hasParamEntityRefs) {
#line 2339
      goto _L;
    } else
#line 2339
    if (dtd->standalone) {
      _L: /* CIL Label */ 
#line 2340
      if (! entity) {
#line 2341
        return ((enum XML_Error )11);
      } else
#line 2342
      if (! entity->is_internal) {
#line 2343
        return ((enum XML_Error )24);
      }
    } else
#line 2345
    if (! entity) {
#line 2346
      if (parser->m_skippedEntityHandler) {
#line 2347
        (*(parser->m_skippedEntityHandler))(parser->m_handlerArg, name, 0);
      } else
#line 2348
      if (parser->m_defaultHandler) {
#line 2349
        reportDefault(parser, enc, s, next);
      }
#line 2350
      break;
    }
#line 2352
    if (entity->open) {
#line 2353
      return ((enum XML_Error )12);
    }
#line 2354
    if (entity->notation) {
#line 2355
      return ((enum XML_Error )15);
    }
#line 2356
    if (entity->textPtr) {
#line 2358
      if (! parser->m_defaultExpandInternalEntities) {
#line 2359
        if (parser->m_skippedEntityHandler) {
#line 2360
          (*(parser->m_skippedEntityHandler))(parser->m_handlerArg, entity->name,
                                              0);
        } else
#line 2361
        if (parser->m_defaultHandler) {
#line 2362
          reportDefault(parser, enc, s, next);
        }
#line 2363
        break;
      }
#line 2365
      result = processInternalEntity(parser, entity, (XML_Bool )0);
#line 2366
      if ((unsigned int )result != 0U) {
#line 2367
        return (result);
      }
    } else
#line 2369
    if (parser->m_externalEntityRefHandler) {
#line 2371
      entity->open = (XML_Bool )1;
#line 2372
      context = getContext(parser);
#line 2373
      entity->open = (XML_Bool )0;
#line 2374
      if (! context) {
#line 2375
        return ((enum XML_Error )1);
      }
#line 2376
      tmp___3 = (*(parser->m_externalEntityRefHandler))(parser->m_externalEntityRefHandlerArg,
                                                        context, entity->base, entity->systemId,
                                                        entity->publicId);
#line 2376
      if (! tmp___3) {
#line 2381
        return ((enum XML_Error )21);
      }
#line 2382
      parser->m_tempPool.ptr = parser->m_tempPool.start;
    } else
#line 2384
    if (parser->m_defaultHandler) {
#line 2385
      reportDefault(parser, enc, s, next);
    }
#line 2386
    break;
    case 1: 
    case 2: 
#line 2395
    if (parser->m_freeTagList) {
#line 2396
      tag = parser->m_freeTagList;
#line 2397
      parser->m_freeTagList = (parser->m_freeTagList)->parent;
    } else {
#line 2400
      tmp___4 = (*(parser->m_mem.malloc_fcn))(sizeof(TAG ));
#line 2400
      tag = (TAG *)tmp___4;
#line 2401
      if (! tag) {
#line 2402
        return ((enum XML_Error )1);
      }
#line 2403
      tmp___5 = (*(parser->m_mem.malloc_fcn))((size_t )32);
#line 2403
      tag->buf = (char *)tmp___5;
#line 2404
      if (! tag->buf) {
#line 2405
        (*(parser->m_mem.free_fcn))((void *)tag);
#line 2406
        return ((enum XML_Error )1);
      }
#line 2408
      tag->bufEnd = tag->buf + 32;
    }
#line 2410
    tag->bindings = (BINDING *)((void *)0);
#line 2411
    tag->parent = parser->m_tagStack;
#line 2412
    parser->m_tagStack = tag;
#line 2413
    tag->name.localPart = (XML_Char const   *)((void *)0);
#line 2414
    tag->name.prefix = (XML_Char const   *)((void *)0);
#line 2415
    tag->rawName = s + enc->minBytesPerChar;
#line 2416
    tag->rawNameLength = (*(enc->nameLength))(enc, tag->rawName);
#line 2417
    (parser->m_tagLevel) ++;
#line 2419
    rawNameEnd = tag->rawName + tag->rawNameLength;
#line 2420
    fromPtr = tag->rawName;
#line 2421
    toPtr = tag->buf;
#line 2422
    while (1) {
#line 2425
      (*(enc->utf8Convert))(enc, & fromPtr, rawNameEnd, & toPtr, (char const   *)(tag->bufEnd - 1));
#line 2428
      convLen = (int )(toPtr - tag->buf);
#line 2429
      if ((unsigned long )fromPtr == (unsigned long )rawNameEnd) {
#line 2430
        tag->name.strLen = convLen;
#line 2431
        break;
      }
#line 2433
      bufSize = (int )(tag->bufEnd - tag->buf) << 1;
#line 2435
      tmp___6 = (*(parser->m_mem.realloc_fcn))((void *)tag->buf, (size_t )bufSize);
#line 2435
      temp = (char *)tmp___6;
#line 2436
      if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 2437
        return ((enum XML_Error )1);
      }
#line 2438
      tag->buf = temp;
#line 2439
      tag->bufEnd = temp + bufSize;
#line 2440
      toPtr = temp + convLen;
    }
#line 2444
    tag->name.str = (XML_Char const   *)tag->buf;
#line 2445
    *toPtr = (XML_Char )'\000';
#line 2446
    result___0 = storeAtts(parser, enc, s, & tag->name, & tag->bindings);
#line 2447
    if (result___0) {
#line 2448
      return (result___0);
    }
#line 2449
    if (parser->m_startElementHandler) {
#line 2450
      (*(parser->m_startElementHandler))(parser->m_handlerArg, tag->name.str, (XML_Char const   **)parser->m_atts);
    } else
#line 2452
    if (parser->m_defaultHandler) {
#line 2453
      reportDefault(parser, enc, s, next);
    }
#line 2454
    poolClear(& parser->m_tempPool);
#line 2455
    break;
    case 3: 
    case 4: 
#line 2461
    rawName = s + enc->minBytesPerChar;
#line 2463
    bindings = (BINDING *)((void *)0);
#line 2464
    noElmHandlers = (XML_Bool )1;
#line 2466
    tmp___7 = (*(enc->nameLength))(enc, rawName);
#line 2466
    tmp___8 = poolStoreString(& parser->m_tempPool, enc, rawName, rawName + tmp___7);
#line 2466
    name___0.str = (XML_Char const   *)tmp___8;
#line 2468
    if (! name___0.str) {
#line 2469
      return ((enum XML_Error )1);
    }
#line 2470
    parser->m_tempPool.start = parser->m_tempPool.ptr;
#line 2471
    result___1 = storeAtts(parser, enc, s, & name___0, & bindings);
#line 2472
    if (result___1) {
#line 2473
      return (result___1);
    }
#line 2474
    parser->m_tempPool.start = parser->m_tempPool.ptr;
#line 2475
    if (parser->m_startElementHandler) {
#line 2476
      (*(parser->m_startElementHandler))(parser->m_handlerArg, name___0.str, (XML_Char const   **)parser->m_atts);
#line 2477
      noElmHandlers = (XML_Bool )0;
    }
#line 2479
    if (parser->m_endElementHandler) {
#line 2480
      if (parser->m_startElementHandler) {
#line 2481
        *eventPP = *eventEndPP;
      }
#line 2482
      (*(parser->m_endElementHandler))(parser->m_handlerArg, name___0.str);
#line 2483
      noElmHandlers = (XML_Bool )0;
    }
#line 2485
    if (noElmHandlers) {
#line 2485
      if (parser->m_defaultHandler) {
#line 2486
        reportDefault(parser, enc, s, next);
      }
    }
#line 2487
    poolClear(& parser->m_tempPool);
#line 2488
    while (bindings) {
#line 2489
      b = bindings;
#line 2490
      if (parser->m_endNamespaceDeclHandler) {
#line 2491
        (*(parser->m_endNamespaceDeclHandler))(parser->m_handlerArg, (b->prefix)->name);
      }
#line 2492
      bindings = bindings->nextTagBinding;
#line 2493
      b->nextTagBinding = parser->m_freeBindingList;
#line 2494
      parser->m_freeBindingList = b;
#line 2495
      (b->prefix)->binding = b->prevPrefixBinding;
    }
#line 2498
    if (parser->m_tagLevel == 0) {
#line 2499
      tmp___9 = epilogProcessor(parser, next, end, nextPtr);
#line 2499
      return (tmp___9);
    }
#line 2500
    break;
    case 5: 
#line 2502
    if (parser->m_tagLevel == startTagLevel) {
#line 2503
      return ((enum XML_Error )13);
    } else {
#line 2507
      tag___0 = parser->m_tagStack;
#line 2508
      parser->m_tagStack = tag___0->parent;
#line 2509
      tag___0->parent = parser->m_freeTagList;
#line 2510
      parser->m_freeTagList = tag___0;
#line 2511
      rawName___0 = s + enc->minBytesPerChar * 2;
#line 2512
      len = (*(enc->nameLength))(enc, rawName___0);
#line 2513
      if (len != tag___0->rawNameLength) {
#line 2515
        *eventPP = rawName___0;
#line 2516
        return ((enum XML_Error )7);
      } else {
#line 2513
        tmp___10 = memcmp((void const   *)tag___0->rawName, (void const   *)rawName___0,
                          (size_t )len);
#line 2513
        if (tmp___10 != 0) {
#line 2515
          *eventPP = rawName___0;
#line 2516
          return ((enum XML_Error )7);
        }
      }
#line 2518
      (parser->m_tagLevel) --;
#line 2519
      if (parser->m_endElementHandler) {
#line 2523
        localPart = tag___0->name.localPart;
#line 2524
        if (parser->m_ns) {
#line 2524
          if (localPart) {
#line 2529
            uri = (XML_Char *)tag___0->name.str + tag___0->name.uriLen;
#line 2531
            while (*localPart) {
#line 2531
              tmp___11 = uri;
#line 2531
              uri ++;
#line 2531
              tmp___12 = localPart;
#line 2531
              localPart ++;
#line 2531
              *tmp___11 = (XML_Char )*tmp___12;
            }
#line 2532
            prefix = (XML_Char const   *)((XML_Char *)tag___0->name.prefix);
#line 2533
            if (parser->m_ns_triplets) {
#line 2533
              if (prefix) {
#line 2534
                tmp___13 = uri;
#line 2534
                uri ++;
#line 2534
                *tmp___13 = parser->m_namespaceSeparator;
#line 2535
                while (*prefix) {
#line 2535
                  tmp___14 = uri;
#line 2535
                  uri ++;
#line 2535
                  tmp___15 = prefix;
#line 2535
                  prefix ++;
#line 2535
                  *tmp___14 = (XML_Char )*tmp___15;
                }
              }
            }
#line 2537
            *uri = (XML_Char )'\000';
          }
        }
#line 2539
        (*(parser->m_endElementHandler))(parser->m_handlerArg, tag___0->name.str);
      } else
#line 2541
      if (parser->m_defaultHandler) {
#line 2542
        reportDefault(parser, enc, s, next);
      }
#line 2543
      while (tag___0->bindings) {
#line 2544
        b___0 = tag___0->bindings;
#line 2545
        if (parser->m_endNamespaceDeclHandler) {
#line 2546
          (*(parser->m_endNamespaceDeclHandler))(parser->m_handlerArg, (b___0->prefix)->name);
        }
#line 2547
        tag___0->bindings = (tag___0->bindings)->nextTagBinding;
#line 2548
        b___0->nextTagBinding = parser->m_freeBindingList;
#line 2549
        parser->m_freeBindingList = b___0;
#line 2550
        (b___0->prefix)->binding = b___0->prevPrefixBinding;
      }
#line 2552
      if (parser->m_tagLevel == 0) {
#line 2553
        tmp___16 = epilogProcessor(parser, next, end, nextPtr);
#line 2553
        return (tmp___16);
      }
    }
#line 2555
    break;
    case 10: 
#line 2558
    tmp___17 = (*(enc->charRefNumber))(enc, s);
#line 2558
    n = tmp___17;
#line 2559
    if (n < 0) {
#line 2560
      return ((enum XML_Error )14);
    }
#line 2561
    if (parser->m_characterDataHandler) {
#line 2563
      tmp___18 = XmlUtf8Encode(n, buf);
#line 2563
      (*(parser->m_characterDataHandler))(parser->m_handlerArg, (XML_Char const   *)(buf),
                                          tmp___18);
    } else
#line 2565
    if (parser->m_defaultHandler) {
#line 2566
      reportDefault(parser, enc, s, next);
    }
#line 2568
    break;
    case 12: 
#line 2570
    return ((enum XML_Error )17);
    case 7: 
#line 2572
    if (parser->m_characterDataHandler) {
#line 2573
      c___0 = (XML_Char )10;
#line 2574
      (*(parser->m_characterDataHandler))(parser->m_handlerArg, (XML_Char const   *)(& c___0),
                                          1);
    } else
#line 2576
    if (parser->m_defaultHandler) {
#line 2577
      reportDefault(parser, enc, s, next);
    }
#line 2578
    break;
    case 8: 
#line 2582
    if (parser->m_startCdataSectionHandler) {
#line 2583
      (*(parser->m_startCdataSectionHandler))(parser->m_handlerArg);
    } else
#line 2600
    if (parser->m_defaultHandler) {
#line 2601
      reportDefault(parser, enc, s, next);
    }
#line 2602
    result___2 = doCdataSection(parser, enc, & next, end, nextPtr, haveMore);
#line 2603
    if ((unsigned int )result___2 != 0U) {
#line 2604
      return (result___2);
    } else
#line 2605
    if (! next) {
#line 2606
      parser->m_processor = & cdataSectionProcessor;
#line 2607
      return (result___2);
    }
#line 2610
    break;
    case -5: 
#line 2612
    if (haveMore) {
#line 2613
      *nextPtr = s;
#line 2614
      return ((enum XML_Error )0);
    }
#line 2616
    if (parser->m_characterDataHandler) {
#line 2617
      if (! enc->isUtf8) {
#line 2618
        dataPtr = parser->m_dataBuf;
#line 2619
        (*(enc->utf8Convert))(enc, & s, end, & dataPtr, (char const   *)parser->m_dataBufEnd);
#line 2620
        (*(parser->m_characterDataHandler))(parser->m_handlerArg, (XML_Char const   *)parser->m_dataBuf,
                                            (int )(dataPtr - parser->m_dataBuf));
      } else {
#line 2624
        (*(parser->m_characterDataHandler))(parser->m_handlerArg, (XML_Char const   *)((XML_Char *)s),
                                            (int )((XML_Char *)end - (XML_Char *)s));
      }
    } else
#line 2628
    if (parser->m_defaultHandler) {
#line 2629
      reportDefault(parser, enc, s, end);
    }
#line 2633
    if (startTagLevel == 0) {
#line 2634
      *eventPP = end;
#line 2635
      return ((enum XML_Error )3);
    }
#line 2637
    if (parser->m_tagLevel != startTagLevel) {
#line 2638
      *eventPP = end;
#line 2639
      return ((enum XML_Error )13);
    }
#line 2641
    *nextPtr = end;
#line 2642
    return ((enum XML_Error )0);
    case 6: 
#line 2645
    charDataHandler = parser->m_characterDataHandler;
#line 2646
    if (charDataHandler) {
#line 2647
      if (! enc->isUtf8) {
#line 2648
        while (1) {
#line 2649
          dataPtr___0 = parser->m_dataBuf;
#line 2650
          (*(enc->utf8Convert))(enc, & s, next, & dataPtr___0, (char const   *)parser->m_dataBufEnd);
#line 2651
          *eventEndPP = s;
#line 2652
          (*charDataHandler)(parser->m_handlerArg, (XML_Char const   *)parser->m_dataBuf,
                             (int )(dataPtr___0 - parser->m_dataBuf));
#line 2654
          if ((unsigned long )s == (unsigned long )next) {
#line 2655
            break;
          }
#line 2656
          *eventPP = s;
        }
      } else {
#line 2660
        (*charDataHandler)(parser->m_handlerArg, (XML_Char const   *)((XML_Char *)s),
                           (int )((XML_Char *)next - (XML_Char *)s));
      }
    } else
#line 2664
    if (parser->m_defaultHandler) {
#line 2665
      reportDefault(parser, enc, s, next);
    }
#line 2667
    break;
    case 11: 
#line 2669
    tmp___19 = reportProcessingInstruction(parser, enc, s, next);
#line 2669
    if (! tmp___19) {
#line 2670
      return ((enum XML_Error )1);
    }
#line 2671
    break;
    case 13: 
#line 2673
    tmp___20 = reportComment(parser, enc, s, next);
#line 2673
    if (! tmp___20) {
#line 2674
      return ((enum XML_Error )1);
    }
#line 2675
    break;
    default: 
#line 2677
    if (parser->m_defaultHandler) {
#line 2678
      reportDefault(parser, enc, s, next);
    }
#line 2679
    break;
    }
#line 2681
    s = next;
#line 2681
    *eventPP = s;
#line 2682
    switch ((unsigned int )parser->m_parsingStatus.parsing) {
    case 3U: 
#line 2684
    *nextPtr = next;
#line 2685
    return ((enum XML_Error )0);
    case 2U: 
#line 2687
    return ((enum XML_Error )35);
    default: ;
    }
  }
}
}
#line 2704 "xmlparse.c"
static enum XML_Error storeAtts(XML_Parser parser , ENCODING const   *enc , char const   *attStr ,
                                TAG_NAME *tagNamePtr , BINDING **bindingsPtr ) 
{ 
  DTD *dtd ;
  ELEMENT_TYPE *elementType ;
  int nDefaultAtts ;
  XML_Char const   **appAtts ;
  int attIndex ;
  int prefixLen ;
  int i ;
  int n ;
  XML_Char *uri ;
  int nPrefixes ;
  BINDING *binding ;
  XML_Char const   *localPart ;
  NAMED *tmp ;
  XML_Char const   *name ;
  XML_Char const   *tmp___0 ;
  NAMED *tmp___1 ;
  int tmp___2 ;
  int oldAttsSize ;
  ATTRIBUTE *temp ;
  void *tmp___3 ;
  ATTRIBUTE *currAtt ;
  ATTRIBUTE_ID *attId ;
  int tmp___4 ;
  ATTRIBUTE_ID *tmp___5 ;
  int tmp___6 ;
  enum XML_Error result ;
  XML_Bool isCdata ;
  int j ;
  XML_Char *tmp___7 ;
  enum XML_Error result___0 ;
  enum XML_Error tmp___8 ;
  DEFAULT_ATTRIBUTE const   *da ;
  enum XML_Error result___1 ;
  enum XML_Error tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int j___0 ;
  unsigned long version ;
  int nsAttsSize ;
  NS_ATT *temp___0 ;
  unsigned char tmp___14 ;
  void *tmp___15 ;
  XML_Char const   *s ;
  ATTRIBUTE_ID *id ;
  BINDING const   *b ;
  unsigned long uriHash ;
  NAMED *tmp___16 ;
  XML_Char c ;
  XML_Char *tmp___18 ;
  int tmp___19 ;
  XML_Bool tmp___20 ;
  XML_Char const   *tmp___21 ;
  XML_Char c___0 ;
  XML_Char *tmp___23 ;
  int tmp___24 ;
  XML_Bool tmp___25 ;
  XML_Char const   *tmp___26 ;
  unsigned char step ;
  unsigned long mask ;
  XML_Char const   *s1 ;
  XML_Char const   *s2 ;
  XML_Char *tmp___28 ;
  int tmp___29 ;
  XML_Bool tmp___30 ;
  XML_Char const   *tmp___31 ;
  XML_Char const   *tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  TAG *p ;
  void *tmp___35 ;

  {
#line 2709
  dtd = parser->m_dtd;
#line 2713
  attIndex = 0;
#line 2718
  nPrefixes = 0;
#line 2723
  tmp = lookup(parser, & dtd->elementTypes, tagNamePtr->str, (size_t )0);
#line 2723
  elementType = (ELEMENT_TYPE *)tmp;
#line 2724
  if (! elementType) {
#line 2725
    tmp___0 = poolCopyString(& dtd->pool, tagNamePtr->str);
#line 2725
    name = tmp___0;
#line 2726
    if (! name) {
#line 2727
      return ((enum XML_Error )1);
    }
#line 2728
    tmp___1 = lookup(parser, & dtd->elementTypes, name, sizeof(ELEMENT_TYPE ));
#line 2728
    elementType = (ELEMENT_TYPE *)tmp___1;
#line 2730
    if (! elementType) {
#line 2731
      return ((enum XML_Error )1);
    }
#line 2732
    if (parser->m_ns) {
#line 2732
      tmp___2 = setElementTypePrefix(parser, elementType);
#line 2732
      if (! tmp___2) {
#line 2733
        return ((enum XML_Error )1);
      }
    }
  }
#line 2735
  nDefaultAtts = elementType->nDefaultAtts;
#line 2738
  n = (*(enc->getAtts))(enc, attStr, parser->m_attsSize, parser->m_atts);
#line 2739
  if (n + nDefaultAtts > parser->m_attsSize) {
#line 2740
    oldAttsSize = parser->m_attsSize;
#line 2745
    parser->m_attsSize = (n + nDefaultAtts) + 16;
#line 2746
    tmp___3 = (*(parser->m_mem.realloc_fcn))((void *)parser->m_atts, (unsigned long )parser->m_attsSize * sizeof(ATTRIBUTE ));
#line 2746
    temp = (ATTRIBUTE *)tmp___3;
#line 2747
    if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 2748
      return ((enum XML_Error )1);
    }
#line 2749
    parser->m_atts = temp;
#line 2756
    if (n > oldAttsSize) {
#line 2757
      (*(enc->getAtts))(enc, attStr, n, parser->m_atts);
    }
  }
#line 2760
  appAtts = (XML_Char const   **)parser->m_atts;
#line 2761
  i = 0;
#line 2761
  while (i < n) {
#line 2762
    currAtt = parser->m_atts + i;
#line 2767
    tmp___4 = (*(enc->nameLength))(enc, currAtt->name);
#line 2767
    tmp___5 = getAttributeId(parser, enc, currAtt->name, currAtt->name + tmp___4);
#line 2767
    attId = tmp___5;
#line 2770
    if (! attId) {
#line 2771
      return ((enum XML_Error )1);
    }
#line 2784
    if (*(attId->name + -1)) {
#line 2785
      if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 2786
        parser->m_eventPtr = (parser->m_atts + i)->name;
      }
#line 2787
      return ((enum XML_Error )8);
    }
#line 2789
    *(attId->name + -1) = (XML_Char )1;
#line 2790
    tmp___6 = attIndex;
#line 2790
    attIndex ++;
#line 2790
    *(appAtts + tmp___6) = (XML_Char const   *)attId->name;
#line 2791
    if (! (parser->m_atts + i)->normalized) {
#line 2793
      isCdata = (XML_Bool )1;
#line 2796
      if (attId->maybeTokenized) {
#line 2798
        j = 0;
#line 2798
        while (j < nDefaultAtts) {
#line 2799
          if ((unsigned long )attId == (unsigned long )(elementType->defaultAtts + j)->id) {
#line 2800
            isCdata = (elementType->defaultAtts + j)->isCdata;
#line 2801
            break;
          }
#line 2798
          j ++;
        }
      }
#line 2807
      result = storeAttributeValue(parser, enc, isCdata, (parser->m_atts + i)->valuePtr,
                                   (parser->m_atts + i)->valueEnd, & parser->m_tempPool);
#line 2810
      if (result) {
#line 2811
        return (result);
      }
#line 2812
      *(appAtts + attIndex) = (XML_Char const   *)parser->m_tempPool.start;
#line 2813
      parser->m_tempPool.start = parser->m_tempPool.ptr;
    } else {
#line 2817
      tmp___7 = poolStoreString(& parser->m_tempPool, enc, (parser->m_atts + i)->valuePtr,
                                (parser->m_atts + i)->valueEnd);
#line 2817
      *(appAtts + attIndex) = (XML_Char const   *)tmp___7;
#line 2819
      if ((unsigned long )*(appAtts + attIndex) == (unsigned long )((XML_Char const   *)0)) {
#line 2820
        return ((enum XML_Error )1);
      }
#line 2821
      parser->m_tempPool.start = parser->m_tempPool.ptr;
    }
#line 2824
    if (attId->prefix) {
#line 2825
      if (attId->xmlns) {
#line 2827
        tmp___8 = addBinding(parser, attId->prefix, (ATTRIBUTE_ID const   *)attId,
                             *(appAtts + attIndex), bindingsPtr);
#line 2827
        result___0 = tmp___8;
#line 2829
        if (result___0) {
#line 2830
          return (result___0);
        }
#line 2831
        attIndex --;
      } else {
#line 2835
        attIndex ++;
#line 2836
        nPrefixes ++;
#line 2837
        *(attId->name + -1) = (XML_Char )2;
      }
    } else {
#line 2841
      attIndex ++;
    }
#line 2761
    i ++;
  }
#line 2845
  parser->m_nSpecifiedAtts = attIndex;
#line 2846
  if (elementType->idAtt) {
#line 2846
    if (*((elementType->idAtt)->name + -1)) {
#line 2847
      i = 0;
#line 2847
      while (i < attIndex) {
#line 2848
        if ((unsigned long )*(appAtts + i) == (unsigned long )(elementType->idAtt)->name) {
#line 2849
          parser->m_idAttIndex = i;
#line 2850
          break;
        }
#line 2847
        i += 2;
      }
    } else {
#line 2854
      parser->m_idAttIndex = -1;
    }
  } else {
#line 2854
    parser->m_idAttIndex = -1;
  }
#line 2857
  i = 0;
#line 2857
  while (i < nDefaultAtts) {
#line 2858
    da = (DEFAULT_ATTRIBUTE const   *)(elementType->defaultAtts + i);
#line 2859
    if (! *((da->id)->name + -1)) {
#line 2859
      if (da->value) {
#line 2860
        if ((da->id)->prefix) {
#line 2861
          if ((da->id)->xmlns) {
#line 2862
            tmp___9 = addBinding(parser, (PREFIX *)(da->id)->prefix, (ATTRIBUTE_ID const   *)da->id,
                                 (XML_Char const   *)da->value, bindingsPtr);
#line 2862
            result___1 = tmp___9;
#line 2864
            if (result___1) {
#line 2865
              return (result___1);
            }
          } else {
#line 2868
            *((da->id)->name + -1) = (XML_Char )2;
#line 2869
            nPrefixes ++;
#line 2870
            tmp___10 = attIndex;
#line 2870
            attIndex ++;
#line 2870
            *(appAtts + tmp___10) = (XML_Char const   *)(da->id)->name;
#line 2871
            tmp___11 = attIndex;
#line 2871
            attIndex ++;
#line 2871
            *(appAtts + tmp___11) = (XML_Char const   *)da->value;
          }
        } else {
#line 2875
          *((da->id)->name + -1) = (XML_Char )1;
#line 2876
          tmp___12 = attIndex;
#line 2876
          attIndex ++;
#line 2876
          *(appAtts + tmp___12) = (XML_Char const   *)(da->id)->name;
#line 2877
          tmp___13 = attIndex;
#line 2877
          attIndex ++;
#line 2877
          *(appAtts + tmp___13) = (XML_Char const   *)da->value;
        }
      }
    }
#line 2857
    i ++;
  }
#line 2881
  *(appAtts + attIndex) = (XML_Char const   *)0;
#line 2885
  i = 0;
#line 2886
  if (nPrefixes) {
#line 2888
    version = parser->m_nsAttsVersion;
#line 2889
    nsAttsSize = 1 << (int )parser->m_nsAttsPower;
#line 2891
    if ((nPrefixes << 1) >> (int )parser->m_nsAttsPower) {
#line 2894
      while (1) {
#line 2894
        tmp___14 = parser->m_nsAttsPower;
#line 2894
        parser->m_nsAttsPower = (unsigned char )((int )parser->m_nsAttsPower + 1);
#line 2894
        if (! (nPrefixes >> (int )tmp___14)) {
#line 2894
          break;
        }
      }
#line 2895
      if ((int )parser->m_nsAttsPower < 3) {
#line 2896
        parser->m_nsAttsPower = (unsigned char)3;
      }
#line 2897
      nsAttsSize = 1 << (int )parser->m_nsAttsPower;
#line 2898
      tmp___15 = (*(parser->m_mem.realloc_fcn))((void *)parser->m_nsAtts, (unsigned long )nsAttsSize * sizeof(NS_ATT ));
#line 2898
      temp___0 = (NS_ATT *)tmp___15;
#line 2899
      if (! temp___0) {
#line 2900
        return ((enum XML_Error )1);
      }
#line 2901
      parser->m_nsAtts = temp___0;
#line 2902
      version = 0UL;
    }
#line 2905
    if (! version) {
#line 2906
      version = 4294967295UL;
#line 2907
      j___0 = nsAttsSize;
#line 2907
      while (j___0 != 0) {
#line 2908
        j___0 --;
#line 2908
        (parser->m_nsAtts + j___0)->version = version;
      }
    }
#line 2910
    version --;
#line 2910
    parser->m_nsAttsVersion = version;
#line 2913
    while (i < attIndex) {
#line 2914
      s = *(appAtts + i);
#line 2915
      if ((int const   )*(s + -1) == 2) {
#line 2918
        uriHash = parser->m_hash_secret_salt;
#line 2919
        *((XML_Char *)s + -1) = (XML_Char )0;
#line 2920
        tmp___16 = lookup(parser, & dtd->attributeIds, s, (size_t )0);
#line 2920
        id = (ATTRIBUTE_ID *)tmp___16;
#line 2921
        b = (BINDING const   *)(id->prefix)->binding;
#line 2922
        if (! b) {
#line 2923
          return ((enum XML_Error )27);
        }
#line 2926
        j___0 = 0;
#line 2926
        while (j___0 < (int )b->uriLen) {
#line 2927
          c = *(b->uri + j___0);
#line 2928
          if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
#line 2928
            tmp___20 = poolGrow(& parser->m_tempPool);
#line 2928
            if (tmp___20) {
#line 2928
              tmp___18 = parser->m_tempPool.ptr;
#line 2928
              (parser->m_tempPool.ptr) ++;
#line 2928
              *tmp___18 = c;
#line 2928
              tmp___19 = 1;
            } else {
#line 2928
              tmp___19 = 0;
            }
          } else {
#line 2928
            tmp___18 = parser->m_tempPool.ptr;
#line 2928
            (parser->m_tempPool.ptr) ++;
#line 2928
            *tmp___18 = c;
#line 2928
            tmp___19 = 1;
          }
#line 2928
          if (! tmp___19) {
#line 2929
            return ((enum XML_Error )1);
          }
#line 2930
          uriHash = uriHash * 1000003UL ^ (unsigned long )((unsigned char )c);
#line 2926
          j___0 ++;
        }
#line 2932
        while (1) {
#line 2932
          tmp___21 = s;
#line 2932
          s ++;
#line 2932
          if (! ((int const   )*tmp___21 != 58)) {
#line 2932
            break;
          }
        }
#line 2934
        while (1) {
#line 2935
          c___0 = (XML_Char )*s;
#line 2936
          if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
#line 2936
            tmp___25 = poolGrow(& parser->m_tempPool);
#line 2936
            if (tmp___25) {
#line 2936
              tmp___23 = parser->m_tempPool.ptr;
#line 2936
              (parser->m_tempPool.ptr) ++;
#line 2936
              *tmp___23 = (XML_Char )*s;
#line 2936
              tmp___24 = 1;
            } else {
#line 2936
              tmp___24 = 0;
            }
          } else {
#line 2936
            tmp___23 = parser->m_tempPool.ptr;
#line 2936
            (parser->m_tempPool.ptr) ++;
#line 2936
            *tmp___23 = (XML_Char )*s;
#line 2936
            tmp___24 = 1;
          }
#line 2936
          if (! tmp___24) {
#line 2937
            return ((enum XML_Error )1);
          }
#line 2938
          uriHash = uriHash * 1000003UL ^ (unsigned long )((unsigned char )c___0);
#line 2934
          tmp___26 = s;
#line 2934
          s ++;
#line 2934
          if (! *tmp___26) {
#line 2934
            break;
          }
        }
#line 2944
        step = (unsigned char)0;
#line 2945
        mask = (unsigned long )(nsAttsSize - 1);
#line 2946
        j___0 = (int )(uriHash & mask);
#line 2947
        while ((parser->m_nsAtts + j___0)->version == version) {
#line 2949
          if (uriHash == (parser->m_nsAtts + j___0)->hash) {
#line 2950
            s1 = (XML_Char const   *)parser->m_tempPool.start;
#line 2951
            s2 = (parser->m_nsAtts + j___0)->uriName;
#line 2953
            while (1) {
#line 2953
              if ((int const   )*s1 == (int const   )*s2) {
#line 2953
                if (! ((int const   )*s1 != 0)) {
#line 2953
                  break;
                }
              } else {
#line 2953
                break;
              }
#line 2953
              s1 ++;
#line 2953
              s2 ++;
            }
#line 2954
            if ((int const   )*s1 == 0) {
#line 2955
              return ((enum XML_Error )8);
            }
          }
#line 2957
          if (! step) {
#line 2958
            step = (unsigned char )((((uriHash & ~ mask) >> ((int )parser->m_nsAttsPower - 1)) & (mask >> 2)) | 1UL);
          }
#line 2959
          if (j___0 < (int )step) {
#line 2959
            j___0 += nsAttsSize - (int )step;
          } else {
#line 2959
            j___0 -= (int )step;
          }
        }
#line 2963
        if (parser->m_ns_triplets) {
#line 2964
          *(parser->m_tempPool.ptr + -1) = parser->m_namespaceSeparator;
#line 2965
          s = (b->prefix)->name;
#line 2966
          while (1) {
#line 2967
            if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
#line 2967
              tmp___30 = poolGrow(& parser->m_tempPool);
#line 2967
              if (tmp___30) {
#line 2967
                tmp___28 = parser->m_tempPool.ptr;
#line 2967
                (parser->m_tempPool.ptr) ++;
#line 2967
                *tmp___28 = (XML_Char )*s;
#line 2967
                tmp___29 = 1;
              } else {
#line 2967
                tmp___29 = 0;
              }
            } else {
#line 2967
              tmp___28 = parser->m_tempPool.ptr;
#line 2967
              (parser->m_tempPool.ptr) ++;
#line 2967
              *tmp___28 = (XML_Char )*s;
#line 2967
              tmp___29 = 1;
            }
#line 2967
            if (! tmp___29) {
#line 2968
              return ((enum XML_Error )1);
            }
#line 2966
            tmp___31 = s;
#line 2966
            s ++;
#line 2966
            if (! *tmp___31) {
#line 2966
              break;
            }
          }
        }
#line 2973
        s = (XML_Char const   *)parser->m_tempPool.start;
#line 2974
        parser->m_tempPool.start = parser->m_tempPool.ptr;
#line 2975
        *(appAtts + i) = s;
#line 2978
        (parser->m_nsAtts + j___0)->version = version;
#line 2979
        (parser->m_nsAtts + j___0)->hash = uriHash;
#line 2980
        (parser->m_nsAtts + j___0)->uriName = s;
#line 2982
        nPrefixes --;
#line 2982
        if (! nPrefixes) {
#line 2983
          i += 2;
#line 2984
          break;
        }
      } else {
#line 2988
        *((XML_Char *)s + -1) = (XML_Char )0;
      }
#line 2913
      i += 2;
    }
  }
#line 2992
  while (i < attIndex) {
#line 2993
    *((XML_Char *)*(appAtts + i) + -1) = (XML_Char )0;
#line 2992
    i += 2;
  }
#line 2994
  binding = *bindingsPtr;
#line 2994
  while (binding) {
#line 2995
    *((binding->attId)->name + -1) = (XML_Char )0;
#line 2994
    binding = binding->nextTagBinding;
  }
#line 2997
  if (! parser->m_ns) {
#line 2998
    return ((enum XML_Error )0);
  }
#line 3001
  if (elementType->prefix) {
#line 3002
    binding = (elementType->prefix)->binding;
#line 3003
    if (! binding) {
#line 3004
      return ((enum XML_Error )27);
    }
#line 3005
    localPart = tagNamePtr->str;
#line 3006
    while (1) {
#line 3006
      tmp___32 = localPart;
#line 3006
      localPart ++;
#line 3006
      if (! ((int const   )*tmp___32 != 58)) {
#line 3006
        break;
      }
    }
  } else
#line 3009
  if (dtd->defaultPrefix.binding) {
#line 3010
    binding = dtd->defaultPrefix.binding;
#line 3011
    localPart = tagNamePtr->str;
  } else {
#line 3014
    return ((enum XML_Error )0);
  }
#line 3015
  prefixLen = 0;
#line 3016
  if (parser->m_ns_triplets) {
#line 3016
    if ((binding->prefix)->name) {
#line 3017
      while (1) {
#line 3017
        tmp___33 = prefixLen;
#line 3017
        prefixLen ++;
#line 3017
        if (! *((binding->prefix)->name + tmp___33)) {
#line 3017
          break;
        }
      }
    }
  }
#line 3020
  tagNamePtr->localPart = localPart;
#line 3021
  tagNamePtr->uriLen = binding->uriLen;
#line 3022
  tagNamePtr->prefix = (binding->prefix)->name;
#line 3023
  tagNamePtr->prefixLen = prefixLen;
#line 3024
  i = 0;
#line 3024
  while (1) {
#line 3024
    tmp___34 = i;
#line 3024
    i ++;
#line 3024
    if (! *(localPart + tmp___34)) {
#line 3024
      break;
    }
  }
#line 3026
  n = (i + binding->uriLen) + prefixLen;
#line 3027
  if (n > binding->uriAlloc) {
#line 3029
    tmp___35 = (*(parser->m_mem.malloc_fcn))((unsigned long )(n + 24) * sizeof(XML_Char ));
#line 3029
    uri = (XML_Char *)tmp___35;
#line 3030
    if (! uri) {
#line 3031
      return ((enum XML_Error )1);
    }
#line 3032
    binding->uriAlloc = n + 24;
#line 3033
    sym_memcpy(uri, binding->uri, (unsigned long )binding->uriLen * sizeof(XML_Char ));
#line 3034
    p = parser->m_tagStack;
#line 3034
    while (p) {
#line 3035
      if ((unsigned long )p->name.str == (unsigned long )binding->uri) {
#line 3036
        p->name.str = (XML_Char const   *)uri;
      }
#line 3034
      p = p->parent;
    }
#line 3037
    (*(parser->m_mem.free_fcn))((void *)binding->uri);
#line 3038
    binding->uri = uri;
  }
#line 3041
  uri = binding->uri + binding->uriLen;
#line 3042
  sym_memcpy(uri, localPart, (unsigned long )i * sizeof(XML_Char ));
#line 3044
  if (prefixLen) {
#line 3045
    uri += i - 1;
#line 3046
    *uri = parser->m_namespaceSeparator;
#line 3047
    sym_memcpy(uri + 1, (binding->prefix)->name, (unsigned long )prefixLen * sizeof(XML_Char ));
  }
#line 3049
  tagNamePtr->str = (XML_Char const   *)binding->uri;
#line 3050
  return ((enum XML_Error )0);
}
}
#line 3060 "xmlparse.c"
static XML_Char const   xmlNamespace[37]  = 
#line 3060
  {      (XML_Char const   )104,      (XML_Char const   )116,      (XML_Char const   )116,      (XML_Char const   )112, 
        (XML_Char const   )58,      (XML_Char const   )47,      (XML_Char const   )47,      (XML_Char const   )119, 
        (XML_Char const   )119,      (XML_Char const   )119,      (XML_Char const   )46,      (XML_Char const   )119, 
        (XML_Char const   )51,      (XML_Char const   )46,      (XML_Char const   )111,      (XML_Char const   )114, 
        (XML_Char const   )103,      (XML_Char const   )47,      (XML_Char const   )88,      (XML_Char const   )77, 
        (XML_Char const   )76,      (XML_Char const   )47,      (XML_Char const   )49,      (XML_Char const   )57, 
        (XML_Char const   )57,      (XML_Char const   )56,      (XML_Char const   )47,      (XML_Char const   )110, 
        (XML_Char const   )97,      (XML_Char const   )109,      (XML_Char const   )101,      (XML_Char const   )115, 
        (XML_Char const   )112,      (XML_Char const   )97,      (XML_Char const   )99,      (XML_Char const   )101, 
        (XML_Char const   )'\000'};
#line 3068 "xmlparse.c"
static int const   xmlLen  =    (int const   )((unsigned long )((int )sizeof(xmlNamespace)) / sizeof(XML_Char ) - 1UL);
#line 3070 "xmlparse.c"
static XML_Char const   xmlnsNamespace[30]  = 
#line 3070
  {      (XML_Char const   )104,      (XML_Char const   )116,      (XML_Char const   )116,      (XML_Char const   )112, 
        (XML_Char const   )58,      (XML_Char const   )47,      (XML_Char const   )47,      (XML_Char const   )119, 
        (XML_Char const   )119,      (XML_Char const   )119,      (XML_Char const   )46,      (XML_Char const   )119, 
        (XML_Char const   )51,      (XML_Char const   )46,      (XML_Char const   )111,      (XML_Char const   )114, 
        (XML_Char const   )103,      (XML_Char const   )47,      (XML_Char const   )50,      (XML_Char const   )48, 
        (XML_Char const   )48,      (XML_Char const   )48,      (XML_Char const   )47,      (XML_Char const   )120, 
        (XML_Char const   )109,      (XML_Char const   )108,      (XML_Char const   )110,      (XML_Char const   )115, 
        (XML_Char const   )47,      (XML_Char const   )'\000'};
#line 3077 "xmlparse.c"
static int const   xmlnsLen  =    (int const   )((unsigned long )((int )sizeof(xmlnsNamespace)) / sizeof(XML_Char ) - 1UL);
#line 3056 "xmlparse.c"
static enum XML_Error addBinding(XML_Parser parser , PREFIX *prefix , ATTRIBUTE_ID const   *attId ,
                                 XML_Char const   *uri , BINDING **bindingsPtr ) 
{ 
  XML_Bool mustBeXML ;
  XML_Bool isXML ;
  XML_Bool isXMLNS ;
  BINDING *b ;
  int len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  XML_Char *temp ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  XML_Char const   *tmp___5 ;

  {
#line 3080
  mustBeXML = (XML_Bool )0;
#line 3081
  isXML = (XML_Bool )1;
#line 3082
  isXMLNS = (XML_Bool )1;
#line 3088
  if ((int const   )*uri == 0) {
#line 3088
    if (prefix->name) {
#line 3089
      return ((enum XML_Error )28);
    }
  }
#line 3091
  if (prefix->name) {
#line 3091
    if ((int const   )*(prefix->name + 0) == 120) {
#line 3091
      if ((int const   )*(prefix->name + 1) == 109) {
#line 3091
        if ((int const   )*(prefix->name + 2) == 108) {
#line 3097
          if ((int const   )*(prefix->name + 3) == 110) {
#line 3097
            if ((int const   )*(prefix->name + 4) == 115) {
#line 3097
              if ((int const   )*(prefix->name + 5) == 0) {
#line 3100
                return ((enum XML_Error )39);
              }
            }
          }
#line 3102
          if ((int const   )*(prefix->name + 3) == 0) {
#line 3103
            mustBeXML = (XML_Bool )1;
          }
        }
      }
    }
  }
#line 3106
  len = 0;
#line 3106
  while (*(uri + len)) {
#line 3107
    if (isXML) {
#line 3107
      if (len > (int )xmlLen) {
#line 3108
        isXML = (XML_Bool )0;
      } else
#line 3107
      if ((int const   )*(uri + len) != (int const   )xmlNamespace[len]) {
#line 3108
        isXML = (XML_Bool )0;
      }
    }
#line 3110
    if (! mustBeXML) {
#line 3110
      if (isXMLNS) {
#line 3110
        if (len > (int )xmlnsLen) {
#line 3112
          isXMLNS = (XML_Bool )0;
        } else
#line 3110
        if ((int const   )*(uri + len) != (int const   )xmlnsNamespace[len]) {
#line 3112
          isXMLNS = (XML_Bool )0;
        }
      }
    }
#line 3106
    len ++;
  }
#line 3114
  if (isXML) {
#line 3114
    if (len == (int )xmlLen) {
#line 3114
      tmp = 1;
    } else {
#line 3114
      tmp = 0;
    }
  } else {
#line 3114
    tmp = 0;
  }
#line 3114
  isXML = (XML_Bool )tmp;
#line 3115
  if (isXMLNS) {
#line 3115
    if (len == (int )xmlnsLen) {
#line 3115
      tmp___0 = 1;
    } else {
#line 3115
      tmp___0 = 0;
    }
  } else {
#line 3115
    tmp___0 = 0;
  }
#line 3115
  isXMLNS = (XML_Bool )tmp___0;
#line 3117
  if ((int )mustBeXML != (int )isXML) {
#line 3118
    if (mustBeXML) {
#line 3118
      tmp___1 = 38;
    } else {
#line 3118
      tmp___1 = 40;
    }
#line 3118
    return ((enum XML_Error )tmp___1);
  }
#line 3121
  if (isXMLNS) {
#line 3122
    return ((enum XML_Error )40);
  }
#line 3124
  if (parser->m_namespaceSeparator) {
#line 3125
    len ++;
  }
#line 3126
  if (parser->m_freeBindingList) {
#line 3127
    b = parser->m_freeBindingList;
#line 3128
    if (len > b->uriAlloc) {
#line 3129
      tmp___2 = (*(parser->m_mem.realloc_fcn))((void *)b->uri, sizeof(XML_Char ) * (unsigned long )(len + 24));
#line 3129
      temp = (XML_Char *)tmp___2;
#line 3131
      if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 3132
        return ((enum XML_Error )1);
      }
#line 3133
      b->uri = temp;
#line 3134
      b->uriAlloc = len + 24;
    }
#line 3136
    parser->m_freeBindingList = b->nextTagBinding;
  } else {
#line 3139
    tmp___3 = (*(parser->m_mem.malloc_fcn))(sizeof(BINDING ));
#line 3139
    b = (BINDING *)tmp___3;
#line 3140
    if (! b) {
#line 3141
      return ((enum XML_Error )1);
    }
#line 3142
    tmp___4 = (*(parser->m_mem.malloc_fcn))(sizeof(XML_Char ) * (unsigned long )(len + 24));
#line 3142
    b->uri = (XML_Char *)tmp___4;
#line 3143
    if (! b->uri) {
#line 3144
      (*(parser->m_mem.free_fcn))((void *)b);
#line 3145
      return ((enum XML_Error )1);
    }
#line 3147
    b->uriAlloc = len + 24;
  }
#line 3149
  b->uriLen = len;
#line 3150
  sym_memcpy(b->uri, uri, (unsigned long )len * sizeof(XML_Char ));
#line 3151
  if (parser->m_namespaceSeparator) {
#line 3152
    *(b->uri + (len - 1)) = parser->m_namespaceSeparator;
  }
#line 3153
  b->prefix = prefix;
#line 3154
  b->attId = attId;
#line 3155
  b->prevPrefixBinding = prefix->binding;
#line 3157
  if ((int const   )*uri == 0) {
#line 3157
    if ((unsigned long )prefix == (unsigned long )(& (parser->m_dtd)->defaultPrefix)) {
#line 3158
      prefix->binding = (BINDING *)((void *)0);
    } else {
#line 3160
      prefix->binding = b;
    }
  } else {
#line 3160
    prefix->binding = b;
  }
#line 3161
  b->nextTagBinding = *bindingsPtr;
#line 3162
  *bindingsPtr = b;
#line 3164
  if (attId) {
#line 3164
    if (parser->m_startNamespaceDeclHandler) {
#line 3165
      if (prefix->binding) {
#line 3165
        tmp___5 = uri;
      } else {
#line 3165
        tmp___5 = (XML_Char const   *)0;
      }
#line 3165
      (*(parser->m_startNamespaceDeclHandler))(parser->m_handlerArg, prefix->name,
                                               tmp___5);
    }
  }
#line 3167
  return ((enum XML_Error )0);
}
}
#line 3173 "xmlparse.c"
static enum XML_Error cdataSectionProcessor(XML_Parser parser , char const   *start ,
                                            char const   *end , char const   **endPtr ) 
{ 
  enum XML_Error result ;
  enum XML_Error tmp ;
  enum XML_Error tmp___0 ;
  enum XML_Error tmp___1 ;

  {
#line 3179
  tmp = doCdataSection(parser, parser->m_encoding, & start, end, endPtr, (XML_Bool )(! parser->m_parsingStatus.finalBuffer));
#line 3179
  result = tmp;
#line 3181
  if ((unsigned int )result != 0U) {
#line 3182
    return (result);
  }
#line 3183
  if (start) {
#line 3184
    if (parser->m_parentParser) {
#line 3185
      parser->m_processor = & externalEntityContentProcessor;
#line 3186
      tmp___0 = externalEntityContentProcessor(parser, start, end, endPtr);
#line 3186
      return (tmp___0);
    } else {
#line 3189
      parser->m_processor = & contentProcessor;
#line 3190
      tmp___1 = contentProcessor(parser, start, end, endPtr);
#line 3190
      return (tmp___1);
    }
  }
#line 3193
  return (result);
}
}
#line 3199 "xmlparse.c"
static enum XML_Error doCdataSection(XML_Parser parser , ENCODING const   *enc , char const   **startPtr ,
                                     char const   *end , char const   **nextPtr ,
                                     XML_Bool haveMore ) 
{ 
  char const   *s ;
  char const   **eventPP ;
  char const   **eventEndPP ;
  char const   *next ;
  int tok ;
  int tmp ;
  XML_Char c ;
  void (*charDataHandler)(void *userData , XML_Char const   *s , int len ) ;
  ICHAR *dataPtr ;

  {
#line 3207
  s = *startPtr;
#line 3210
  if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 3211
    eventPP = & parser->m_eventPtr;
#line 3212
    *eventPP = s;
#line 3213
    eventEndPP = & parser->m_eventEndPtr;
  } else {
#line 3216
    eventPP = & (parser->m_openInternalEntities)->internalEventPtr;
#line 3217
    eventEndPP = & (parser->m_openInternalEntities)->internalEventEndPtr;
  }
#line 3219
  *eventPP = s;
#line 3220
  *startPtr = (char const   *)((void *)0);
#line 3222
  while (1) {
#line 3224
    tmp = (*(enc->scanners[2]))(enc, s, end, & next);
#line 3224
    tok = tmp;
#line 3225
    *eventEndPP = next;
#line 3226
    switch (tok) {
    case 40: 
#line 3228
    if (parser->m_endCdataSectionHandler) {
#line 3229
      (*(parser->m_endCdataSectionHandler))(parser->m_handlerArg);
    } else
#line 3235
    if (parser->m_defaultHandler) {
#line 3236
      reportDefault(parser, enc, s, next);
    }
#line 3237
    *startPtr = next;
#line 3238
    *nextPtr = next;
#line 3239
    if ((unsigned int )parser->m_parsingStatus.parsing == 2U) {
#line 3240
      return ((enum XML_Error )35);
    } else {
#line 3242
      return ((enum XML_Error )0);
    }
    case 7: 
#line 3244
    if (parser->m_characterDataHandler) {
#line 3245
      c = (XML_Char )10;
#line 3246
      (*(parser->m_characterDataHandler))(parser->m_handlerArg, (XML_Char const   *)(& c),
                                          1);
    } else
#line 3248
    if (parser->m_defaultHandler) {
#line 3249
      reportDefault(parser, enc, s, next);
    }
#line 3250
    break;
    case 6: 
#line 3253
    charDataHandler = parser->m_characterDataHandler;
#line 3254
    if (charDataHandler) {
#line 3255
      if (! enc->isUtf8) {
#line 3256
        while (1) {
#line 3257
          dataPtr = parser->m_dataBuf;
#line 3258
          (*(enc->utf8Convert))(enc, & s, next, & dataPtr, (char const   *)parser->m_dataBufEnd);
#line 3259
          *eventEndPP = next;
#line 3260
          (*charDataHandler)(parser->m_handlerArg, (XML_Char const   *)parser->m_dataBuf,
                             (int )(dataPtr - parser->m_dataBuf));
#line 3262
          if ((unsigned long )s == (unsigned long )next) {
#line 3263
            break;
          }
#line 3264
          *eventPP = s;
        }
      } else {
#line 3268
        (*charDataHandler)(parser->m_handlerArg, (XML_Char const   *)((XML_Char *)s),
                           (int )((XML_Char *)next - (XML_Char *)s));
      }
    } else
#line 3272
    if (parser->m_defaultHandler) {
#line 3273
      reportDefault(parser, enc, s, next);
    }
#line 3275
    break;
    case 0: 
#line 3277
    *eventPP = next;
#line 3278
    return ((enum XML_Error )4);
    case -2: 
#line 3280
    if (haveMore) {
#line 3281
      *nextPtr = s;
#line 3282
      return ((enum XML_Error )0);
    }
#line 3284
    return ((enum XML_Error )6);
    case -4: 
    case -1: 
#line 3287
    if (haveMore) {
#line 3288
      *nextPtr = s;
#line 3289
      return ((enum XML_Error )0);
    }
#line 3291
    return ((enum XML_Error )20);
    default: 
#line 3293
    *eventPP = next;
#line 3294
    return ((enum XML_Error )23);
    }
#line 3297
    s = next;
#line 3297
    *eventPP = s;
#line 3298
    switch ((unsigned int )parser->m_parsingStatus.parsing) {
    case 3U: 
#line 3300
    *nextPtr = next;
#line 3301
    return ((enum XML_Error )0);
    case 2U: 
#line 3303
    return ((enum XML_Error )35);
    default: ;
    }
  }
}
}
#line 3315 "xmlparse.c"
static enum XML_Error ignoreSectionProcessor(XML_Parser parser , char const   *start ,
                                             char const   *end , char const   **endPtr ) 
{ 
  enum XML_Error result ;
  enum XML_Error tmp ;
  enum XML_Error tmp___0 ;

  {
#line 3321
  tmp = doIgnoreSection(parser, parser->m_encoding, & start, end, endPtr, (XML_Bool )(! parser->m_parsingStatus.finalBuffer));
#line 3321
  result = tmp;
#line 3323
  if ((unsigned int )result != 0U) {
#line 3324
    return (result);
  }
#line 3325
  if (start) {
#line 3326
    parser->m_processor = & prologProcessor;
#line 3327
    tmp___0 = prologProcessor(parser, start, end, endPtr);
#line 3327
    return (tmp___0);
  }
#line 3329
  return (result);
}
}
#line 3335 "xmlparse.c"
static enum XML_Error doIgnoreSection(XML_Parser parser , ENCODING const   *enc ,
                                      char const   **startPtr , char const   *end ,
                                      char const   **nextPtr , XML_Bool haveMore ) 
{ 
  char const   *next ;
  int tok ;
  char const   *s ;
  char const   **eventPP ;
  char const   **eventEndPP ;

  {
#line 3345
  s = *startPtr;
#line 3348
  if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 3349
    eventPP = & parser->m_eventPtr;
#line 3350
    *eventPP = s;
#line 3351
    eventEndPP = & parser->m_eventEndPtr;
  } else {
#line 3354
    eventPP = & (parser->m_openInternalEntities)->internalEventPtr;
#line 3355
    eventEndPP = & (parser->m_openInternalEntities)->internalEventEndPtr;
  }
#line 3357
  *eventPP = s;
#line 3358
  *startPtr = (char const   *)((void *)0);
#line 3359
  tok = (*(enc->scanners[3]))(enc, s, end, & next);
#line 3360
  *eventEndPP = next;
#line 3361
  switch (tok) {
  case 42: 
#line 3363
  if (parser->m_defaultHandler) {
#line 3364
    reportDefault(parser, enc, s, next);
  }
#line 3365
  *startPtr = next;
#line 3366
  *nextPtr = next;
#line 3367
  if ((unsigned int )parser->m_parsingStatus.parsing == 2U) {
#line 3368
    return ((enum XML_Error )35);
  } else {
#line 3370
    return ((enum XML_Error )0);
  }
  case 0: 
#line 3372
  *eventPP = next;
#line 3373
  return ((enum XML_Error )4);
  case -2: 
#line 3375
  if (haveMore) {
#line 3376
    *nextPtr = s;
#line 3377
    return ((enum XML_Error )0);
  }
#line 3379
  return ((enum XML_Error )6);
  case -4: 
  case -1: 
#line 3382
  if (haveMore) {
#line 3383
    *nextPtr = s;
#line 3384
    return ((enum XML_Error )0);
  }
#line 3386
  return ((enum XML_Error )2);
  default: 
#line 3388
  *eventPP = next;
#line 3389
  return ((enum XML_Error )23);
  }
}
}
#line 3396 "xmlparse.c"
static enum XML_Error initializeEncoding(XML_Parser parser ) 
{ 
  char const   *s ;
  int (*tmp)(INIT_ENCODING * , ENCODING const   ** , char const   *name ) ;
  int tmp___0 ;
  enum XML_Error tmp___1 ;

  {
#line 3418
  s = parser->m_protocolEncodingName;
#line 3420
  if (parser->m_ns) {
#line 3420
    tmp = & XmlInitEncodingNS;
  } else {
#line 3420
    tmp = & XmlInitEncoding;
  }
#line 3420
  tmp___0 = (*tmp)(& parser->m_initEncoding, & parser->m_encoding, s);
#line 3420
  if (tmp___0) {
#line 3421
    return ((enum XML_Error )0);
  }
#line 3422
  tmp___1 = handleUnknownEncoding(parser, parser->m_protocolEncodingName);
#line 3422
  return (tmp___1);
}
}
#line 3425 "xmlparse.c"
static enum XML_Error processXmlDecl(XML_Parser parser , int isGeneralTextEntity ,
                                     char const   *s , char const   *next ) 
{ 
  char const   *encodingName ;
  XML_Char const   *storedEncName ;
  ENCODING const   *newEncoding ;
  char const   *version ;
  char const   *versionend ;
  XML_Char const   *storedversion ;
  int standalone ;
  int (*tmp)(int isGeneralTextEntity , ENCODING const   *enc , char const   *ptr ,
             char const   *end , char const   **badPtr , char const   **versionPtr ,
             char const   **versionEndPtr , char const   **encodingNamePtr , ENCODING const   **namedEncodingPtr ,
             int *standalonePtr ) ;
  int tmp___0 ;
  int tmp___1 ;
  XML_Char *tmp___2 ;
  XML_Char *tmp___3 ;
  enum XML_Error result ;
  int tmp___4 ;
  XML_Char *tmp___5 ;

  {
#line 3429
  encodingName = (char const   *)((void *)0);
#line 3430
  storedEncName = (XML_Char const   *)((void *)0);
#line 3431
  newEncoding = (ENCODING const   *)((void *)0);
#line 3432
  version = (char const   *)((void *)0);
#line 3434
  storedversion = (XML_Char const   *)((void *)0);
#line 3435
  standalone = -1;
#line 3436
  if (parser->m_ns) {
#line 3436
    tmp = & XmlParseXmlDeclNS;
  } else {
#line 3436
    tmp = & XmlParseXmlDecl;
  }
#line 3436
  tmp___0 = (*tmp)(isGeneralTextEntity, parser->m_encoding, s, next, & parser->m_eventPtr,
                   & version, & versionend, & encodingName, & newEncoding, & standalone);
#line 3436
  if (! tmp___0) {
#line 3448
    if (isGeneralTextEntity) {
#line 3449
      return ((enum XML_Error )31);
    } else {
#line 3451
      return ((enum XML_Error )30);
    }
  }
#line 3453
  if (! isGeneralTextEntity) {
#line 3453
    if (standalone == 1) {
#line 3454
      (parser->m_dtd)->standalone = (XML_Bool )1;
#line 3456
      if ((unsigned int )parser->m_paramEntityParsing == 1U) {
#line 3457
        parser->m_paramEntityParsing = (enum XML_ParamEntityParsing )0;
      }
    }
  }
#line 3460
  if (parser->m_xmlDeclHandler) {
#line 3461
    if ((unsigned long )encodingName != (unsigned long )((void *)0)) {
#line 3462
      tmp___1 = (*((parser->m_encoding)->nameLength))(parser->m_encoding, encodingName);
#line 3462
      tmp___2 = poolStoreString(& parser->m_temp2Pool, parser->m_encoding, encodingName,
                                encodingName + tmp___1);
#line 3462
      storedEncName = (XML_Char const   *)tmp___2;
#line 3467
      if (! storedEncName) {
#line 3468
        return ((enum XML_Error )1);
      }
#line 3469
      parser->m_temp2Pool.start = parser->m_temp2Pool.ptr;
    }
#line 3471
    if (version) {
#line 3472
      tmp___3 = poolStoreString(& parser->m_temp2Pool, parser->m_encoding, version,
                                versionend - (parser->m_encoding)->minBytesPerChar);
#line 3472
      storedversion = (XML_Char const   *)tmp___3;
#line 3476
      if (! storedversion) {
#line 3477
        return ((enum XML_Error )1);
      }
    }
#line 3479
    (*(parser->m_xmlDeclHandler))(parser->m_handlerArg, storedversion, storedEncName,
                                  standalone);
  } else
#line 3481
  if (parser->m_defaultHandler) {
#line 3482
    reportDefault(parser, parser->m_encoding, s, next);
  }
#line 3483
  if ((unsigned long )parser->m_protocolEncodingName == (unsigned long )((void *)0)) {
#line 3484
    if (newEncoding) {
#line 3485
      if (newEncoding->minBytesPerChar != (parser->m_encoding)->minBytesPerChar) {
#line 3486
        parser->m_eventPtr = encodingName;
#line 3487
        return ((enum XML_Error )19);
      }
#line 3489
      parser->m_encoding = newEncoding;
    } else
#line 3491
    if (encodingName) {
#line 3493
      if (! storedEncName) {
#line 3494
        tmp___4 = (*((parser->m_encoding)->nameLength))(parser->m_encoding, encodingName);
#line 3494
        tmp___5 = poolStoreString(& parser->m_temp2Pool, parser->m_encoding, encodingName,
                                  encodingName + tmp___4);
#line 3494
        storedEncName = (XML_Char const   *)tmp___5;
#line 3497
        if (! storedEncName) {
#line 3498
          return ((enum XML_Error )1);
        }
      }
#line 3500
      result = handleUnknownEncoding(parser, storedEncName);
#line 3501
      poolClear(& parser->m_temp2Pool);
#line 3502
      if ((unsigned int )result == 18U) {
#line 3503
        parser->m_eventPtr = encodingName;
      }
#line 3504
      return (result);
    }
  }
#line 3508
  if (storedEncName) {
#line 3509
    poolClear(& parser->m_temp2Pool);
  } else
#line 3508
  if (storedversion) {
#line 3509
    poolClear(& parser->m_temp2Pool);
  }
#line 3511
  return ((enum XML_Error )0);
}
}
#line 3514 "xmlparse.c"
static enum XML_Error handleUnknownEncoding(XML_Parser parser , XML_Char const   *encodingName ) 
{ 
  XML_Encoding info ;
  int i ;
  ENCODING *enc ;
  int tmp ;
  ENCODING *(*tmp___0)(void *mem , int *table , int (*convert)(void *userData , char const   *p ) ,
                       void *userData ) ;
  int tmp___1 ;

  {
#line 3517
  if (parser->m_unknownEncodingHandler) {
#line 3520
    i = 0;
#line 3520
    while (i < 256) {
#line 3521
      info.map[i] = -1;
#line 3520
      i ++;
    }
#line 3522
    info.convert = (int (*)(void *data , char const   *s ))((void *)0);
#line 3523
    info.data = (void *)0;
#line 3524
    info.release = (void (*)(void *data ))((void *)0);
#line 3525
    tmp___1 = (*(parser->m_unknownEncodingHandler))(parser->m_unknownEncodingHandlerData,
                                                    encodingName, & info);
#line 3525
    if (tmp___1) {
#line 3528
      tmp = XmlSizeOfUnknownEncoding();
#line 3528
      parser->m_unknownEncodingMem = (*(parser->m_mem.malloc_fcn))((size_t )tmp);
#line 3529
      if (! parser->m_unknownEncodingMem) {
#line 3530
        if (info.release) {
#line 3531
          (*(info.release))(info.data);
        }
#line 3532
        return ((enum XML_Error )1);
      }
#line 3534
      if (parser->m_ns) {
#line 3534
        tmp___0 = & XmlInitUnknownEncodingNS;
      } else {
#line 3534
        tmp___0 = & XmlInitUnknownEncoding;
      }
#line 3534
      enc = (*tmp___0)(parser->m_unknownEncodingMem, info.map, info.convert, info.data);
#line 3540
      if (enc) {
#line 3541
        parser->m_unknownEncodingData = info.data;
#line 3542
        parser->m_unknownEncodingRelease = info.release;
#line 3543
        parser->m_encoding = (ENCODING const   *)enc;
#line 3544
        return ((enum XML_Error )0);
      }
    }
#line 3547
    if ((unsigned long )info.release != (unsigned long )((void *)0)) {
#line 3548
      (*(info.release))(info.data);
    }
  }
#line 3550
  return ((enum XML_Error )18);
}
}
#line 3553 "xmlparse.c"
static enum XML_Error prologInitProcessor(XML_Parser parser , char const   *s , char const   *end ,
                                          char const   **nextPtr ) 
{ 
  enum XML_Error result ;
  enum XML_Error tmp ;
  enum XML_Error tmp___0 ;

  {
#line 3559
  tmp = initializeEncoding(parser);
#line 3559
  result = tmp;
#line 3560
  if ((unsigned int )result != 0U) {
#line 3561
    return (result);
  }
#line 3562
  parser->m_processor = & prologProcessor;
#line 3563
  tmp___0 = prologProcessor(parser, s, end, nextPtr);
#line 3563
  return (tmp___0);
}
}
#line 3568 "xmlparse.c"
static enum XML_Error externalParEntInitProcessor(XML_Parser parser , char const   *s ,
                                                  char const   *end , char const   **nextPtr ) 
{ 
  enum XML_Error result ;
  enum XML_Error tmp ;
  enum XML_Error tmp___0 ;
  enum XML_Error tmp___1 ;

  {
#line 3574
  tmp = initializeEncoding(parser);
#line 3574
  result = tmp;
#line 3575
  if ((unsigned int )result != 0U) {
#line 3576
    return (result);
  }
#line 3580
  (parser->m_dtd)->paramEntityRead = (XML_Bool )1;
#line 3582
  if (parser->m_prologState.inEntityValue) {
#line 3583
    parser->m_processor = & entityValueInitProcessor;
#line 3584
    tmp___0 = entityValueInitProcessor(parser, s, end, nextPtr);
#line 3584
    return (tmp___0);
  } else {
#line 3587
    parser->m_processor = & externalParEntProcessor;
#line 3588
    tmp___1 = externalParEntProcessor(parser, s, end, nextPtr);
#line 3588
    return (tmp___1);
  }
}
}
#line 3592 "xmlparse.c"
static enum XML_Error entityValueInitProcessor(XML_Parser parser , char const   *s ,
                                               char const   *end , char const   **nextPtr ) 
{ 
  int tok ;
  char const   *start ;
  char const   *next ;
  enum XML_Error tmp ;
  enum XML_Error result ;
  enum XML_Error tmp___0 ;

  {
#line 3599
  start = s;
#line 3600
  next = start;
#line 3601
  parser->m_eventPtr = start;
#line 3603
  while (1) {
#line 3604
    tok = (*((parser->m_encoding)->scanners[0]))(parser->m_encoding, start, end, & next);
#line 3605
    parser->m_eventEndPtr = next;
#line 3606
    if (tok <= 0) {
#line 3607
      if (! parser->m_parsingStatus.finalBuffer) {
#line 3607
        if (tok != 0) {
#line 3608
          *nextPtr = s;
#line 3609
          return ((enum XML_Error )0);
        }
      }
#line 3611
      switch (tok) {
      case 0: 
#line 3613
      return ((enum XML_Error )4);
      case -1: 
#line 3615
      return ((enum XML_Error )5);
      case -2: 
#line 3617
      return ((enum XML_Error )6);
      default: 
#line 3620
      break;
      }
#line 3623
      tmp = storeEntityValue(parser, parser->m_encoding, s, end);
#line 3623
      return (tmp);
    } else
#line 3625
    if (tok == 12) {
#line 3627
      result = processXmlDecl(parser, 0, start, next);
#line 3628
      if ((unsigned int )result != 0U) {
#line 3629
        return (result);
      }
#line 3630
      switch ((unsigned int )parser->m_parsingStatus.parsing) {
      case 3U: 
#line 3632
      *nextPtr = next;
#line 3633
      return ((enum XML_Error )0);
      case 2U: 
#line 3635
      return ((enum XML_Error )35);
      default: 
#line 3637
      *nextPtr = next;
      }
#line 3640
      parser->m_processor = & entityValueProcessor;
#line 3641
      tmp___0 = entityValueProcessor(parser, next, end, nextPtr);
#line 3641
      return (tmp___0);
    } else
#line 3650
    if (tok == 14) {
#line 3650
      if ((unsigned long )next == (unsigned long )end) {
#line 3650
        if (! parser->m_parsingStatus.finalBuffer) {
#line 3651
          *nextPtr = next;
#line 3652
          return ((enum XML_Error )0);
        }
      }
    }
#line 3654
    start = next;
#line 3655
    parser->m_eventPtr = start;
  }
}
}
#line 3659 "xmlparse.c"
static enum XML_Error externalParEntProcessor(XML_Parser parser , char const   *s ,
                                              char const   *end , char const   **nextPtr ) 
{ 
  char const   *next ;
  int tok ;
  enum XML_Error tmp ;

  {
#line 3665
  next = s;
#line 3668
  tok = (*((parser->m_encoding)->scanners[0]))(parser->m_encoding, s, end, & next);
#line 3669
  if (tok <= 0) {
#line 3670
    if (! parser->m_parsingStatus.finalBuffer) {
#line 3670
      if (tok != 0) {
#line 3671
        *nextPtr = s;
#line 3672
        return ((enum XML_Error )0);
      }
    }
#line 3674
    switch (tok) {
    case 0: 
#line 3676
    return ((enum XML_Error )4);
    case -1: 
#line 3678
    return ((enum XML_Error )5);
    case -2: 
#line 3680
    return ((enum XML_Error )6);
    default: 
#line 3683
    break;
    }
  } else
#line 3690
  if (tok == 14) {
#line 3691
    s = next;
#line 3692
    tok = (*((parser->m_encoding)->scanners[0]))(parser->m_encoding, s, end, & next);
  }
#line 3695
  parser->m_processor = & prologProcessor;
#line 3696
  tmp = doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr, (XML_Bool )(! parser->m_parsingStatus.finalBuffer));
#line 3696
  return (tmp);
}
}
#line 3700 "xmlparse.c"
static enum XML_Error entityValueProcessor(XML_Parser parser , char const   *s , char const   *end ,
                                           char const   **nextPtr ) 
{ 
  char const   *start ;
  char const   *next ;
  ENCODING const   *enc ;
  int tok ;
  enum XML_Error tmp ;

  {
#line 3706
  start = s;
#line 3707
  next = s;
#line 3708
  enc = parser->m_encoding;
#line 3711
  while (1) {
#line 3712
    tok = (*(enc->scanners[0]))(enc, start, end, & next);
#line 3713
    if (tok <= 0) {
#line 3714
      if (! parser->m_parsingStatus.finalBuffer) {
#line 3714
        if (tok != 0) {
#line 3715
          *nextPtr = s;
#line 3716
          return ((enum XML_Error )0);
        }
      }
#line 3718
      switch (tok) {
      case 0: 
#line 3720
      return ((enum XML_Error )4);
      case -1: 
#line 3722
      return ((enum XML_Error )5);
      case -2: 
#line 3724
      return ((enum XML_Error )6);
      default: 
#line 3727
      break;
      }
#line 3730
      tmp = storeEntityValue(parser, enc, s, end);
#line 3730
      return (tmp);
    }
#line 3732
    start = next;
  }
}
}
#line 3738 "xmlparse.c"
static enum XML_Error prologProcessor(XML_Parser parser , char const   *s , char const   *end ,
                                      char const   **nextPtr ) 
{ 
  char const   *next ;
  int tok ;
  int tmp ;
  enum XML_Error tmp___0 ;

  {
#line 3744
  next = s;
#line 3745
  tmp = (*((parser->m_encoding)->scanners[0]))(parser->m_encoding, s, end, & next);
#line 3745
  tok = tmp;
#line 3746
  tmp___0 = doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr, (XML_Bool )(! parser->m_parsingStatus.finalBuffer));
#line 3746
  return (tmp___0);
}
}
#line 3761 "xmlparse.c"
static XML_Char const   externalSubsetName[2]  = {      (XML_Char const   )35,      (XML_Char const   )'\000'};
#line 3763 "xmlparse.c"
static XML_Char const   atypeCDATA[6]  = {      (XML_Char const   )67,      (XML_Char const   )68,      (XML_Char const   )65,      (XML_Char const   )84, 
        (XML_Char const   )65,      (XML_Char const   )'\000'};
#line 3765 "xmlparse.c"
static XML_Char const   atypeID[3]  = {      (XML_Char const   )73,      (XML_Char const   )68,      (XML_Char const   )'\000'};
#line 3766 "xmlparse.c"
static XML_Char const   atypeIDREF[6]  = {      (XML_Char const   )73,      (XML_Char const   )68,      (XML_Char const   )82,      (XML_Char const   )69, 
        (XML_Char const   )70,      (XML_Char const   )'\000'};
#line 3768 "xmlparse.c"
static XML_Char const   atypeIDREFS[7]  = {      (XML_Char const   )73,      (XML_Char const   )68,      (XML_Char const   )82,      (XML_Char const   )69, 
        (XML_Char const   )70,      (XML_Char const   )83,      (XML_Char const   )'\000'};
#line 3770 "xmlparse.c"
static XML_Char const   atypeENTITY[7]  = {      (XML_Char const   )69,      (XML_Char const   )78,      (XML_Char const   )84,      (XML_Char const   )73, 
        (XML_Char const   )84,      (XML_Char const   )89,      (XML_Char const   )'\000'};
#line 3772 "xmlparse.c"
static XML_Char const   atypeENTITIES[9]  = 
#line 3772
  {      (XML_Char const   )69,      (XML_Char const   )78,      (XML_Char const   )84,      (XML_Char const   )73, 
        (XML_Char const   )84,      (XML_Char const   )73,      (XML_Char const   )69,      (XML_Char const   )83, 
        (XML_Char const   )'\000'};
#line 3774 "xmlparse.c"
static XML_Char const   atypeNMTOKEN[8]  = 
#line 3774
  {      (XML_Char const   )78,      (XML_Char const   )77,      (XML_Char const   )84,      (XML_Char const   )79, 
        (XML_Char const   )75,      (XML_Char const   )69,      (XML_Char const   )78,      (XML_Char const   )'\000'};
#line 3776 "xmlparse.c"
static XML_Char const   atypeNMTOKENS[9]  = 
#line 3776
  {      (XML_Char const   )78,      (XML_Char const   )77,      (XML_Char const   )84,      (XML_Char const   )79, 
        (XML_Char const   )75,      (XML_Char const   )69,      (XML_Char const   )78,      (XML_Char const   )83, 
        (XML_Char const   )'\000'};
#line 3778 "xmlparse.c"
static XML_Char const   notationPrefix[10]  = 
#line 3778
  {      (XML_Char const   )78,      (XML_Char const   )79,      (XML_Char const   )84,      (XML_Char const   )65, 
        (XML_Char const   )84,      (XML_Char const   )73,      (XML_Char const   )79,      (XML_Char const   )78, 
        (XML_Char const   )40,      (XML_Char const   )'\000'};
#line 3780 "xmlparse.c"
static XML_Char const   enumValueSep[2]  = {      (XML_Char const   )124,      (XML_Char const   )'\000'};
#line 3781 "xmlparse.c"
static XML_Char const   enumValueStart[2]  = {      (XML_Char const   )40,      (XML_Char const   )'\000'};
#line 3750 "xmlparse.c"
static enum XML_Error doProlog(XML_Parser parser , ENCODING const   *enc , char const   *s ,
                               char const   *end , int tok , char const   *next ,
                               char const   **nextPtr , XML_Bool haveMore ) 
{ 
  DTD *dtd ;
  char const   **eventPP ;
  char const   **eventEndPP ;
  enum XML_Content_Quant quant ;
  int role ;
  XML_Bool handleDefault ;
  int tmp ;
  enum XML_Error result ;
  enum XML_Error tmp___0 ;
  XML_Char *tmp___1 ;
  enum XML_Error result___0 ;
  enum XML_Error tmp___2 ;
  NAMED *tmp___3 ;
  XML_Char *pubId ;
  int tmp___4 ;
  int tmp___5 ;
  XML_Char *tem ;
  XML_Char *tmp___6 ;
  XML_Bool hadParamEntityRefs ;
  ENTITY *entity ;
  NAMED *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  XML_Bool hadParamEntityRefs___0 ;
  ENTITY *entity___0 ;
  NAMED *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  enum XML_Error tmp___13 ;
  XML_Char const   *prefix ;
  XML_Char const   *tmp___14 ;
  XML_Char *tmp___15 ;
  int tmp___16 ;
  XML_Char *tmp___18 ;
  int tmp___19 ;
  XML_Bool tmp___20 ;
  XML_Char *tmp___22 ;
  int tmp___23 ;
  XML_Bool tmp___24 ;
  XML_Char const   *attVal ;
  enum XML_Error result___1 ;
  enum XML_Error tmp___25 ;
  int tmp___26 ;
  XML_Char *tmp___28 ;
  int tmp___29 ;
  XML_Bool tmp___30 ;
  XML_Char *tmp___32 ;
  int tmp___33 ;
  XML_Bool tmp___34 ;
  enum XML_Error result___2 ;
  enum XML_Error tmp___35 ;
  XML_Char *tmp___36 ;
  int tmp___37 ;
  NAMED *tmp___38 ;
  XML_Char *tmp___39 ;
  XML_Char *tmp___40 ;
  int tmp___41 ;
  XML_Char const   *name ;
  XML_Char *tmp___42 ;
  NAMED *tmp___43 ;
  int tmp___44 ;
  XML_Char const   *name___0 ;
  XML_Char *tmp___45 ;
  NAMED *tmp___46 ;
  int tmp___47 ;
  XML_Char *tmp___48 ;
  int tmp___49 ;
  XML_Char *tem___0 ;
  XML_Char *tmp___50 ;
  XML_Char const   *systemId ;
  XML_Char *tmp___51 ;
  enum XML_Error result___3 ;
  char *temp ;
  unsigned int tmp___52 ;
  void *tmp___53 ;
  int *temp___0 ;
  void *tmp___54 ;
  unsigned int tmp___55 ;
  void *tmp___56 ;
  int myindex ;
  int tmp___57 ;
  XML_Char const   *name___1 ;
  ENTITY *entity___1 ;
  XML_Char *tmp___58 ;
  NAMED *tmp___59 ;
  int tmp___60 ;
  enum XML_Error result___4 ;
  XML_Bool betweenDecl ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  XML_Content *content ;
  void *tmp___64 ;
  ELEMENT_TYPE *el ;
  XML_Char const   *name___2 ;
  int nameLen ;
  char const   *nxt ;
  char const   *tmp___65 ;
  int myindex___0 ;
  int tmp___66 ;
  int tmp___67 ;
  XML_Content *model ;
  XML_Content *tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;

  {
#line 3784
  dtd = parser->m_dtd;
#line 3790
  if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 3791
    eventPP = & parser->m_eventPtr;
#line 3792
    eventEndPP = & parser->m_eventEndPtr;
  } else {
#line 3795
    eventPP = & (parser->m_openInternalEntities)->internalEventPtr;
#line 3796
    eventEndPP = & (parser->m_openInternalEntities)->internalEventEndPtr;
  }
#line 3799
  while (1) {
#line 3801
    handleDefault = (XML_Bool )1;
#line 3802
    *eventPP = s;
#line 3803
    *eventEndPP = next;
#line 3804
    if (tok <= 0) {
#line 3805
      if (haveMore) {
#line 3805
        if (tok != 0) {
#line 3806
          *nextPtr = s;
#line 3807
          return ((enum XML_Error )0);
        }
      }
#line 3809
      switch (tok) {
      case 0: 
#line 3811
      *eventPP = next;
#line 3812
      return ((enum XML_Error )4);
      case -1: 
#line 3814
      return ((enum XML_Error )5);
      case -2: 
#line 3816
      return ((enum XML_Error )6);
      case -15: 
#line 3818
      tok = - tok;
#line 3819
      break;
      case -4: 
#line 3823
      if ((unsigned long )enc != (unsigned long )parser->m_encoding) {
#line 3823
        if (! (parser->m_openInternalEntities)->betweenDecl) {
#line 3824
          *nextPtr = s;
#line 3825
          return ((enum XML_Error )0);
        }
      }
#line 3831
      if (parser->m_isParamEntity) {
#line 3831
        goto _L;
      } else
#line 3831
      if ((unsigned long )enc != (unsigned long )parser->m_encoding) {
        _L: /* CIL Label */ 
#line 3832
        tmp = (*(parser->m_prologState.handler))(& parser->m_prologState, -4, end,
                                                 end, enc);
#line 3832
        if (tmp == -1) {
#line 3834
          return ((enum XML_Error )29);
        }
#line 3835
        *nextPtr = s;
#line 3836
        return ((enum XML_Error )0);
      }
#line 3839
      return ((enum XML_Error )3);
      default: 
#line 3841
      tok = - tok;
#line 3842
      next = end;
#line 3843
      break;
      }
    }
#line 3846
    role = (*(parser->m_prologState.handler))(& parser->m_prologState, tok, s, next,
                                              enc);
#line 3847
    switch (role) {
    case 1: 
#line 3850
    tmp___0 = processXmlDecl(parser, 0, s, next);
#line 3850
    result = tmp___0;
#line 3851
    if ((unsigned int )result != 0U) {
#line 3852
      return (result);
    }
#line 3853
    enc = parser->m_encoding;
#line 3854
    handleDefault = (XML_Bool )0;
#line 3856
    break;
    case 4: 
#line 3858
    if (parser->m_startDoctypeDeclHandler) {
#line 3859
      tmp___1 = poolStoreString(& parser->m_tempPool, enc, s, next);
#line 3859
      parser->m_doctypeName = (XML_Char const   *)tmp___1;
#line 3860
      if (! parser->m_doctypeName) {
#line 3861
        return ((enum XML_Error )1);
      }
#line 3862
      parser->m_tempPool.start = parser->m_tempPool.ptr;
#line 3863
      parser->m_doctypePubid = (XML_Char const   *)((void *)0);
#line 3864
      handleDefault = (XML_Bool )0;
    }
#line 3866
    parser->m_doctypeSysid = (XML_Char const   *)((void *)0);
#line 3867
    break;
    case 7: 
#line 3869
    if (parser->m_startDoctypeDeclHandler) {
#line 3870
      (*(parser->m_startDoctypeDeclHandler))(parser->m_handlerArg, parser->m_doctypeName,
                                             parser->m_doctypeSysid, parser->m_doctypePubid,
                                             1);
#line 3872
      parser->m_doctypeName = (XML_Char const   *)((void *)0);
#line 3873
      poolClear(& parser->m_tempPool);
#line 3874
      handleDefault = (XML_Bool )0;
    }
#line 3876
    break;
    case 57: 
#line 3880
    tmp___2 = processXmlDecl(parser, 1, s, next);
#line 3880
    result___0 = tmp___2;
#line 3881
    if ((unsigned int )result___0 != 0U) {
#line 3882
      return (result___0);
    }
#line 3883
    enc = parser->m_encoding;
#line 3884
    handleDefault = (XML_Bool )0;
#line 3886
    break;
    case 6: 
#line 3890
    parser->m_useForeignDTD = (XML_Bool )0;
#line 3891
    tmp___3 = lookup(parser, & dtd->paramEntities, externalSubsetName, sizeof(ENTITY ));
#line 3891
    parser->m_declEntity = (ENTITY *)tmp___3;
#line 3895
    if (! parser->m_declEntity) {
#line 3896
      return ((enum XML_Error )1);
    }
#line 3898
    dtd->hasParamEntityRefs = (XML_Bool )1;
#line 3899
    if (parser->m_startDoctypeDeclHandler) {
#line 3901
      tmp___4 = (*(enc->isPublicId))(enc, s, next, eventPP);
#line 3901
      if (! tmp___4) {
#line 3902
        return ((enum XML_Error )32);
      }
#line 3903
      pubId = poolStoreString(& parser->m_tempPool, enc, s + enc->minBytesPerChar,
                              next - enc->minBytesPerChar);
#line 3906
      if (! pubId) {
#line 3907
        return ((enum XML_Error )1);
      }
#line 3908
      normalizePublicId(pubId);
#line 3909
      parser->m_tempPool.start = parser->m_tempPool.ptr;
#line 3910
      parser->m_doctypePubid = (XML_Char const   *)pubId;
#line 3911
      handleDefault = (XML_Bool )0;
#line 3912
      goto alreadyChecked;
    }
    case 14: 
#line 3916
    tmp___5 = (*(enc->isPublicId))(enc, s, next, eventPP);
#line 3916
    if (! tmp___5) {
#line 3917
      return ((enum XML_Error )32);
    }
    alreadyChecked: 
#line 3919
    if (dtd->keepProcessing) {
#line 3919
      if (parser->m_declEntity) {
#line 3920
        tmp___6 = poolStoreString(& dtd->pool, enc, s + enc->minBytesPerChar, next - enc->minBytesPerChar);
#line 3920
        tem = tmp___6;
#line 3924
        if (! tem) {
#line 3925
          return ((enum XML_Error )1);
        }
#line 3926
        normalizePublicId(tem);
#line 3927
        (parser->m_declEntity)->publicId = (XML_Char const   *)tem;
#line 3928
        dtd->pool.start = dtd->pool.ptr;
#line 3929
        if (parser->m_entityDeclHandler) {
#line 3930
          handleDefault = (XML_Bool )0;
        }
      }
    }
#line 3932
    break;
    case 8: 
#line 3934
    if (parser->m_doctypeName) {
#line 3935
      (*(parser->m_startDoctypeDeclHandler))(parser->m_handlerArg, parser->m_doctypeName,
                                             parser->m_doctypeSysid, parser->m_doctypePubid,
                                             0);
#line 3937
      poolClear(& parser->m_tempPool);
#line 3938
      handleDefault = (XML_Bool )0;
    }
#line 3945
    if (parser->m_doctypeSysid) {
#line 3945
      goto _L___0;
    } else
#line 3945
    if (parser->m_useForeignDTD) {
      _L___0: /* CIL Label */ 
#line 3946
      hadParamEntityRefs = dtd->hasParamEntityRefs;
#line 3947
      dtd->hasParamEntityRefs = (XML_Bool )1;
#line 3948
      if (parser->m_paramEntityParsing) {
#line 3948
        if (parser->m_externalEntityRefHandler) {
#line 3949
          tmp___7 = lookup(parser, & dtd->paramEntities, externalSubsetName, sizeof(ENTITY ));
#line 3949
          entity = (ENTITY *)tmp___7;
#line 3953
          if (! entity) {
#line 3954
            return ((enum XML_Error )1);
          }
#line 3955
          if (parser->m_useForeignDTD) {
#line 3956
            entity->base = parser->m_curBase;
          }
#line 3957
          dtd->paramEntityRead = (XML_Bool )0;
#line 3958
          tmp___8 = (*(parser->m_externalEntityRefHandler))(parser->m_externalEntityRefHandlerArg,
                                                            (XML_Char const   *)0,
                                                            entity->base, entity->systemId,
                                                            entity->publicId);
#line 3958
          if (! tmp___8) {
#line 3963
            return ((enum XML_Error )21);
          }
#line 3964
          if (dtd->paramEntityRead) {
#line 3965
            if (! dtd->standalone) {
#line 3965
              if (parser->m_notStandaloneHandler) {
#line 3965
                tmp___9 = (*(parser->m_notStandaloneHandler))(parser->m_handlerArg);
#line 3965
                if (! tmp___9) {
#line 3968
                  return ((enum XML_Error )22);
                }
              }
            }
          } else
#line 3973
          if (! parser->m_doctypeSysid) {
#line 3974
            dtd->hasParamEntityRefs = hadParamEntityRefs;
          }
        }
      }
#line 3977
      parser->m_useForeignDTD = (XML_Bool )0;
    }
#line 3980
    if (parser->m_endDoctypeDeclHandler) {
#line 3981
      (*(parser->m_endDoctypeDeclHandler))(parser->m_handlerArg);
#line 3982
      handleDefault = (XML_Bool )0;
    }
#line 3984
    break;
    case 2: 
#line 3990
    if (parser->m_useForeignDTD) {
#line 3991
      hadParamEntityRefs___0 = dtd->hasParamEntityRefs;
#line 3992
      dtd->hasParamEntityRefs = (XML_Bool )1;
#line 3993
      if (parser->m_paramEntityParsing) {
#line 3993
        if (parser->m_externalEntityRefHandler) {
#line 3994
          tmp___10 = lookup(parser, & dtd->paramEntities, externalSubsetName, sizeof(ENTITY ));
#line 3994
          entity___0 = (ENTITY *)tmp___10;
#line 3997
          if (! entity___0) {
#line 3998
            return ((enum XML_Error )1);
          }
#line 3999
          entity___0->base = parser->m_curBase;
#line 4000
          dtd->paramEntityRead = (XML_Bool )0;
#line 4001
          tmp___11 = (*(parser->m_externalEntityRefHandler))(parser->m_externalEntityRefHandlerArg,
                                                             (XML_Char const   *)0,
                                                             entity___0->base, entity___0->systemId,
                                                             entity___0->publicId);
#line 4001
          if (! tmp___11) {
#line 4006
            return ((enum XML_Error )21);
          }
#line 4007
          if (dtd->paramEntityRead) {
#line 4008
            if (! dtd->standalone) {
#line 4008
              if (parser->m_notStandaloneHandler) {
#line 4008
                tmp___12 = (*(parser->m_notStandaloneHandler))(parser->m_handlerArg);
#line 4008
                if (! tmp___12) {
#line 4011
                  return ((enum XML_Error )22);
                }
              }
            }
          } else {
#line 4017
            dtd->hasParamEntityRefs = hadParamEntityRefs___0;
          }
        }
      }
    }
#line 4022
    parser->m_processor = & contentProcessor;
#line 4023
    tmp___13 = contentProcessor(parser, s, end, nextPtr);
#line 4023
    return (tmp___13);
    case 34: 
#line 4025
    parser->m_declElementType = getElementType(parser, enc, s, next);
#line 4026
    if (! parser->m_declElementType) {
#line 4027
      return ((enum XML_Error )1);
    }
#line 4028
    goto checkAttListDeclHandler;
    case 22: 
#line 4030
    parser->m_declAttributeId = getAttributeId(parser, enc, s, next);
#line 4031
    if (! parser->m_declAttributeId) {
#line 4032
      return ((enum XML_Error )1);
    }
#line 4033
    parser->m_declAttributeIsCdata = (XML_Bool )0;
#line 4034
    parser->m_declAttributeType = (XML_Char const   *)((void *)0);
#line 4035
    parser->m_declAttributeIsId = (XML_Bool )0;
#line 4036
    goto checkAttListDeclHandler;
    case 23: 
#line 4038
    parser->m_declAttributeIsCdata = (XML_Bool )1;
#line 4039
    parser->m_declAttributeType = atypeCDATA;
#line 4040
    goto checkAttListDeclHandler;
    case 24: 
#line 4042
    parser->m_declAttributeIsId = (XML_Bool )1;
#line 4043
    parser->m_declAttributeType = atypeID;
#line 4044
    goto checkAttListDeclHandler;
    case 25: 
#line 4046
    parser->m_declAttributeType = atypeIDREF;
#line 4047
    goto checkAttListDeclHandler;
    case 26: 
#line 4049
    parser->m_declAttributeType = atypeIDREFS;
#line 4050
    goto checkAttListDeclHandler;
    case 27: 
#line 4052
    parser->m_declAttributeType = atypeENTITY;
#line 4053
    goto checkAttListDeclHandler;
    case 28: 
#line 4055
    parser->m_declAttributeType = atypeENTITIES;
#line 4056
    goto checkAttListDeclHandler;
    case 29: 
#line 4058
    parser->m_declAttributeType = atypeNMTOKEN;
#line 4059
    goto checkAttListDeclHandler;
    case 30: 
#line 4061
    parser->m_declAttributeType = atypeNMTOKENS;
    checkAttListDeclHandler: 
#line 4063
    if (dtd->keepProcessing) {
#line 4063
      if (parser->m_attlistDeclHandler) {
#line 4064
        handleDefault = (XML_Bool )0;
      }
    }
#line 4065
    break;
    case 32: 
    case 31: 
#line 4068
    if (dtd->keepProcessing) {
#line 4068
      if (parser->m_attlistDeclHandler) {
#line 4070
        if (parser->m_declAttributeType) {
#line 4071
          prefix = enumValueSep;
        } else
#line 4074
        if (role == 32) {
#line 4074
          prefix = notationPrefix;
        } else {
#line 4074
          prefix = enumValueStart;
        }
#line 4078
        tmp___14 = poolAppendString(& parser->m_tempPool, prefix);
#line 4078
        if (! tmp___14) {
#line 4079
          return ((enum XML_Error )1);
        }
#line 4080
        tmp___15 = poolAppend(& parser->m_tempPool, enc, s, next);
#line 4080
        if (! tmp___15) {
#line 4081
          return ((enum XML_Error )1);
        }
#line 4082
        parser->m_declAttributeType = (XML_Char const   *)parser->m_tempPool.start;
#line 4083
        handleDefault = (XML_Bool )0;
      }
    }
#line 4085
    break;
    case 36: 
    case 35: 
#line 4088
    if (dtd->keepProcessing) {
#line 4089
      tmp___16 = defineAttribute(parser->m_declElementType, parser->m_declAttributeId,
                                 parser->m_declAttributeIsCdata, parser->m_declAttributeIsId,
                                 (XML_Char const   *)0, parser);
#line 4089
      if (! tmp___16) {
#line 4092
        return ((enum XML_Error )1);
      }
#line 4093
      if (parser->m_attlistDeclHandler) {
#line 4093
        if (parser->m_declAttributeType) {
#line 4094
          if ((int const   )*(parser->m_declAttributeType) == 40) {
#line 4094
            goto _L___1;
          } else
#line 4094
          if ((int const   )*(parser->m_declAttributeType) == 78) {
#line 4094
            if ((int const   )*(parser->m_declAttributeType + 1) == 79) {
              _L___1: /* CIL Label */ 
#line 4098
              if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
#line 4098
                tmp___20 = poolGrow(& parser->m_tempPool);
#line 4098
                if (tmp___20) {
#line 4098
                  tmp___18 = parser->m_tempPool.ptr;
#line 4098
                  (parser->m_tempPool.ptr) ++;
#line 4098
                  *tmp___18 = (XML_Char )41;
#line 4098
                  tmp___19 = 1;
                } else {
#line 4098
                  tmp___19 = 0;
                }
              } else {
#line 4098
                tmp___18 = parser->m_tempPool.ptr;
#line 4098
                (parser->m_tempPool.ptr) ++;
#line 4098
                *tmp___18 = (XML_Char )41;
#line 4098
                tmp___19 = 1;
              }
#line 4098
              if (tmp___19) {
#line 4098
                if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
#line 4098
                  tmp___24 = poolGrow(& parser->m_tempPool);
#line 4098
                  if (tmp___24) {
#line 4098
                    tmp___22 = parser->m_tempPool.ptr;
#line 4098
                    (parser->m_tempPool.ptr) ++;
#line 4098
                    *tmp___22 = (XML_Char )'\000';
#line 4098
                    tmp___23 = 1;
                  } else {
#line 4098
                    tmp___23 = 0;
                  }
                } else {
#line 4098
                  tmp___22 = parser->m_tempPool.ptr;
#line 4098
                  (parser->m_tempPool.ptr) ++;
#line 4098
                  *tmp___22 = (XML_Char )'\000';
#line 4098
                  tmp___23 = 1;
                }
#line 4098
                if (! tmp___23) {
#line 4100
                  return ((enum XML_Error )1);
                }
              } else {
#line 4100
                return ((enum XML_Error )1);
              }
#line 4101
              parser->m_declAttributeType = (XML_Char const   *)parser->m_tempPool.start;
#line 4102
              parser->m_tempPool.start = parser->m_tempPool.ptr;
            }
          }
#line 4104
          *eventEndPP = s;
#line 4105
          (*(parser->m_attlistDeclHandler))(parser->m_handlerArg, (parser->m_declElementType)->name,
                                            (XML_Char const   *)(parser->m_declAttributeId)->name,
                                            parser->m_declAttributeType, (XML_Char const   *)0,
                                            role == 36);
#line 4108
          poolClear(& parser->m_tempPool);
#line 4109
          handleDefault = (XML_Bool )0;
        }
      }
    }
#line 4112
    break;
    case 38: 
    case 37: 
#line 4115
    if (dtd->keepProcessing) {
#line 4117
      tmp___25 = storeAttributeValue(parser, enc, parser->m_declAttributeIsCdata,
                                     s + enc->minBytesPerChar, next - enc->minBytesPerChar,
                                     & dtd->pool);
#line 4117
      result___1 = tmp___25;
#line 4122
      if (result___1) {
#line 4123
        return (result___1);
      }
#line 4124
      attVal = (XML_Char const   *)dtd->pool.start;
#line 4125
      dtd->pool.start = dtd->pool.ptr;
#line 4127
      tmp___26 = defineAttribute(parser->m_declElementType, parser->m_declAttributeId,
                                 parser->m_declAttributeIsCdata, (XML_Bool )0, attVal,
                                 parser);
#line 4127
      if (! tmp___26) {
#line 4129
        return ((enum XML_Error )1);
      }
#line 4130
      if (parser->m_attlistDeclHandler) {
#line 4130
        if (parser->m_declAttributeType) {
#line 4131
          if ((int const   )*(parser->m_declAttributeType) == 40) {
#line 4131
            goto _L___2;
          } else
#line 4131
          if ((int const   )*(parser->m_declAttributeType) == 78) {
#line 4131
            if ((int const   )*(parser->m_declAttributeType + 1) == 79) {
              _L___2: /* CIL Label */ 
#line 4135
              if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
#line 4135
                tmp___30 = poolGrow(& parser->m_tempPool);
#line 4135
                if (tmp___30) {
#line 4135
                  tmp___28 = parser->m_tempPool.ptr;
#line 4135
                  (parser->m_tempPool.ptr) ++;
#line 4135
                  *tmp___28 = (XML_Char )41;
#line 4135
                  tmp___29 = 1;
                } else {
#line 4135
                  tmp___29 = 0;
                }
              } else {
#line 4135
                tmp___28 = parser->m_tempPool.ptr;
#line 4135
                (parser->m_tempPool.ptr) ++;
#line 4135
                *tmp___28 = (XML_Char )41;
#line 4135
                tmp___29 = 1;
              }
#line 4135
              if (tmp___29) {
#line 4135
                if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
#line 4135
                  tmp___34 = poolGrow(& parser->m_tempPool);
#line 4135
                  if (tmp___34) {
#line 4135
                    tmp___32 = parser->m_tempPool.ptr;
#line 4135
                    (parser->m_tempPool.ptr) ++;
#line 4135
                    *tmp___32 = (XML_Char )'\000';
#line 4135
                    tmp___33 = 1;
                  } else {
#line 4135
                    tmp___33 = 0;
                  }
                } else {
#line 4135
                  tmp___32 = parser->m_tempPool.ptr;
#line 4135
                  (parser->m_tempPool.ptr) ++;
#line 4135
                  *tmp___32 = (XML_Char )'\000';
#line 4135
                  tmp___33 = 1;
                }
#line 4135
                if (! tmp___33) {
#line 4137
                  return ((enum XML_Error )1);
                }
              } else {
#line 4137
                return ((enum XML_Error )1);
              }
#line 4138
              parser->m_declAttributeType = (XML_Char const   *)parser->m_tempPool.start;
#line 4139
              parser->m_tempPool.start = parser->m_tempPool.ptr;
            }
          }
#line 4141
          *eventEndPP = s;
#line 4142
          (*(parser->m_attlistDeclHandler))(parser->m_handlerArg, (parser->m_declElementType)->name,
                                            (XML_Char const   *)(parser->m_declAttributeId)->name,
                                            parser->m_declAttributeType, attVal, role == 38);
#line 4146
          poolClear(& parser->m_tempPool);
#line 4147
          handleDefault = (XML_Bool )0;
        }
      }
    }
#line 4150
    break;
    case 12: 
#line 4152
    if (dtd->keepProcessing) {
#line 4153
      tmp___35 = storeEntityValue(parser, enc, s + enc->minBytesPerChar, next - enc->minBytesPerChar);
#line 4153
      result___2 = tmp___35;
#line 4156
      if (parser->m_declEntity) {
#line 4157
        (parser->m_declEntity)->textPtr = (XML_Char const   *)dtd->entityValuePool.start;
#line 4158
        (parser->m_declEntity)->textLen = (int )(dtd->entityValuePool.ptr - dtd->entityValuePool.start);
#line 4159
        dtd->entityValuePool.start = dtd->entityValuePool.ptr;
#line 4160
        if (parser->m_entityDeclHandler) {
#line 4161
          *eventEndPP = s;
#line 4162
          (*(parser->m_entityDeclHandler))(parser->m_handlerArg, (parser->m_declEntity)->name,
                                           (int )(parser->m_declEntity)->is_param,
                                           (parser->m_declEntity)->textPtr, (parser->m_declEntity)->textLen,
                                           parser->m_curBase, (XML_Char const   *)0,
                                           (XML_Char const   *)0, (XML_Char const   *)0);
#line 4168
          handleDefault = (XML_Bool )0;
        }
      } else {
#line 4172
        dtd->entityValuePool.ptr = dtd->entityValuePool.start;
      }
#line 4173
      if ((unsigned int )result___2 != 0U) {
#line 4174
        return (result___2);
      }
    }
#line 4176
    break;
    case 5: 
#line 4179
    parser->m_useForeignDTD = (XML_Bool )0;
#line 4181
    dtd->hasParamEntityRefs = (XML_Bool )1;
#line 4182
    if (parser->m_startDoctypeDeclHandler) {
#line 4183
      tmp___36 = poolStoreString(& parser->m_tempPool, enc, s + enc->minBytesPerChar,
                                 next - enc->minBytesPerChar);
#line 4183
      parser->m_doctypeSysid = (XML_Char const   *)tmp___36;
#line 4186
      if ((unsigned long )parser->m_doctypeSysid == (unsigned long )((void *)0)) {
#line 4187
        return ((enum XML_Error )1);
      }
#line 4188
      parser->m_tempPool.start = parser->m_tempPool.ptr;
#line 4189
      handleDefault = (XML_Bool )0;
    } else {
#line 4195
      parser->m_doctypeSysid = externalSubsetName;
    }
#line 4197
    if (! dtd->standalone) {
#line 4197
      if (! parser->m_paramEntityParsing) {
#line 4197
        if (parser->m_notStandaloneHandler) {
#line 4197
          tmp___37 = (*(parser->m_notStandaloneHandler))(parser->m_handlerArg);
#line 4197
          if (! tmp___37) {
#line 4203
            return ((enum XML_Error )22);
          }
        }
      }
    }
#line 4207
    if (! parser->m_declEntity) {
#line 4208
      tmp___38 = lookup(parser, & dtd->paramEntities, externalSubsetName, sizeof(ENTITY ));
#line 4208
      parser->m_declEntity = (ENTITY *)tmp___38;
#line 4212
      if (! parser->m_declEntity) {
#line 4213
        return ((enum XML_Error )1);
      }
#line 4214
      (parser->m_declEntity)->publicId = (XML_Char const   *)((void *)0);
    }
    case 13: 
#line 4219
    if (dtd->keepProcessing) {
#line 4219
      if (parser->m_declEntity) {
#line 4220
        tmp___39 = poolStoreString(& dtd->pool, enc, s + enc->minBytesPerChar, next - enc->minBytesPerChar);
#line 4220
        (parser->m_declEntity)->systemId = (XML_Char const   *)tmp___39;
#line 4223
        if (! (parser->m_declEntity)->systemId) {
#line 4224
          return ((enum XML_Error )1);
        }
#line 4225
        (parser->m_declEntity)->base = parser->m_curBase;
#line 4226
        dtd->pool.start = dtd->pool.ptr;
#line 4227
        if (parser->m_entityDeclHandler) {
#line 4228
          handleDefault = (XML_Bool )0;
        }
      }
    }
#line 4230
    break;
    case 15: 
#line 4232
    if (dtd->keepProcessing) {
#line 4232
      if (parser->m_declEntity) {
#line 4232
        if (parser->m_entityDeclHandler) {
#line 4233
          *eventEndPP = s;
#line 4234
          (*(parser->m_entityDeclHandler))(parser->m_handlerArg, (parser->m_declEntity)->name,
                                           (int )(parser->m_declEntity)->is_param,
                                           (XML_Char const   *)0, 0, (parser->m_declEntity)->base,
                                           (parser->m_declEntity)->systemId, (parser->m_declEntity)->publicId,
                                           (XML_Char const   *)0);
#line 4242
          handleDefault = (XML_Bool )0;
        }
      }
    }
#line 4244
    break;
    case 16: 
#line 4246
    if (dtd->keepProcessing) {
#line 4246
      if (parser->m_declEntity) {
#line 4247
        tmp___40 = poolStoreString(& dtd->pool, enc, s, next);
#line 4247
        (parser->m_declEntity)->notation = (XML_Char const   *)tmp___40;
#line 4248
        if (! (parser->m_declEntity)->notation) {
#line 4249
          return ((enum XML_Error )1);
        }
#line 4250
        dtd->pool.start = dtd->pool.ptr;
#line 4251
        if (parser->m_unparsedEntityDeclHandler) {
#line 4252
          *eventEndPP = s;
#line 4253
          (*(parser->m_unparsedEntityDeclHandler))(parser->m_handlerArg, (parser->m_declEntity)->name,
                                                   (parser->m_declEntity)->base, (parser->m_declEntity)->systemId,
                                                   (parser->m_declEntity)->publicId,
                                                   (parser->m_declEntity)->notation);
#line 4259
          handleDefault = (XML_Bool )0;
        } else
#line 4261
        if (parser->m_entityDeclHandler) {
#line 4262
          *eventEndPP = s;
#line 4263
          (*(parser->m_entityDeclHandler))(parser->m_handlerArg, (parser->m_declEntity)->name,
                                           0, (XML_Char const   *)0, 0, (parser->m_declEntity)->base,
                                           (parser->m_declEntity)->systemId, (parser->m_declEntity)->publicId,
                                           (parser->m_declEntity)->notation);
#line 4270
          handleDefault = (XML_Bool )0;
        }
      }
    }
#line 4273
    break;
    case 9: 
#line 4276
    tmp___41 = (*(enc->predefinedEntityName))(enc, s, next);
#line 4276
    if (tmp___41) {
#line 4277
      parser->m_declEntity = (ENTITY *)((void *)0);
#line 4278
      break;
    }
#line 4280
    if (dtd->keepProcessing) {
#line 4281
      tmp___42 = poolStoreString(& dtd->pool, enc, s, next);
#line 4281
      name = (XML_Char const   *)tmp___42;
#line 4282
      if (! name) {
#line 4283
        return ((enum XML_Error )1);
      }
#line 4284
      tmp___43 = lookup(parser, & dtd->generalEntities, name, sizeof(ENTITY ));
#line 4284
      parser->m_declEntity = (ENTITY *)tmp___43;
#line 4286
      if (! parser->m_declEntity) {
#line 4287
        return ((enum XML_Error )1);
      }
#line 4288
      if ((unsigned long )(parser->m_declEntity)->name != (unsigned long )name) {
#line 4289
        dtd->pool.ptr = dtd->pool.start;
#line 4290
        parser->m_declEntity = (ENTITY *)((void *)0);
      } else {
#line 4293
        dtd->pool.start = dtd->pool.ptr;
#line 4294
        (parser->m_declEntity)->publicId = (XML_Char const   *)((void *)0);
#line 4295
        (parser->m_declEntity)->is_param = (XML_Bool )0;
#line 4299
        if (parser->m_parentParser) {
#line 4299
          tmp___44 = 0;
        } else
#line 4299
        if (parser->m_openInternalEntities) {
#line 4299
          tmp___44 = 0;
        } else {
#line 4299
          tmp___44 = 1;
        }
#line 4299
        (parser->m_declEntity)->is_internal = (XML_Bool )tmp___44;
#line 4300
        if (parser->m_entityDeclHandler) {
#line 4301
          handleDefault = (XML_Bool )0;
        }
      }
    } else {
#line 4305
      dtd->pool.ptr = dtd->pool.start;
#line 4306
      parser->m_declEntity = (ENTITY *)((void *)0);
    }
#line 4309
    break;
    case 10: 
#line 4312
    if (dtd->keepProcessing) {
#line 4313
      tmp___45 = poolStoreString(& dtd->pool, enc, s, next);
#line 4313
      name___0 = (XML_Char const   *)tmp___45;
#line 4314
      if (! name___0) {
#line 4315
        return ((enum XML_Error )1);
      }
#line 4316
      tmp___46 = lookup(parser, & dtd->paramEntities, name___0, sizeof(ENTITY ));
#line 4316
      parser->m_declEntity = (ENTITY *)tmp___46;
#line 4318
      if (! parser->m_declEntity) {
#line 4319
        return ((enum XML_Error )1);
      }
#line 4320
      if ((unsigned long )(parser->m_declEntity)->name != (unsigned long )name___0) {
#line 4321
        dtd->pool.ptr = dtd->pool.start;
#line 4322
        parser->m_declEntity = (ENTITY *)((void *)0);
      } else {
#line 4325
        dtd->pool.start = dtd->pool.ptr;
#line 4326
        (parser->m_declEntity)->publicId = (XML_Char const   *)((void *)0);
#line 4327
        (parser->m_declEntity)->is_param = (XML_Bool )1;
#line 4331
        if (parser->m_parentParser) {
#line 4331
          tmp___47 = 0;
        } else
#line 4331
        if (parser->m_openInternalEntities) {
#line 4331
          tmp___47 = 0;
        } else {
#line 4331
          tmp___47 = 1;
        }
#line 4331
        (parser->m_declEntity)->is_internal = (XML_Bool )tmp___47;
#line 4332
        if (parser->m_entityDeclHandler) {
#line 4333
          handleDefault = (XML_Bool )0;
        }
      }
    } else {
#line 4337
      dtd->pool.ptr = dtd->pool.start;
#line 4338
      parser->m_declEntity = (ENTITY *)((void *)0);
    }
#line 4343
    break;
    case 18: 
#line 4345
    parser->m_declNotationPublicId = (XML_Char const   *)((void *)0);
#line 4346
    parser->m_declNotationName = (XML_Char const   *)((void *)0);
#line 4347
    if (parser->m_notationDeclHandler) {
#line 4348
      tmp___48 = poolStoreString(& parser->m_tempPool, enc, s, next);
#line 4348
      parser->m_declNotationName = (XML_Char const   *)tmp___48;
#line 4349
      if (! parser->m_declNotationName) {
#line 4350
        return ((enum XML_Error )1);
      }
#line 4351
      parser->m_tempPool.start = parser->m_tempPool.ptr;
#line 4352
      handleDefault = (XML_Bool )0;
    }
#line 4354
    break;
    case 21: 
#line 4356
    tmp___49 = (*(enc->isPublicId))(enc, s, next, eventPP);
#line 4356
    if (! tmp___49) {
#line 4357
      return ((enum XML_Error )32);
    }
#line 4358
    if (parser->m_declNotationName) {
#line 4359
      tmp___50 = poolStoreString(& parser->m_tempPool, enc, s + enc->minBytesPerChar,
                                 next - enc->minBytesPerChar);
#line 4359
      tem___0 = tmp___50;
#line 4363
      if (! tem___0) {
#line 4364
        return ((enum XML_Error )1);
      }
#line 4365
      normalizePublicId(tem___0);
#line 4366
      parser->m_declNotationPublicId = (XML_Char const   *)tem___0;
#line 4367
      parser->m_tempPool.start = parser->m_tempPool.ptr;
#line 4368
      handleDefault = (XML_Bool )0;
    }
#line 4370
    break;
    case 19: 
#line 4372
    if (parser->m_declNotationName) {
#line 4372
      if (parser->m_notationDeclHandler) {
#line 4373
        tmp___51 = poolStoreString(& parser->m_tempPool, enc, s + enc->minBytesPerChar,
                                   next - enc->minBytesPerChar);
#line 4373
        systemId = (XML_Char const   *)tmp___51;
#line 4377
        if (! systemId) {
#line 4378
          return ((enum XML_Error )1);
        }
#line 4379
        *eventEndPP = s;
#line 4380
        (*(parser->m_notationDeclHandler))(parser->m_handlerArg, parser->m_declNotationName,
                                           parser->m_curBase, systemId, parser->m_declNotationPublicId);
#line 4385
        handleDefault = (XML_Bool )0;
      }
    }
#line 4387
    poolClear(& parser->m_tempPool);
#line 4388
    break;
    case 20: 
#line 4390
    if (parser->m_declNotationPublicId) {
#line 4390
      if (parser->m_notationDeclHandler) {
#line 4391
        *eventEndPP = s;
#line 4392
        (*(parser->m_notationDeclHandler))(parser->m_handlerArg, parser->m_declNotationName,
                                           parser->m_curBase, (XML_Char const   *)0,
                                           parser->m_declNotationPublicId);
#line 4397
        handleDefault = (XML_Bool )0;
      }
    }
#line 4399
    poolClear(& parser->m_tempPool);
#line 4400
    break;
    case -1: 
#line 4402
    switch (tok) {
    case 28: 
#line 4406
    return ((enum XML_Error )10);
    case 12: 
#line 4408
    return ((enum XML_Error )17);
    default: 
#line 4410
    return ((enum XML_Error )2);
    }
    case 58: 
#line 4416
    if (parser->m_defaultHandler) {
#line 4417
      reportDefault(parser, enc, s, next);
    }
#line 4418
    handleDefault = (XML_Bool )0;
#line 4419
    result___3 = doIgnoreSection(parser, enc, & next, end, nextPtr, haveMore);
#line 4420
    if ((unsigned int )result___3 != 0U) {
#line 4421
      return (result___3);
    } else
#line 4422
    if (! next) {
#line 4423
      parser->m_processor = & ignoreSectionProcessor;
#line 4424
      return (result___3);
    }
#line 4427
    break;
    case 44: 
#line 4430
    if (parser->m_prologState.level >= parser->m_groupSize) {
#line 4431
      if (parser->m_groupSize) {
#line 4432
        tmp___52 = parser->m_groupSize * 2U;
#line 4432
        parser->m_groupSize = tmp___52;
#line 4432
        tmp___53 = (*(parser->m_mem.realloc_fcn))((void *)parser->m_groupConnector,
                                                  (size_t )tmp___52);
#line 4432
        temp = (char *)tmp___53;
#line 4433
        if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 4434
          return ((enum XML_Error )1);
        }
#line 4435
        parser->m_groupConnector = temp;
#line 4436
        if (dtd->scaffIndex) {
#line 4437
          tmp___54 = (*(parser->m_mem.realloc_fcn))((void *)dtd->scaffIndex, (unsigned long )parser->m_groupSize * sizeof(int ));
#line 4437
          temp___0 = (int *)tmp___54;
#line 4439
          if ((unsigned long )temp___0 == (unsigned long )((void *)0)) {
#line 4440
            return ((enum XML_Error )1);
          }
#line 4441
          dtd->scaffIndex = temp___0;
        }
      } else {
#line 4445
        tmp___55 = 32U;
#line 4445
        parser->m_groupSize = tmp___55;
#line 4445
        tmp___56 = (*(parser->m_mem.malloc_fcn))((size_t )tmp___55);
#line 4445
        parser->m_groupConnector = (char *)tmp___56;
#line 4446
        if (! parser->m_groupConnector) {
#line 4447
          return ((enum XML_Error )1);
        }
      }
    }
#line 4450
    *(parser->m_groupConnector + parser->m_prologState.level) = (char)0;
#line 4451
    if (dtd->in_eldecl) {
#line 4452
      tmp___57 = nextScaffoldPart(parser);
#line 4452
      myindex = tmp___57;
#line 4453
      if (myindex < 0) {
#line 4454
        return ((enum XML_Error )1);
      }
#line 4455
      *(dtd->scaffIndex + dtd->scaffLevel) = myindex;
#line 4456
      (dtd->scaffLevel) ++;
#line 4457
      (dtd->scaffold + myindex)->type = (enum XML_Content_Type )6;
#line 4458
      if (parser->m_elementDeclHandler) {
#line 4459
        handleDefault = (XML_Bool )0;
      }
    }
#line 4461
    break;
    case 50: 
#line 4463
    if ((int )*(parser->m_groupConnector + parser->m_prologState.level) == 124) {
#line 4464
      return ((enum XML_Error )2);
    }
#line 4465
    *(parser->m_groupConnector + parser->m_prologState.level) = (char)44;
#line 4466
    if (dtd->in_eldecl) {
#line 4466
      if (parser->m_elementDeclHandler) {
#line 4467
        handleDefault = (XML_Bool )0;
      }
    }
#line 4468
    break;
    case 49: 
#line 4470
    if ((int )*(parser->m_groupConnector + parser->m_prologState.level) == 44) {
#line 4471
      return ((enum XML_Error )2);
    }
#line 4472
    if (dtd->in_eldecl) {
#line 4472
      if (! *(parser->m_groupConnector + parser->m_prologState.level)) {
#line 4472
        if ((unsigned int )(dtd->scaffold + *(dtd->scaffIndex + (dtd->scaffLevel - 1)))->type != 3U) {
#line 4477
          (dtd->scaffold + *(dtd->scaffIndex + (dtd->scaffLevel - 1)))->type = (enum XML_Content_Type )5;
#line 4479
          if (parser->m_elementDeclHandler) {
#line 4480
            handleDefault = (XML_Bool )0;
          }
        }
      }
    }
#line 4482
    *(parser->m_groupConnector + parser->m_prologState.level) = (char)124;
#line 4483
    break;
    case 59: 
    case 60: 
#line 4487
    dtd->hasParamEntityRefs = (XML_Bool )1;
#line 4488
    if (! parser->m_paramEntityParsing) {
#line 4489
      dtd->keepProcessing = dtd->standalone;
    } else {
#line 4493
      tmp___58 = poolStoreString(& dtd->pool, enc, s + enc->minBytesPerChar, next - enc->minBytesPerChar);
#line 4493
      name___1 = (XML_Char const   *)tmp___58;
#line 4496
      if (! name___1) {
#line 4497
        return ((enum XML_Error )1);
      }
#line 4498
      tmp___59 = lookup(parser, & dtd->paramEntities, name___1, (size_t )0);
#line 4498
      entity___1 = (ENTITY *)tmp___59;
#line 4499
      dtd->pool.ptr = dtd->pool.start;
#line 4504
      if (parser->m_prologState.documentEntity) {
#line 4504
        if (dtd->standalone) {
#line 4504
          tmp___60 = ! parser->m_openInternalEntities;
        } else {
#line 4504
          tmp___60 = ! dtd->hasParamEntityRefs;
        }
#line 4504
        if (tmp___60) {
#line 4508
          if (! entity___1) {
#line 4509
            return ((enum XML_Error )11);
          } else
#line 4510
          if (! entity___1->is_internal) {
#line 4511
            return ((enum XML_Error )24);
          }
        } else {
#line 4504
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 4513
      if (! entity___1) {
#line 4514
        dtd->keepProcessing = dtd->standalone;
#line 4516
        if (role == 60) {
#line 4516
          if (parser->m_skippedEntityHandler) {
#line 4517
            (*(parser->m_skippedEntityHandler))(parser->m_handlerArg, name___1, 1);
#line 4518
            handleDefault = (XML_Bool )0;
          }
        }
#line 4520
        break;
      }
#line 4522
      if (entity___1->open) {
#line 4523
        return ((enum XML_Error )12);
      }
#line 4524
      if (entity___1->textPtr) {
#line 4526
        if (role == 60) {
#line 4526
          tmp___61 = (int )((XML_Bool )1);
        } else {
#line 4526
          tmp___61 = (int )((XML_Bool )0);
        }
#line 4526
        betweenDecl = (XML_Bool )tmp___61;
#line 4528
        result___4 = processInternalEntity(parser, entity___1, betweenDecl);
#line 4529
        if ((unsigned int )result___4 != 0U) {
#line 4530
          return (result___4);
        }
#line 4531
        handleDefault = (XML_Bool )0;
#line 4532
        break;
      }
#line 4534
      if (parser->m_externalEntityRefHandler) {
#line 4535
        dtd->paramEntityRead = (XML_Bool )0;
#line 4536
        entity___1->open = (XML_Bool )1;
#line 4537
        tmp___62 = (*(parser->m_externalEntityRefHandler))(parser->m_externalEntityRefHandlerArg,
                                                           (XML_Char const   *)0,
                                                           entity___1->base, entity___1->systemId,
                                                           entity___1->publicId);
#line 4537
        if (! tmp___62) {
#line 4542
          entity___1->open = (XML_Bool )0;
#line 4543
          return ((enum XML_Error )21);
        }
#line 4545
        entity___1->open = (XML_Bool )0;
#line 4546
        handleDefault = (XML_Bool )0;
#line 4547
        if (! dtd->paramEntityRead) {
#line 4548
          dtd->keepProcessing = dtd->standalone;
#line 4549
          break;
        }
      } else {
#line 4553
        dtd->keepProcessing = dtd->standalone;
#line 4554
        break;
      }
    }
#line 4558
    if (! dtd->standalone) {
#line 4558
      if (parser->m_notStandaloneHandler) {
#line 4558
        tmp___63 = (*(parser->m_notStandaloneHandler))(parser->m_handlerArg);
#line 4558
        if (! tmp___63) {
#line 4561
          return ((enum XML_Error )22);
        }
      }
    }
#line 4562
    break;
    case 40: 
#line 4567
    if (parser->m_elementDeclHandler) {
#line 4568
      parser->m_declElementType = getElementType(parser, enc, s, next);
#line 4569
      if (! parser->m_declElementType) {
#line 4570
        return ((enum XML_Error )1);
      }
#line 4571
      dtd->scaffLevel = 0;
#line 4572
      dtd->scaffCount = 0U;
#line 4573
      dtd->in_eldecl = (XML_Bool )1;
#line 4574
      handleDefault = (XML_Bool )0;
    }
#line 4576
    break;
    case 42: 
    case 41: 
#line 4580
    if (dtd->in_eldecl) {
#line 4581
      if (parser->m_elementDeclHandler) {
#line 4582
        tmp___64 = (*(parser->m_mem.malloc_fcn))(sizeof(XML_Content ));
#line 4582
        content = (XML_Content *)tmp___64;
#line 4583
        if (! content) {
#line 4584
          return ((enum XML_Error )1);
        }
#line 4585
        content->quant = (enum XML_Content_Quant )0;
#line 4586
        content->name = (XML_Char *)((void *)0);
#line 4587
        content->numchildren = 0U;
#line 4588
        content->children = (XML_Content *)((void *)0);
#line 4589
        if (role == 41) {
#line 4589
          content->type = (enum XML_Content_Type )2;
        } else {
#line 4589
          content->type = (enum XML_Content_Type )1;
        }
#line 4592
        *eventEndPP = s;
#line 4593
        (*(parser->m_elementDeclHandler))(parser->m_handlerArg, (parser->m_declElementType)->name,
                                          content);
#line 4594
        handleDefault = (XML_Bool )0;
      }
#line 4596
      dtd->in_eldecl = (XML_Bool )0;
    }
#line 4598
    break;
    case 43: 
#line 4601
    if (dtd->in_eldecl) {
#line 4602
      (dtd->scaffold + *(dtd->scaffIndex + (dtd->scaffLevel - 1)))->type = (enum XML_Content_Type )3;
#line 4604
      if (parser->m_elementDeclHandler) {
#line 4605
        handleDefault = (XML_Bool )0;
      }
    }
#line 4607
    break;
    case 51: 
#line 4610
    quant = (enum XML_Content_Quant )0;
#line 4611
    goto elementContent;
    case 53: 
#line 4613
    quant = (enum XML_Content_Quant )1;
#line 4614
    goto elementContent;
    case 52: 
#line 4616
    quant = (enum XML_Content_Quant )2;
#line 4617
    goto elementContent;
    case 54: 
#line 4619
    quant = (enum XML_Content_Quant )3;
    elementContent: 
#line 4621
    if (dtd->in_eldecl) {
#line 4625
      if ((unsigned int )quant == 0U) {
#line 4625
        tmp___65 = next;
      } else {
#line 4625
        tmp___65 = next - enc->minBytesPerChar;
      }
#line 4625
      nxt = tmp___65;
#line 4628
      tmp___66 = nextScaffoldPart(parser);
#line 4628
      myindex___0 = tmp___66;
#line 4629
      if (myindex___0 < 0) {
#line 4630
        return ((enum XML_Error )1);
      }
#line 4631
      (dtd->scaffold + myindex___0)->type = (enum XML_Content_Type )4;
#line 4632
      (dtd->scaffold + myindex___0)->quant = quant;
#line 4633
      el = getElementType(parser, enc, s, nxt);
#line 4634
      if (! el) {
#line 4635
        return ((enum XML_Error )1);
      }
#line 4636
      name___2 = el->name;
#line 4637
      (dtd->scaffold + myindex___0)->name = name___2;
#line 4638
      nameLen = 0;
#line 4639
      while (1) {
#line 4639
        tmp___67 = nameLen;
#line 4639
        nameLen ++;
#line 4639
        if (! *(name___2 + tmp___67)) {
#line 4639
          break;
        }
      }
#line 4640
      dtd->contentStringLen += (unsigned int )nameLen;
#line 4641
      if (parser->m_elementDeclHandler) {
#line 4642
        handleDefault = (XML_Bool )0;
      }
    }
#line 4644
    break;
    case 45: 
#line 4647
    quant = (enum XML_Content_Quant )0;
#line 4648
    goto closeGroup;
    case 47: 
#line 4650
    quant = (enum XML_Content_Quant )1;
#line 4651
    goto closeGroup;
    case 46: 
#line 4653
    quant = (enum XML_Content_Quant )2;
#line 4654
    goto closeGroup;
    case 48: 
#line 4656
    quant = (enum XML_Content_Quant )3;
    closeGroup: 
#line 4658
    if (dtd->in_eldecl) {
#line 4659
      if (parser->m_elementDeclHandler) {
#line 4660
        handleDefault = (XML_Bool )0;
      }
#line 4661
      (dtd->scaffLevel) --;
#line 4662
      (dtd->scaffold + *(dtd->scaffIndex + dtd->scaffLevel))->quant = quant;
#line 4663
      if (dtd->scaffLevel == 0) {
#line 4664
        if (! handleDefault) {
#line 4665
          tmp___68 = build_model(parser);
#line 4665
          model = tmp___68;
#line 4666
          if (! model) {
#line 4667
            return ((enum XML_Error )1);
          }
#line 4668
          *eventEndPP = s;
#line 4669
          (*(parser->m_elementDeclHandler))(parser->m_handlerArg, (parser->m_declElementType)->name,
                                            model);
        }
#line 4671
        dtd->in_eldecl = (XML_Bool )0;
#line 4672
        dtd->contentStringLen = 0U;
      }
    }
#line 4675
    break;
    case 55: 
#line 4679
    tmp___69 = reportProcessingInstruction(parser, enc, s, next);
#line 4679
    if (! tmp___69) {
#line 4680
      return ((enum XML_Error )1);
    }
#line 4681
    handleDefault = (XML_Bool )0;
#line 4682
    break;
    case 56: 
#line 4684
    tmp___70 = reportComment(parser, enc, s, next);
#line 4684
    if (! tmp___70) {
#line 4685
      return ((enum XML_Error )1);
    }
#line 4686
    handleDefault = (XML_Bool )0;
#line 4687
    break;
    case 0: 
#line 4689
    switch (tok) {
    case 14: 
#line 4691
    handleDefault = (XML_Bool )0;
#line 4692
    break;
    }
#line 4694
    break;
    case 3: 
#line 4696
    if (parser->m_startDoctypeDeclHandler) {
#line 4697
      handleDefault = (XML_Bool )0;
    }
#line 4698
    break;
    case 11: 
#line 4700
    if (dtd->keepProcessing) {
#line 4700
      if (parser->m_entityDeclHandler) {
#line 4701
        handleDefault = (XML_Bool )0;
      }
    }
#line 4702
    break;
    case 17: 
#line 4704
    if (parser->m_notationDeclHandler) {
#line 4705
      handleDefault = (XML_Bool )0;
    }
#line 4706
    break;
    case 33: 
#line 4708
    if (dtd->keepProcessing) {
#line 4708
      if (parser->m_attlistDeclHandler) {
#line 4709
        handleDefault = (XML_Bool )0;
      }
    }
#line 4710
    break;
    case 39: 
#line 4712
    if (parser->m_elementDeclHandler) {
#line 4713
      handleDefault = (XML_Bool )0;
    }
#line 4714
    break;
    }
#line 4717
    if (handleDefault) {
#line 4717
      if (parser->m_defaultHandler) {
#line 4718
        reportDefault(parser, enc, s, next);
      }
    }
#line 4720
    switch ((unsigned int )parser->m_parsingStatus.parsing) {
    case 3U: 
#line 4722
    *nextPtr = next;
#line 4723
    return ((enum XML_Error )0);
    case 2U: 
#line 4725
    return ((enum XML_Error )35);
    default: 
#line 4727
    s = next;
#line 4728
    tok = (*(enc->scanners[0]))(enc, s, end, & next);
    }
  }
}
}
#line 4734 "xmlparse.c"
static enum XML_Error epilogProcessor(XML_Parser parser , char const   *s , char const   *end ,
                                      char const   **nextPtr ) 
{ 
  char const   *next ;
  int tok ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 4740
  parser->m_processor = & epilogProcessor;
#line 4741
  parser->m_eventPtr = s;
#line 4742
  while (1) {
#line 4743
    next = (char const   *)((void *)0);
#line 4744
    tmp = (*((parser->m_encoding)->scanners[0]))(parser->m_encoding, s, end, & next);
#line 4744
    tok = tmp;
#line 4745
    parser->m_eventEndPtr = next;
#line 4746
    switch (tok) {
    case -15: 
#line 4749
    if (parser->m_defaultHandler) {
#line 4750
      reportDefault(parser, parser->m_encoding, s, next);
#line 4751
      if ((unsigned int )parser->m_parsingStatus.parsing == 2U) {
#line 4752
        return ((enum XML_Error )35);
      }
    }
#line 4754
    *nextPtr = next;
#line 4755
    return ((enum XML_Error )0);
    case -4: 
#line 4757
    *nextPtr = s;
#line 4758
    return ((enum XML_Error )0);
    case 15: 
#line 4760
    if (parser->m_defaultHandler) {
#line 4761
      reportDefault(parser, parser->m_encoding, s, next);
    }
#line 4762
    break;
    case 11: 
#line 4764
    tmp___0 = reportProcessingInstruction(parser, parser->m_encoding, s, next);
#line 4764
    if (! tmp___0) {
#line 4765
      return ((enum XML_Error )1);
    }
#line 4766
    break;
    case 13: 
#line 4768
    tmp___1 = reportComment(parser, parser->m_encoding, s, next);
#line 4768
    if (! tmp___1) {
#line 4769
      return ((enum XML_Error )1);
    }
#line 4770
    break;
    case 0: 
#line 4772
    parser->m_eventPtr = next;
#line 4773
    return ((enum XML_Error )4);
    case -1: 
#line 4775
    if (! parser->m_parsingStatus.finalBuffer) {
#line 4776
      *nextPtr = s;
#line 4777
      return ((enum XML_Error )0);
    }
#line 4779
    return ((enum XML_Error )5);
    case -2: 
#line 4781
    if (! parser->m_parsingStatus.finalBuffer) {
#line 4782
      *nextPtr = s;
#line 4783
      return ((enum XML_Error )0);
    }
#line 4785
    return ((enum XML_Error )6);
    default: 
#line 4787
    return ((enum XML_Error )9);
    }
#line 4789
    s = next;
#line 4789
    parser->m_eventPtr = s;
#line 4790
    switch ((unsigned int )parser->m_parsingStatus.parsing) {
    case 3U: 
#line 4792
    *nextPtr = next;
#line 4793
    return ((enum XML_Error )0);
    case 2U: 
#line 4795
    return ((enum XML_Error )35);
    default: ;
    }
  }
}
}
#line 4801 "xmlparse.c"
static enum XML_Error processInternalEntity(XML_Parser parser , ENTITY *entity , XML_Bool betweenDecl ) 
{ 
  char const   *textStart ;
  char const   *textEnd ;
  char const   *next ;
  enum XML_Error result ;
  OPEN_INTERNAL_ENTITY *openEntity ;
  void *tmp ;
  int tok ;
  int tmp___0 ;

  {
#line 4810
  if (parser->m_freeInternalEntities) {
#line 4811
    openEntity = parser->m_freeInternalEntities;
#line 4812
    parser->m_freeInternalEntities = openEntity->next;
  } else {
#line 4815
    tmp = (*(parser->m_mem.malloc_fcn))(sizeof(OPEN_INTERNAL_ENTITY ));
#line 4815
    openEntity = (OPEN_INTERNAL_ENTITY *)tmp;
#line 4816
    if (! openEntity) {
#line 4817
      return ((enum XML_Error )1);
    }
  }
#line 4819
  entity->open = (XML_Bool )1;
#line 4820
  entity->processed = 0;
#line 4821
  openEntity->next = parser->m_openInternalEntities;
#line 4822
  parser->m_openInternalEntities = openEntity;
#line 4823
  openEntity->entity = entity;
#line 4824
  openEntity->startTagLevel = parser->m_tagLevel;
#line 4825
  openEntity->betweenDecl = betweenDecl;
#line 4826
  openEntity->internalEventPtr = (char const   *)((void *)0);
#line 4827
  openEntity->internalEventEndPtr = (char const   *)((void *)0);
#line 4828
  textStart = (char const   *)((char *)entity->textPtr);
#line 4829
  textEnd = (char const   *)((char *)(entity->textPtr + entity->textLen));
#line 4832
  if (entity->is_param) {
#line 4833
    tmp___0 = (*((parser->m_internalEncoding)->scanners[0]))(parser->m_internalEncoding,
                                                             textStart, textEnd, & next);
#line 4833
    tok = tmp___0;
#line 4834
    result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd, tok,
                      next, & next, (XML_Bool )0);
  } else {
#line 4839
    result = doContent(parser, parser->m_tagLevel, parser->m_internalEncoding, textStart,
                       textEnd, & next, (XML_Bool )0);
  }
#line 4842
  if ((unsigned int )result == 0U) {
#line 4843
    if ((unsigned long )textEnd != (unsigned long )next) {
#line 4843
      if ((unsigned int )parser->m_parsingStatus.parsing == 3U) {
#line 4844
        entity->processed = (int )(next - textStart);
#line 4845
        parser->m_processor = & internalEntityProcessor;
      } else {
#line 4848
        entity->open = (XML_Bool )0;
#line 4849
        parser->m_openInternalEntities = openEntity->next;
#line 4851
        openEntity->next = parser->m_freeInternalEntities;
#line 4852
        parser->m_freeInternalEntities = openEntity;
      }
    } else {
#line 4848
      entity->open = (XML_Bool )0;
#line 4849
      parser->m_openInternalEntities = openEntity->next;
#line 4851
      openEntity->next = parser->m_freeInternalEntities;
#line 4852
      parser->m_freeInternalEntities = openEntity;
    }
  }
#line 4855
  return (result);
}
}
#line 4858 "xmlparse.c"
static enum XML_Error internalEntityProcessor(XML_Parser parser , char const   *s ,
                                              char const   *end , char const   **nextPtr ) 
{ 
  ENTITY *entity ;
  char const   *textStart ;
  char const   *textEnd ;
  char const   *next ;
  enum XML_Error result ;
  OPEN_INTERNAL_ENTITY *openEntity ;
  int tok ;
  int tmp ;
  int tok___0 ;
  enum XML_Error tmp___0 ;
  int tmp___1 ;
  enum XML_Error tmp___2 ;

  {
#line 4868
  openEntity = parser->m_openInternalEntities;
#line 4869
  if (! openEntity) {
#line 4870
    return ((enum XML_Error )23);
  }
#line 4872
  entity = openEntity->entity;
#line 4873
  textStart = (char const   *)((char *)entity->textPtr + entity->processed);
#line 4874
  textEnd = (char const   *)((char *)(entity->textPtr + entity->textLen));
#line 4877
  if (entity->is_param) {
#line 4878
    tmp = (*((parser->m_internalEncoding)->scanners[0]))(parser->m_internalEncoding,
                                                         textStart, textEnd, & next);
#line 4878
    tok = tmp;
#line 4879
    result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd, tok,
                      next, & next, (XML_Bool )0);
  } else {
#line 4884
    result = doContent(parser, openEntity->startTagLevel, parser->m_internalEncoding,
                       textStart, textEnd, & next, (XML_Bool )0);
  }
#line 4887
  if ((unsigned int )result != 0U) {
#line 4888
    return (result);
  } else
#line 4889
  if ((unsigned long )textEnd != (unsigned long )next) {
#line 4889
    if ((unsigned int )parser->m_parsingStatus.parsing == 3U) {
#line 4890
      entity->processed = (int )(next - (char const   *)((char *)entity->textPtr));
#line 4891
      return (result);
    } else {
#line 4894
      entity->open = (XML_Bool )0;
#line 4895
      parser->m_openInternalEntities = openEntity->next;
#line 4897
      openEntity->next = parser->m_freeInternalEntities;
#line 4898
      parser->m_freeInternalEntities = openEntity;
    }
  } else {
#line 4894
    entity->open = (XML_Bool )0;
#line 4895
    parser->m_openInternalEntities = openEntity->next;
#line 4897
    openEntity->next = parser->m_freeInternalEntities;
#line 4898
    parser->m_freeInternalEntities = openEntity;
  }
#line 4902
  if (entity->is_param) {
#line 4904
    parser->m_processor = & prologProcessor;
#line 4905
    tok___0 = (*((parser->m_encoding)->scanners[0]))(parser->m_encoding, s, end, & next);
#line 4906
    tmp___0 = doProlog(parser, parser->m_encoding, s, end, tok___0, next, nextPtr,
                       (XML_Bool )(! parser->m_parsingStatus.finalBuffer));
#line 4906
    return (tmp___0);
  } else {
#line 4912
    parser->m_processor = & contentProcessor;
#line 4914
    if (parser->m_parentParser) {
#line 4914
      tmp___1 = 1;
    } else {
#line 4914
      tmp___1 = 0;
    }
#line 4914
    tmp___2 = doContent(parser, tmp___1, parser->m_encoding, s, end, nextPtr, (XML_Bool )(! parser->m_parsingStatus.finalBuffer));
#line 4914
    return (tmp___2);
  }
}
}
#line 4919 "xmlparse.c"
static enum XML_Error errorProcessor(XML_Parser parser , char const   *s , char const   *end ,
                                     char const   **nextPtr ) 
{ 


  {
#line 4925
  return (parser->m_errorCode);
}
}
#line 4928 "xmlparse.c"
static enum XML_Error storeAttributeValue(XML_Parser parser , ENCODING const   *enc ,
                                          XML_Bool isCdata , char const   *ptr , char const   *end ,
                                          STRING_POOL *pool ) 
{ 
  enum XML_Error result ;
  enum XML_Error tmp ;
  XML_Char *tmp___1 ;
  int tmp___2 ;
  XML_Bool tmp___3 ;

  {
#line 4933
  tmp = appendAttributeValue(parser, enc, isCdata, ptr, end, pool);
#line 4933
  result = tmp;
#line 4935
  if (result) {
#line 4936
    return (result);
  }
#line 4937
  if (! isCdata) {
#line 4937
    if (pool->ptr - pool->start) {
#line 4937
      if ((int )*(pool->ptr + -1) == 32) {
#line 4938
        (pool->ptr) --;
      }
    }
  }
#line 4939
  if ((unsigned long )pool->ptr == (unsigned long )pool->end) {
#line 4939
    tmp___3 = poolGrow(pool);
#line 4939
    if (tmp___3) {
#line 4939
      tmp___1 = pool->ptr;
#line 4939
      (pool->ptr) ++;
#line 4939
      *tmp___1 = (XML_Char )'\000';
#line 4939
      tmp___2 = 1;
    } else {
#line 4939
      tmp___2 = 0;
    }
  } else {
#line 4939
    tmp___1 = pool->ptr;
#line 4939
    (pool->ptr) ++;
#line 4939
    *tmp___1 = (XML_Char )'\000';
#line 4939
    tmp___2 = 1;
  }
#line 4939
  if (! tmp___2) {
#line 4940
    return ((enum XML_Error )1);
  }
#line 4941
  return ((enum XML_Error )0);
}
}
#line 4944 "xmlparse.c"
static enum XML_Error appendAttributeValue(XML_Parser parser , ENCODING const   *enc ,
                                           XML_Bool isCdata , char const   *ptr ,
                                           char const   *end , STRING_POOL *pool ) 
{ 
  DTD *dtd ;
  char const   *next ;
  int tok ;
  int tmp ;
  XML_Char buf[4] ;
  int i ;
  int n ;
  int tmp___0 ;
  XML_Char *tmp___2 ;
  int tmp___3 ;
  XML_Bool tmp___4 ;
  XML_Char *tmp___5 ;
  XML_Char *tmp___7 ;
  int tmp___8 ;
  XML_Bool tmp___9 ;
  XML_Char const   *name ;
  ENTITY *entity ;
  char checkEntityDecl ;
  XML_Char ch ;
  int tmp___10 ;
  XML_Char *tmp___12 ;
  int tmp___13 ;
  XML_Bool tmp___14 ;
  XML_Char *tmp___15 ;
  NAMED *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  enum XML_Error result ;
  XML_Char const   *textEnd ;

  {
#line 4949
  dtd = parser->m_dtd;
#line 4950
  while (1) {
#line 4952
    tmp = (*(enc->literalScanners[0]))(enc, ptr, end, & next);
#line 4952
    tok = tmp;
#line 4953
    switch (tok) {
    case -4: 
#line 4955
    return ((enum XML_Error )0);
    case 0: 
#line 4957
    if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 4958
      parser->m_eventPtr = next;
    }
#line 4959
    return ((enum XML_Error )4);
    case -1: 
#line 4961
    if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 4962
      parser->m_eventPtr = ptr;
    }
#line 4963
    return ((enum XML_Error )4);
    case 10: 
#line 4968
    tmp___0 = (*(enc->charRefNumber))(enc, ptr);
#line 4968
    n = tmp___0;
#line 4969
    if (n < 0) {
#line 4970
      if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 4971
        parser->m_eventPtr = ptr;
      }
#line 4972
      return ((enum XML_Error )14);
    }
#line 4974
    if (! isCdata) {
#line 4974
      if (n == 32) {
#line 4974
        if (pool->ptr - pool->start == 0L) {
#line 4977
          break;
        } else
#line 4974
        if ((int )*(pool->ptr + -1) == 32) {
#line 4977
          break;
        }
      }
    }
#line 4978
    n = XmlUtf8Encode(n, buf);
#line 4979
    if (! n) {
#line 4980
      if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 4981
        parser->m_eventPtr = ptr;
      }
#line 4982
      return ((enum XML_Error )14);
    }
#line 4984
    i = 0;
#line 4984
    while (i < n) {
#line 4985
      if ((unsigned long )pool->ptr == (unsigned long )pool->end) {
#line 4985
        tmp___4 = poolGrow(pool);
#line 4985
        if (tmp___4) {
#line 4985
          tmp___2 = pool->ptr;
#line 4985
          (pool->ptr) ++;
#line 4985
          *tmp___2 = buf[i];
#line 4985
          tmp___3 = 1;
        } else {
#line 4985
          tmp___3 = 0;
        }
      } else {
#line 4985
        tmp___2 = pool->ptr;
#line 4985
        (pool->ptr) ++;
#line 4985
        *tmp___2 = buf[i];
#line 4985
        tmp___3 = 1;
      }
#line 4985
      if (! tmp___3) {
#line 4986
        return ((enum XML_Error )1);
      }
#line 4984
      i ++;
    }
#line 4989
    break;
    case 6: 
#line 4991
    tmp___5 = poolAppend(pool, enc, ptr, next);
#line 4991
    if (! tmp___5) {
#line 4992
      return ((enum XML_Error )1);
    }
#line 4993
    break;
    case -3: 
#line 4995
    next = ptr + enc->minBytesPerChar;
    case 7: 
    case 39: 
#line 4999
    if (! isCdata) {
#line 4999
      if (pool->ptr - pool->start == 0L) {
#line 5000
        break;
      } else
#line 4999
      if ((int )*(pool->ptr + -1) == 32) {
#line 5000
        break;
      }
    }
#line 5001
    if ((unsigned long )pool->ptr == (unsigned long )pool->end) {
#line 5001
      tmp___9 = poolGrow(pool);
#line 5001
      if (tmp___9) {
#line 5001
        tmp___7 = pool->ptr;
#line 5001
        (pool->ptr) ++;
#line 5001
        *tmp___7 = (XML_Char )32;
#line 5001
        tmp___8 = 1;
      } else {
#line 5001
        tmp___8 = 0;
      }
    } else {
#line 5001
      tmp___7 = pool->ptr;
#line 5001
      (pool->ptr) ++;
#line 5001
      *tmp___7 = (XML_Char )32;
#line 5001
      tmp___8 = 1;
    }
#line 5001
    if (! tmp___8) {
#line 5002
      return ((enum XML_Error )1);
    }
#line 5003
    break;
    case 9: 
#line 5009
    tmp___10 = (*(enc->predefinedEntityName))(enc, ptr + enc->minBytesPerChar, next - enc->minBytesPerChar);
#line 5009
    ch = (XML_Char )tmp___10;
#line 5012
    if (ch) {
#line 5013
      if ((unsigned long )pool->ptr == (unsigned long )pool->end) {
#line 5013
        tmp___14 = poolGrow(pool);
#line 5013
        if (tmp___14) {
#line 5013
          tmp___12 = pool->ptr;
#line 5013
          (pool->ptr) ++;
#line 5013
          *tmp___12 = ch;
#line 5013
          tmp___13 = 1;
        } else {
#line 5013
          tmp___13 = 0;
        }
      } else {
#line 5013
        tmp___12 = pool->ptr;
#line 5013
        (pool->ptr) ++;
#line 5013
        *tmp___12 = ch;
#line 5013
        tmp___13 = 1;
      }
#line 5013
      if (! tmp___13) {
#line 5014
        return ((enum XML_Error )1);
      }
#line 5015
      break;
    }
#line 5017
    tmp___15 = poolStoreString(& parser->m_temp2Pool, enc, ptr + enc->minBytesPerChar,
                               next - enc->minBytesPerChar);
#line 5017
    name = (XML_Char const   *)tmp___15;
#line 5020
    if (! name) {
#line 5021
      return ((enum XML_Error )1);
    }
#line 5022
    tmp___16 = lookup(parser, & dtd->generalEntities, name, (size_t )0);
#line 5022
    entity = (ENTITY *)tmp___16;
#line 5023
    parser->m_temp2Pool.ptr = parser->m_temp2Pool.start;
#line 5027
    if ((unsigned long )pool == (unsigned long )(& dtd->pool)) {
#line 5028
      if (parser->m_prologState.documentEntity) {
#line 5028
        if (dtd->standalone) {
#line 5028
          tmp___17 = ! parser->m_openInternalEntities;
        } else {
#line 5028
          tmp___17 = ! dtd->hasParamEntityRefs;
        }
#line 5028
        if (tmp___17) {
#line 5028
          tmp___18 = 1;
        } else {
#line 5028
          tmp___18 = 0;
        }
      } else {
#line 5028
        tmp___18 = 0;
      }
#line 5028
      checkEntityDecl = (char )tmp___18;
    } else {
#line 5036
      if (! dtd->hasParamEntityRefs) {
#line 5036
        tmp___19 = 1;
      } else
#line 5036
      if (dtd->standalone) {
#line 5036
        tmp___19 = 1;
      } else {
#line 5036
        tmp___19 = 0;
      }
#line 5036
      checkEntityDecl = (char )tmp___19;
    }
#line 5037
    if (checkEntityDecl) {
#line 5038
      if (! entity) {
#line 5039
        return ((enum XML_Error )11);
      } else
#line 5040
      if (! entity->is_internal) {
#line 5041
        return ((enum XML_Error )24);
      }
    } else
#line 5043
    if (! entity) {
#line 5054
      break;
    }
#line 5056
    if (entity->open) {
#line 5057
      if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 5058
        parser->m_eventPtr = ptr;
      }
#line 5059
      return ((enum XML_Error )12);
    }
#line 5061
    if (entity->notation) {
#line 5062
      if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 5063
        parser->m_eventPtr = ptr;
      }
#line 5064
      return ((enum XML_Error )15);
    }
#line 5066
    if (! entity->textPtr) {
#line 5067
      if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 5068
        parser->m_eventPtr = ptr;
      }
#line 5069
      return ((enum XML_Error )16);
    } else {
#line 5073
      textEnd = entity->textPtr + entity->textLen;
#line 5074
      entity->open = (XML_Bool )1;
#line 5075
      result = appendAttributeValue(parser, parser->m_internalEncoding, isCdata, (char const   *)((char *)entity->textPtr),
                                    (char const   *)((char *)textEnd), pool);
#line 5078
      entity->open = (XML_Bool )0;
#line 5079
      if (result) {
#line 5080
        return (result);
      }
    }
#line 5083
    break;
    default: 
#line 5085
    if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 5086
      parser->m_eventPtr = ptr;
    }
#line 5087
    return ((enum XML_Error )23);
    }
#line 5089
    ptr = next;
  }
}
}
#line 5094 "xmlparse.c"
static enum XML_Error storeEntityValue(XML_Parser parser , ENCODING const   *enc ,
                                       char const   *entityTextPtr , char const   *entityTextEnd ) 
{ 
  DTD *dtd ;
  STRING_POOL *pool ;
  enum XML_Error result ;
  int oldInEntityValue ;
  XML_Bool tmp ;
  char const   *next ;
  int tok ;
  int tmp___0 ;
  XML_Char const   *name ;
  ENTITY *entity ;
  XML_Char *tmp___1 ;
  NAMED *tmp___2 ;
  int tmp___3 ;
  XML_Char *tmp___4 ;
  XML_Bool tmp___5 ;
  XML_Char *tmp___6 ;
  XML_Char buf[4] ;
  int i ;
  int n ;
  int tmp___7 ;
  XML_Bool tmp___8 ;
  XML_Char *tmp___9 ;

  {
#line 5100
  dtd = parser->m_dtd;
#line 5101
  pool = & dtd->entityValuePool;
#line 5102
  result = (enum XML_Error )0;
#line 5104
  oldInEntityValue = parser->m_prologState.inEntityValue;
#line 5105
  parser->m_prologState.inEntityValue = 1;
#line 5110
  if (! pool->blocks) {
#line 5111
    tmp = poolGrow(pool);
#line 5111
    if (! tmp) {
#line 5112
      return ((enum XML_Error )1);
    }
  }
#line 5115
  while (1) {
#line 5117
    tmp___0 = (*(enc->literalScanners[1]))(enc, entityTextPtr, entityTextEnd, & next);
#line 5117
    tok = tmp___0;
#line 5118
    switch (tok) {
    case 28: 
#line 5121
    if (parser->m_isParamEntity) {
#line 5121
      goto _L;
    } else
#line 5121
    if ((unsigned long )enc != (unsigned long )parser->m_encoding) {
      _L: /* CIL Label */ 
#line 5124
      tmp___1 = poolStoreString(& parser->m_tempPool, enc, entityTextPtr + enc->minBytesPerChar,
                                next - enc->minBytesPerChar);
#line 5124
      name = (XML_Char const   *)tmp___1;
#line 5127
      if (! name) {
#line 5128
        result = (enum XML_Error )1;
#line 5129
        goto endEntityValue;
      }
#line 5131
      tmp___2 = lookup(parser, & dtd->paramEntities, name, (size_t )0);
#line 5131
      entity = (ENTITY *)tmp___2;
#line 5132
      parser->m_tempPool.ptr = parser->m_tempPool.start;
#line 5133
      if (! entity) {
#line 5140
        dtd->keepProcessing = dtd->standalone;
#line 5141
        goto endEntityValue;
      }
#line 5143
      if (entity->open) {
#line 5144
        if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 5145
          parser->m_eventPtr = entityTextPtr;
        }
#line 5146
        result = (enum XML_Error )12;
#line 5147
        goto endEntityValue;
      }
#line 5149
      if (entity->systemId) {
#line 5150
        if (parser->m_externalEntityRefHandler) {
#line 5151
          dtd->paramEntityRead = (XML_Bool )0;
#line 5152
          entity->open = (XML_Bool )1;
#line 5153
          tmp___3 = (*(parser->m_externalEntityRefHandler))(parser->m_externalEntityRefHandlerArg,
                                                            (XML_Char const   *)0,
                                                            entity->base, entity->systemId,
                                                            entity->publicId);
#line 5153
          if (! tmp___3) {
#line 5158
            entity->open = (XML_Bool )0;
#line 5159
            result = (enum XML_Error )21;
#line 5160
            goto endEntityValue;
          }
#line 5162
          entity->open = (XML_Bool )0;
#line 5163
          if (! dtd->paramEntityRead) {
#line 5164
            dtd->keepProcessing = dtd->standalone;
          }
        } else {
#line 5167
          dtd->keepProcessing = dtd->standalone;
        }
      } else {
#line 5170
        entity->open = (XML_Bool )1;
#line 5171
        result = storeEntityValue(parser, parser->m_internalEncoding, (char const   *)((char *)entity->textPtr),
                                  (char const   *)((char *)(entity->textPtr + entity->textLen)));
#line 5176
        entity->open = (XML_Bool )0;
#line 5177
        if (result) {
#line 5178
          goto endEntityValue;
        }
      }
#line 5180
      break;
    }
#line 5185
    parser->m_eventPtr = entityTextPtr;
#line 5186
    result = (enum XML_Error )10;
#line 5187
    goto endEntityValue;
    case -4: 
#line 5189
    result = (enum XML_Error )0;
#line 5190
    goto endEntityValue;
    case 6: 
    case 9: 
#line 5193
    tmp___4 = poolAppend(pool, enc, entityTextPtr, next);
#line 5193
    if (! tmp___4) {
#line 5194
      result = (enum XML_Error )1;
#line 5195
      goto endEntityValue;
    }
#line 5197
    break;
    case -3: 
#line 5199
    next = entityTextPtr + enc->minBytesPerChar;
    case 7: 
#line 5202
    if ((unsigned long )pool->end == (unsigned long )pool->ptr) {
#line 5202
      tmp___5 = poolGrow(pool);
#line 5202
      if (! tmp___5) {
#line 5203
        result = (enum XML_Error )1;
#line 5204
        goto endEntityValue;
      }
    }
#line 5206
    tmp___6 = pool->ptr;
#line 5206
    (pool->ptr) ++;
#line 5206
    *tmp___6 = (XML_Char )10;
#line 5207
    break;
    case 10: 
#line 5212
    tmp___7 = (*(enc->charRefNumber))(enc, entityTextPtr);
#line 5212
    n = tmp___7;
#line 5213
    if (n < 0) {
#line 5214
      if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 5215
        parser->m_eventPtr = entityTextPtr;
      }
#line 5216
      result = (enum XML_Error )14;
#line 5217
      goto endEntityValue;
    }
#line 5219
    n = XmlUtf8Encode(n, buf);
#line 5220
    if (! n) {
#line 5221
      if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 5222
        parser->m_eventPtr = entityTextPtr;
      }
#line 5223
      result = (enum XML_Error )14;
#line 5224
      goto endEntityValue;
    }
#line 5226
    i = 0;
#line 5226
    while (i < n) {
#line 5227
      if ((unsigned long )pool->end == (unsigned long )pool->ptr) {
#line 5227
        tmp___8 = poolGrow(pool);
#line 5227
        if (! tmp___8) {
#line 5228
          result = (enum XML_Error )1;
#line 5229
          goto endEntityValue;
        }
      }
#line 5231
      tmp___9 = pool->ptr;
#line 5231
      (pool->ptr) ++;
#line 5231
      *tmp___9 = buf[i];
#line 5226
      i ++;
    }
#line 5234
    break;
    case -1: 
#line 5236
    if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 5237
      parser->m_eventPtr = entityTextPtr;
    }
#line 5238
    result = (enum XML_Error )4;
#line 5239
    goto endEntityValue;
    case 0: 
#line 5241
    if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 5242
      parser->m_eventPtr = next;
    }
#line 5243
    result = (enum XML_Error )4;
#line 5244
    goto endEntityValue;
    default: 
#line 5246
    if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 5247
      parser->m_eventPtr = entityTextPtr;
    }
#line 5248
    result = (enum XML_Error )23;
#line 5249
    goto endEntityValue;
    }
#line 5251
    entityTextPtr = next;
  }
  endEntityValue: 
#line 5255
  parser->m_prologState.inEntityValue = oldInEntityValue;
#line 5257
  return (result);
}
}
#line 5260 "xmlparse.c"
static void normalizeLines(XML_Char *s ) 
{ 
  XML_Char *p ;
  XML_Char *tmp ;
  XML_Char *tmp___0 ;
  XML_Char *tmp___1 ;

  {
#line 5264
  while (1) {
#line 5265
    if ((int )*s == 0) {
#line 5266
      return;
    }
#line 5267
    if ((int )*s == 13) {
#line 5268
      break;
    }
#line 5264
    s ++;
  }
#line 5270
  p = s;
#line 5271
  while (1) {
#line 5272
    if ((int )*s == 13) {
#line 5273
      tmp = p;
#line 5273
      p ++;
#line 5273
      *tmp = (XML_Char )10;
#line 5274
      s ++;
#line 5274
      if ((int )*s == 10) {
#line 5275
        s ++;
      }
    } else {
#line 5278
      tmp___0 = p;
#line 5278
      p ++;
#line 5278
      tmp___1 = s;
#line 5278
      s ++;
#line 5278
      *tmp___0 = *tmp___1;
    }
#line 5271
    if (! *s) {
#line 5271
      break;
    }
  }
#line 5280
  *p = (XML_Char )'\000';
#line 5281
  return;
}
}
#line 5283 "xmlparse.c"
static int reportProcessingInstruction(XML_Parser parser , ENCODING const   *enc ,
                                       char const   *start , char const   *end ) 
{ 
  XML_Char const   *target ;
  XML_Char *data ;
  char const   *tem ;
  int tmp ;
  XML_Char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 5290
  if (! parser->m_processingInstructionHandler) {
#line 5291
    if (parser->m_defaultHandler) {
#line 5292
      reportDefault(parser, enc, start, end);
    }
#line 5293
    return (1);
  }
#line 5295
  start += enc->minBytesPerChar * 2;
#line 5296
  tmp = (*(enc->nameLength))(enc, start);
#line 5296
  tem = start + tmp;
#line 5297
  tmp___0 = poolStoreString(& parser->m_tempPool, enc, start, tem);
#line 5297
  target = (XML_Char const   *)tmp___0;
#line 5298
  if (! target) {
#line 5299
    return (0);
  }
#line 5300
  parser->m_tempPool.start = parser->m_tempPool.ptr;
#line 5301
  tmp___1 = (*(enc->skipS))(enc, tem);
#line 5301
  data = poolStoreString(& parser->m_tempPool, enc, tmp___1, end - enc->minBytesPerChar * 2);
#line 5304
  if (! data) {
#line 5305
    return (0);
  }
#line 5306
  normalizeLines(data);
#line 5307
  (*(parser->m_processingInstructionHandler))(parser->m_handlerArg, target, (XML_Char const   *)data);
#line 5308
  poolClear(& parser->m_tempPool);
#line 5309
  return (1);
}
}
#line 5312 "xmlparse.c"
static int reportComment(XML_Parser parser , ENCODING const   *enc , char const   *start ,
                         char const   *end ) 
{ 
  XML_Char *data ;

  {
#line 5317
  if (! parser->m_commentHandler) {
#line 5318
    if (parser->m_defaultHandler) {
#line 5319
      reportDefault(parser, enc, start, end);
    }
#line 5320
    return (1);
  }
#line 5322
  data = poolStoreString(& parser->m_tempPool, enc, start + enc->minBytesPerChar * 4,
                         end - enc->minBytesPerChar * 3);
#line 5326
  if (! data) {
#line 5327
    return (0);
  }
#line 5328
  normalizeLines(data);
#line 5329
  (*(parser->m_commentHandler))(parser->m_handlerArg, (XML_Char const   *)data);
#line 5330
  poolClear(& parser->m_tempPool);
#line 5331
  return (1);
}
}
#line 5334 "xmlparse.c"
static void reportDefault(XML_Parser parser , ENCODING const   *enc , char const   *s ,
                          char const   *end ) 
{ 
  char const   **eventPP ;
  char const   **eventEndPP ;
  ICHAR *dataPtr ;

  {
#line 5338
  if (! enc->isUtf8) {
#line 5341
    if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 5342
      eventPP = & parser->m_eventPtr;
#line 5343
      eventEndPP = & parser->m_eventEndPtr;
    } else {
#line 5346
      eventPP = & (parser->m_openInternalEntities)->internalEventPtr;
#line 5347
      eventEndPP = & (parser->m_openInternalEntities)->internalEventEndPtr;
    }
#line 5349
    while (1) {
#line 5350
      dataPtr = parser->m_dataBuf;
#line 5351
      (*(enc->utf8Convert))(enc, & s, end, & dataPtr, (char const   *)parser->m_dataBufEnd);
#line 5352
      *eventEndPP = s;
#line 5353
      (*(parser->m_defaultHandler))(parser->m_handlerArg, (XML_Char const   *)parser->m_dataBuf,
                                    (int )(dataPtr - parser->m_dataBuf));
#line 5354
      *eventPP = s;
#line 5349
      if (! ((unsigned long )s != (unsigned long )end)) {
#line 5349
        break;
      }
    }
  } else {
#line 5358
    (*(parser->m_defaultHandler))(parser->m_handlerArg, (XML_Char const   *)((XML_Char *)s),
                                  (int )((XML_Char *)end - (XML_Char *)s));
  }
#line 5359
  return;
}
}
#line 5362 "xmlparse.c"
static int defineAttribute(ELEMENT_TYPE *type , ATTRIBUTE_ID *attId , XML_Bool isCdata ,
                           XML_Bool isId , XML_Char const   *value , XML_Parser parser ) 
{ 
  DEFAULT_ATTRIBUTE *att ;
  int i ;
  void *tmp ;
  DEFAULT_ATTRIBUTE *temp ;
  int count ;
  void *tmp___0 ;

  {
#line 5367
  if (value) {
#line 5367
    goto _L;
  } else
#line 5367
  if (isId) {
    _L: /* CIL Label */ 
#line 5371
    i = 0;
#line 5371
    while (i < type->nDefaultAtts) {
#line 5372
      if ((unsigned long )attId == (unsigned long )(type->defaultAtts + i)->id) {
#line 5373
        return (1);
      }
#line 5371
      i ++;
    }
#line 5374
    if (isId) {
#line 5374
      if (! type->idAtt) {
#line 5374
        if (! attId->xmlns) {
#line 5375
          type->idAtt = (ATTRIBUTE_ID const   *)attId;
        }
      }
    }
  }
#line 5377
  if (type->nDefaultAtts == type->allocDefaultAtts) {
#line 5378
    if (type->allocDefaultAtts == 0) {
#line 5379
      type->allocDefaultAtts = 8;
#line 5380
      tmp = (*(parser->m_mem.malloc_fcn))((unsigned long )type->allocDefaultAtts * sizeof(DEFAULT_ATTRIBUTE ));
#line 5380
      type->defaultAtts = (DEFAULT_ATTRIBUTE *)tmp;
#line 5382
      if (! type->defaultAtts) {
#line 5383
        return (0);
      }
    } else {
#line 5387
      count = type->allocDefaultAtts * 2;
#line 5388
      tmp___0 = (*(parser->m_mem.realloc_fcn))((void *)type->defaultAtts, (unsigned long )count * sizeof(DEFAULT_ATTRIBUTE ));
#line 5388
      temp = (DEFAULT_ATTRIBUTE *)tmp___0;
#line 5390
      if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 5391
        return (0);
      }
#line 5392
      type->allocDefaultAtts = count;
#line 5393
      type->defaultAtts = temp;
    }
  }
#line 5396
  att = type->defaultAtts + type->nDefaultAtts;
#line 5397
  att->id = (ATTRIBUTE_ID const   *)attId;
#line 5398
  att->value = value;
#line 5399
  att->isCdata = isCdata;
#line 5400
  if (! isCdata) {
#line 5401
    attId->maybeTokenized = (XML_Bool )1;
  }
#line 5402
  (type->nDefaultAtts) ++;
#line 5403
  return (1);
}
}
#line 5406 "xmlparse.c"
static int setElementTypePrefix(XML_Parser parser , ELEMENT_TYPE *elementType ) 
{ 
  DTD *dtd ;
  XML_Char const   *name ;
  PREFIX *prefix ;
  XML_Char const   *s ;
  XML_Char *tmp___0 ;
  int tmp___1 ;
  XML_Bool tmp___2 ;
  XML_Char *tmp___4 ;
  int tmp___5 ;
  XML_Bool tmp___6 ;
  NAMED *tmp___7 ;

  {
#line 5409
  dtd = parser->m_dtd;
#line 5411
  name = elementType->name;
#line 5411
  while (*name) {
#line 5412
    if ((int const   )*name == 58) {
#line 5415
      s = elementType->name;
#line 5415
      while ((unsigned long )s != (unsigned long )name) {
#line 5416
        if ((unsigned long )dtd->pool.ptr == (unsigned long )dtd->pool.end) {
#line 5416
          tmp___2 = poolGrow(& dtd->pool);
#line 5416
          if (tmp___2) {
#line 5416
            tmp___0 = dtd->pool.ptr;
#line 5416
            (dtd->pool.ptr) ++;
#line 5416
            *tmp___0 = (XML_Char )*s;
#line 5416
            tmp___1 = 1;
          } else {
#line 5416
            tmp___1 = 0;
          }
        } else {
#line 5416
          tmp___0 = dtd->pool.ptr;
#line 5416
          (dtd->pool.ptr) ++;
#line 5416
          *tmp___0 = (XML_Char )*s;
#line 5416
          tmp___1 = 1;
        }
#line 5416
        if (! tmp___1) {
#line 5417
          return (0);
        }
#line 5415
        s ++;
      }
#line 5419
      if ((unsigned long )dtd->pool.ptr == (unsigned long )dtd->pool.end) {
#line 5419
        tmp___6 = poolGrow(& dtd->pool);
#line 5419
        if (tmp___6) {
#line 5419
          tmp___4 = dtd->pool.ptr;
#line 5419
          (dtd->pool.ptr) ++;
#line 5419
          *tmp___4 = (XML_Char )'\000';
#line 5419
          tmp___5 = 1;
        } else {
#line 5419
          tmp___5 = 0;
        }
      } else {
#line 5419
        tmp___4 = dtd->pool.ptr;
#line 5419
        (dtd->pool.ptr) ++;
#line 5419
        *tmp___4 = (XML_Char )'\000';
#line 5419
        tmp___5 = 1;
      }
#line 5419
      if (! tmp___5) {
#line 5420
        return (0);
      }
#line 5421
      tmp___7 = lookup(parser, & dtd->prefixes, (KEY )dtd->pool.start, sizeof(PREFIX ));
#line 5421
      prefix = (PREFIX *)tmp___7;
#line 5423
      if (! prefix) {
#line 5424
        return (0);
      }
#line 5425
      if ((unsigned long )prefix->name == (unsigned long )dtd->pool.start) {
#line 5426
        dtd->pool.start = dtd->pool.ptr;
      } else {
#line 5428
        dtd->pool.ptr = dtd->pool.start;
      }
#line 5429
      elementType->prefix = prefix;
    }
#line 5411
    name ++;
  }
#line 5433
  return (1);
}
}
#line 5436 "xmlparse.c"
static ATTRIBUTE_ID *getAttributeId(XML_Parser parser , ENCODING const   *enc , char const   *start ,
                                    char const   *end ) 
{ 
  DTD *dtd ;
  ATTRIBUTE_ID *id ;
  XML_Char const   *name ;
  XML_Char *tmp___0 ;
  int tmp___1 ;
  XML_Bool tmp___2 ;
  XML_Char *tmp___3 ;
  NAMED *tmp___4 ;
  NAMED *tmp___5 ;
  int i ;
  int j ;
  XML_Char *tmp___7 ;
  int tmp___8 ;
  XML_Bool tmp___9 ;
  XML_Char *tmp___11 ;
  int tmp___12 ;
  XML_Bool tmp___13 ;
  NAMED *tmp___14 ;

  {
#line 5440
  dtd = parser->m_dtd;
#line 5443
  if ((unsigned long )dtd->pool.ptr == (unsigned long )dtd->pool.end) {
#line 5443
    tmp___2 = poolGrow(& dtd->pool);
#line 5443
    if (tmp___2) {
#line 5443
      tmp___0 = dtd->pool.ptr;
#line 5443
      (dtd->pool.ptr) ++;
#line 5443
      *tmp___0 = (XML_Char )'\000';
#line 5443
      tmp___1 = 1;
    } else {
#line 5443
      tmp___1 = 0;
    }
  } else {
#line 5443
    tmp___0 = dtd->pool.ptr;
#line 5443
    (dtd->pool.ptr) ++;
#line 5443
    *tmp___0 = (XML_Char )'\000';
#line 5443
    tmp___1 = 1;
  }
#line 5443
  if (! tmp___1) {
#line 5444
    return ((ATTRIBUTE_ID *)((void *)0));
  }
#line 5445
  tmp___3 = poolStoreString(& dtd->pool, enc, start, end);
#line 5445
  name = (XML_Char const   *)tmp___3;
#line 5446
  if (! name) {
#line 5447
    return ((ATTRIBUTE_ID *)((void *)0));
  }
#line 5449
  name ++;
#line 5450
  tmp___4 = lookup(parser, & dtd->attributeIds, name, sizeof(ATTRIBUTE_ID ));
#line 5450
  id = (ATTRIBUTE_ID *)tmp___4;
#line 5451
  if (! id) {
#line 5452
    return ((ATTRIBUTE_ID *)((void *)0));
  }
#line 5453
  if ((unsigned long )id->name != (unsigned long )name) {
#line 5454
    dtd->pool.ptr = dtd->pool.start;
  } else {
#line 5456
    dtd->pool.start = dtd->pool.ptr;
#line 5457
    if (! (! parser->m_ns)) {
#line 5459
      if ((int const   )*(name + 0) == 120) {
#line 5459
        if ((int const   )*(name + 1) == 109) {
#line 5459
          if ((int const   )*(name + 2) == 108) {
#line 5459
            if ((int const   )*(name + 3) == 110) {
#line 5459
              if ((int const   )*(name + 4) == 115) {
#line 5459
                if ((int const   )*(name + 5) == 0) {
#line 5459
                  goto _L___0;
                } else
#line 5459
                if ((int const   )*(name + 5) == 58) {
                  _L___0: /* CIL Label */ 
#line 5465
                  if ((int const   )*(name + 5) == 0) {
#line 5466
                    id->prefix = & dtd->defaultPrefix;
                  } else {
#line 5468
                    tmp___5 = lookup(parser, & dtd->prefixes, name + 6, sizeof(PREFIX ));
#line 5468
                    id->prefix = (PREFIX *)tmp___5;
                  }
#line 5469
                  id->xmlns = (XML_Bool )1;
                } else {
#line 5459
                  goto _L___4;
                }
              } else {
#line 5459
                goto _L___4;
              }
            } else {
#line 5459
              goto _L___4;
            }
          } else {
#line 5459
            goto _L___4;
          }
        } else {
#line 5459
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ 
#line 5473
        i = 0;
#line 5473
        while (*(name + i)) {
#line 5475
          if ((int const   )*(name + i) == 58) {
#line 5477
            j = 0;
#line 5477
            while (j < i) {
#line 5478
              if ((unsigned long )dtd->pool.ptr == (unsigned long )dtd->pool.end) {
#line 5478
                tmp___9 = poolGrow(& dtd->pool);
#line 5478
                if (tmp___9) {
#line 5478
                  tmp___7 = dtd->pool.ptr;
#line 5478
                  (dtd->pool.ptr) ++;
#line 5478
                  *tmp___7 = (XML_Char )*(name + j);
#line 5478
                  tmp___8 = 1;
                } else {
#line 5478
                  tmp___8 = 0;
                }
              } else {
#line 5478
                tmp___7 = dtd->pool.ptr;
#line 5478
                (dtd->pool.ptr) ++;
#line 5478
                *tmp___7 = (XML_Char )*(name + j);
#line 5478
                tmp___8 = 1;
              }
#line 5478
              if (! tmp___8) {
#line 5479
                return ((ATTRIBUTE_ID *)((void *)0));
              }
#line 5477
              j ++;
            }
#line 5481
            if ((unsigned long )dtd->pool.ptr == (unsigned long )dtd->pool.end) {
#line 5481
              tmp___13 = poolGrow(& dtd->pool);
#line 5481
              if (tmp___13) {
#line 5481
                tmp___11 = dtd->pool.ptr;
#line 5481
                (dtd->pool.ptr) ++;
#line 5481
                *tmp___11 = (XML_Char )'\000';
#line 5481
                tmp___12 = 1;
              } else {
#line 5481
                tmp___12 = 0;
              }
            } else {
#line 5481
              tmp___11 = dtd->pool.ptr;
#line 5481
              (dtd->pool.ptr) ++;
#line 5481
              *tmp___11 = (XML_Char )'\000';
#line 5481
              tmp___12 = 1;
            }
#line 5481
            if (! tmp___12) {
#line 5482
              return ((ATTRIBUTE_ID *)((void *)0));
            }
#line 5483
            tmp___14 = lookup(parser, & dtd->prefixes, (KEY )dtd->pool.start, sizeof(PREFIX ));
#line 5483
            id->prefix = (PREFIX *)tmp___14;
#line 5485
            if ((unsigned long )(id->prefix)->name == (unsigned long )dtd->pool.start) {
#line 5486
              dtd->pool.start = dtd->pool.ptr;
            } else {
#line 5488
              dtd->pool.ptr = dtd->pool.start;
            }
#line 5489
            break;
          }
#line 5473
          i ++;
        }
      }
    }
  }
#line 5494
  return (id);
}
}
#line 5499 "xmlparse.c"
static XML_Char const   *getContext(XML_Parser parser ) 
{ 
  DTD *dtd ;
  HASH_TABLE_ITER iter ;
  XML_Bool needSep ;
  int i ;
  int len ;
  XML_Char *tmp___0 ;
  int tmp___1 ;
  XML_Bool tmp___2 ;
  XML_Char *tmp___4 ;
  int tmp___5 ;
  XML_Bool tmp___6 ;
  int i___0 ;
  int len___0 ;
  XML_Char const   *s ;
  PREFIX *prefix ;
  NAMED *tmp___7 ;
  XML_Char *tmp___9 ;
  int tmp___10 ;
  XML_Bool tmp___11 ;
  XML_Char *tmp___13 ;
  int tmp___14 ;
  XML_Bool tmp___15 ;
  XML_Char *tmp___17 ;
  int tmp___18 ;
  XML_Bool tmp___19 ;
  XML_Char *tmp___21 ;
  int tmp___22 ;
  XML_Bool tmp___23 ;
  XML_Char const   *s___0 ;
  ENTITY *e ;
  NAMED *tmp___24 ;
  XML_Char *tmp___26 ;
  int tmp___27 ;
  XML_Bool tmp___28 ;
  XML_Char *tmp___30 ;
  int tmp___31 ;
  XML_Bool tmp___32 ;
  XML_Char *tmp___34 ;
  int tmp___35 ;
  XML_Bool tmp___36 ;

  {
#line 5502
  dtd = parser->m_dtd;
#line 5504
  needSep = (XML_Bool )0;
#line 5506
  if (dtd->defaultPrefix.binding) {
#line 5509
    if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
#line 5509
      tmp___2 = poolGrow(& parser->m_tempPool);
#line 5509
      if (tmp___2) {
#line 5509
        tmp___0 = parser->m_tempPool.ptr;
#line 5509
        (parser->m_tempPool.ptr) ++;
#line 5509
        *tmp___0 = (XML_Char )61;
#line 5509
        tmp___1 = 1;
      } else {
#line 5509
        tmp___1 = 0;
      }
    } else {
#line 5509
      tmp___0 = parser->m_tempPool.ptr;
#line 5509
      (parser->m_tempPool.ptr) ++;
#line 5509
      *tmp___0 = (XML_Char )61;
#line 5509
      tmp___1 = 1;
    }
#line 5509
    if (! tmp___1) {
#line 5510
      return ((XML_Char const   *)((void *)0));
    }
#line 5511
    len = (dtd->defaultPrefix.binding)->uriLen;
#line 5512
    if (parser->m_namespaceSeparator) {
#line 5513
      len --;
    }
#line 5514
    i = 0;
#line 5514
    while (i < len) {
#line 5515
      if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
#line 5515
        tmp___6 = poolGrow(& parser->m_tempPool);
#line 5515
        if (tmp___6) {
#line 5515
          tmp___4 = parser->m_tempPool.ptr;
#line 5515
          (parser->m_tempPool.ptr) ++;
#line 5515
          *tmp___4 = *((dtd->defaultPrefix.binding)->uri + i);
#line 5515
          tmp___5 = 1;
        } else {
#line 5515
          tmp___5 = 0;
        }
      } else {
#line 5515
        tmp___4 = parser->m_tempPool.ptr;
#line 5515
        (parser->m_tempPool.ptr) ++;
#line 5515
        *tmp___4 = *((dtd->defaultPrefix.binding)->uri + i);
#line 5515
        tmp___5 = 1;
      }
#line 5515
      if (! tmp___5) {
#line 5516
        return ((XML_Char const   *)((void *)0));
      }
#line 5514
      i ++;
    }
#line 5517
    needSep = (XML_Bool )1;
  }
#line 5520
  hashTableIterInit(& iter, (HASH_TABLE const   *)(& dtd->prefixes));
#line 5521
  while (1) {
#line 5525
    tmp___7 = hashTableIterNext(& iter);
#line 5525
    prefix = (PREFIX *)tmp___7;
#line 5526
    if (! prefix) {
#line 5527
      break;
    }
#line 5528
    if (! prefix->binding) {
#line 5529
      goto __Cont;
    }
#line 5530
    if (needSep) {
#line 5530
      if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
#line 5530
        tmp___11 = poolGrow(& parser->m_tempPool);
#line 5530
        if (tmp___11) {
#line 5530
          tmp___9 = parser->m_tempPool.ptr;
#line 5530
          (parser->m_tempPool.ptr) ++;
#line 5530
          *tmp___9 = (XML_Char )12;
#line 5530
          tmp___10 = 1;
        } else {
#line 5530
          tmp___10 = 0;
        }
      } else {
#line 5530
        tmp___9 = parser->m_tempPool.ptr;
#line 5530
        (parser->m_tempPool.ptr) ++;
#line 5530
        *tmp___9 = (XML_Char )12;
#line 5530
        tmp___10 = 1;
      }
#line 5530
      if (! tmp___10) {
#line 5531
        return ((XML_Char const   *)((void *)0));
      }
    }
#line 5532
    s = prefix->name;
#line 5532
    while (*s) {
#line 5533
      if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
#line 5533
        tmp___15 = poolGrow(& parser->m_tempPool);
#line 5533
        if (tmp___15) {
#line 5533
          tmp___13 = parser->m_tempPool.ptr;
#line 5533
          (parser->m_tempPool.ptr) ++;
#line 5533
          *tmp___13 = (XML_Char )*s;
#line 5533
          tmp___14 = 1;
        } else {
#line 5533
          tmp___14 = 0;
        }
      } else {
#line 5533
        tmp___13 = parser->m_tempPool.ptr;
#line 5533
        (parser->m_tempPool.ptr) ++;
#line 5533
        *tmp___13 = (XML_Char )*s;
#line 5533
        tmp___14 = 1;
      }
#line 5533
      if (! tmp___14) {
#line 5534
        return ((XML_Char const   *)((void *)0));
      }
#line 5532
      s ++;
    }
#line 5535
    if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
#line 5535
      tmp___19 = poolGrow(& parser->m_tempPool);
#line 5535
      if (tmp___19) {
#line 5535
        tmp___17 = parser->m_tempPool.ptr;
#line 5535
        (parser->m_tempPool.ptr) ++;
#line 5535
        *tmp___17 = (XML_Char )61;
#line 5535
        tmp___18 = 1;
      } else {
#line 5535
        tmp___18 = 0;
      }
    } else {
#line 5535
      tmp___17 = parser->m_tempPool.ptr;
#line 5535
      (parser->m_tempPool.ptr) ++;
#line 5535
      *tmp___17 = (XML_Char )61;
#line 5535
      tmp___18 = 1;
    }
#line 5535
    if (! tmp___18) {
#line 5536
      return ((XML_Char const   *)((void *)0));
    }
#line 5537
    len___0 = (prefix->binding)->uriLen;
#line 5538
    if (parser->m_namespaceSeparator) {
#line 5539
      len___0 --;
    }
#line 5540
    i___0 = 0;
#line 5540
    while (i___0 < len___0) {
#line 5541
      if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
#line 5541
        tmp___23 = poolGrow(& parser->m_tempPool);
#line 5541
        if (tmp___23) {
#line 5541
          tmp___21 = parser->m_tempPool.ptr;
#line 5541
          (parser->m_tempPool.ptr) ++;
#line 5541
          *tmp___21 = *((prefix->binding)->uri + i___0);
#line 5541
          tmp___22 = 1;
        } else {
#line 5541
          tmp___22 = 0;
        }
      } else {
#line 5541
        tmp___21 = parser->m_tempPool.ptr;
#line 5541
        (parser->m_tempPool.ptr) ++;
#line 5541
        *tmp___21 = *((prefix->binding)->uri + i___0);
#line 5541
        tmp___22 = 1;
      }
#line 5541
      if (! tmp___22) {
#line 5542
        return ((XML_Char const   *)((void *)0));
      }
#line 5540
      i___0 ++;
    }
#line 5543
    needSep = (XML_Bool )1;
    __Cont: /* CIL Label */ ;
  }
#line 5547
  hashTableIterInit(& iter, (HASH_TABLE const   *)(& dtd->generalEntities));
#line 5548
  while (1) {
#line 5550
    tmp___24 = hashTableIterNext(& iter);
#line 5550
    e = (ENTITY *)tmp___24;
#line 5551
    if (! e) {
#line 5552
      break;
    }
#line 5553
    if (! e->open) {
#line 5554
      goto __Cont___0;
    }
#line 5555
    if (needSep) {
#line 5555
      if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
#line 5555
        tmp___28 = poolGrow(& parser->m_tempPool);
#line 5555
        if (tmp___28) {
#line 5555
          tmp___26 = parser->m_tempPool.ptr;
#line 5555
          (parser->m_tempPool.ptr) ++;
#line 5555
          *tmp___26 = (XML_Char )12;
#line 5555
          tmp___27 = 1;
        } else {
#line 5555
          tmp___27 = 0;
        }
      } else {
#line 5555
        tmp___26 = parser->m_tempPool.ptr;
#line 5555
        (parser->m_tempPool.ptr) ++;
#line 5555
        *tmp___26 = (XML_Char )12;
#line 5555
        tmp___27 = 1;
      }
#line 5555
      if (! tmp___27) {
#line 5556
        return ((XML_Char const   *)((void *)0));
      }
    }
#line 5557
    s___0 = e->name;
#line 5557
    while (*s___0) {
#line 5558
      if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
#line 5558
        tmp___32 = poolGrow(& parser->m_tempPool);
#line 5558
        if (tmp___32) {
#line 5558
          tmp___30 = parser->m_tempPool.ptr;
#line 5558
          (parser->m_tempPool.ptr) ++;
#line 5558
          *tmp___30 = (XML_Char )*s___0;
#line 5558
          tmp___31 = 1;
        } else {
#line 5558
          tmp___31 = 0;
        }
      } else {
#line 5558
        tmp___30 = parser->m_tempPool.ptr;
#line 5558
        (parser->m_tempPool.ptr) ++;
#line 5558
        *tmp___30 = (XML_Char )*s___0;
#line 5558
        tmp___31 = 1;
      }
#line 5558
      if (! tmp___31) {
#line 5559
        return ((XML_Char const   *)0);
      }
#line 5557
      s___0 ++;
    }
#line 5560
    needSep = (XML_Bool )1;
    __Cont___0: /* CIL Label */ ;
  }
#line 5563
  if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
#line 5563
    tmp___36 = poolGrow(& parser->m_tempPool);
#line 5563
    if (tmp___36) {
#line 5563
      tmp___34 = parser->m_tempPool.ptr;
#line 5563
      (parser->m_tempPool.ptr) ++;
#line 5563
      *tmp___34 = (XML_Char )'\000';
#line 5563
      tmp___35 = 1;
    } else {
#line 5563
      tmp___35 = 0;
    }
  } else {
#line 5563
    tmp___34 = parser->m_tempPool.ptr;
#line 5563
    (parser->m_tempPool.ptr) ++;
#line 5563
    *tmp___34 = (XML_Char )'\000';
#line 5563
    tmp___35 = 1;
  }
#line 5563
  if (! tmp___35) {
#line 5564
    return ((XML_Char const   *)((void *)0));
  }
#line 5565
  return ((XML_Char const   *)parser->m_tempPool.start);
}
}
#line 5568 "xmlparse.c"
static XML_Bool setContext(XML_Parser parser , XML_Char const   *context ) 
{ 
  DTD *dtd ;
  XML_Char const   *s ;
  ENTITY *e ;
  XML_Char *tmp___0 ;
  int tmp___1 ;
  XML_Bool tmp___2 ;
  NAMED *tmp___3 ;
  PREFIX *prefix ;
  XML_Char *tmp___5 ;
  int tmp___6 ;
  XML_Bool tmp___7 ;
  NAMED *tmp___8 ;
  XML_Char *tmp___10 ;
  int tmp___11 ;
  XML_Bool tmp___12 ;
  XML_Char *tmp___14 ;
  int tmp___15 ;
  XML_Bool tmp___16 ;
  enum XML_Error tmp___17 ;
  XML_Char *tmp___19 ;
  int tmp___20 ;
  XML_Bool tmp___21 ;

  {
#line 5571
  dtd = parser->m_dtd;
#line 5572
  s = context;
#line 5574
  while ((int const   )*context != 0) {
#line 5575
    if ((int const   )*s == 12) {
#line 5575
      goto _L;
    } else
#line 5575
    if ((int const   )*s == 0) {
      _L: /* CIL Label */ 
#line 5577
      if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
#line 5577
        tmp___2 = poolGrow(& parser->m_tempPool);
#line 5577
        if (tmp___2) {
#line 5577
          tmp___0 = parser->m_tempPool.ptr;
#line 5577
          (parser->m_tempPool.ptr) ++;
#line 5577
          *tmp___0 = (XML_Char )'\000';
#line 5577
          tmp___1 = 1;
        } else {
#line 5577
          tmp___1 = 0;
        }
      } else {
#line 5577
        tmp___0 = parser->m_tempPool.ptr;
#line 5577
        (parser->m_tempPool.ptr) ++;
#line 5577
        *tmp___0 = (XML_Char )'\000';
#line 5577
        tmp___1 = 1;
      }
#line 5577
      if (! tmp___1) {
#line 5578
        return ((XML_Bool )0);
      }
#line 5579
      tmp___3 = lookup(parser, & dtd->generalEntities, (KEY )parser->m_tempPool.start,
                       (size_t )0);
#line 5579
      e = (ENTITY *)tmp___3;
#line 5580
      if (e) {
#line 5581
        e->open = (XML_Bool )1;
      }
#line 5582
      if ((int const   )*s != 0) {
#line 5583
        s ++;
      }
#line 5584
      context = s;
#line 5585
      parser->m_tempPool.ptr = parser->m_tempPool.start;
    } else
#line 5587
    if ((int const   )*s == 61) {
#line 5589
      if (parser->m_tempPool.ptr - parser->m_tempPool.start == 0L) {
#line 5590
        prefix = & dtd->defaultPrefix;
      } else {
#line 5592
        if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
#line 5592
          tmp___7 = poolGrow(& parser->m_tempPool);
#line 5592
          if (tmp___7) {
#line 5592
            tmp___5 = parser->m_tempPool.ptr;
#line 5592
            (parser->m_tempPool.ptr) ++;
#line 5592
            *tmp___5 = (XML_Char )'\000';
#line 5592
            tmp___6 = 1;
          } else {
#line 5592
            tmp___6 = 0;
          }
        } else {
#line 5592
          tmp___5 = parser->m_tempPool.ptr;
#line 5592
          (parser->m_tempPool.ptr) ++;
#line 5592
          *tmp___5 = (XML_Char )'\000';
#line 5592
          tmp___6 = 1;
        }
#line 5592
        if (! tmp___6) {
#line 5593
          return ((XML_Bool )0);
        }
#line 5594
        tmp___8 = lookup(parser, & dtd->prefixes, (KEY )parser->m_tempPool.start,
                         sizeof(PREFIX ));
#line 5594
        prefix = (PREFIX *)tmp___8;
#line 5596
        if (! prefix) {
#line 5597
          return ((XML_Bool )0);
        }
#line 5598
        if ((unsigned long )prefix->name == (unsigned long )parser->m_tempPool.start) {
#line 5599
          prefix->name = poolCopyString(& dtd->pool, prefix->name);
#line 5600
          if (! prefix->name) {
#line 5601
            return ((XML_Bool )0);
          }
        }
#line 5603
        parser->m_tempPool.ptr = parser->m_tempPool.start;
      }
#line 5605
      context = s + 1;
#line 5605
      while (1) {
#line 5605
        if ((int const   )*context != 12) {
#line 5605
          if (! ((int const   )*context != 0)) {
#line 5605
            break;
          }
        } else {
#line 5605
          break;
        }
#line 5608
        if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
#line 5608
          tmp___12 = poolGrow(& parser->m_tempPool);
#line 5608
          if (tmp___12) {
#line 5608
            tmp___10 = parser->m_tempPool.ptr;
#line 5608
            (parser->m_tempPool.ptr) ++;
#line 5608
            *tmp___10 = (XML_Char )*context;
#line 5608
            tmp___11 = 1;
          } else {
#line 5608
            tmp___11 = 0;
          }
        } else {
#line 5608
          tmp___10 = parser->m_tempPool.ptr;
#line 5608
          (parser->m_tempPool.ptr) ++;
#line 5608
          *tmp___10 = (XML_Char )*context;
#line 5608
          tmp___11 = 1;
        }
#line 5608
        if (! tmp___11) {
#line 5609
          return ((XML_Bool )0);
        }
#line 5605
        context ++;
      }
#line 5610
      if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
#line 5610
        tmp___16 = poolGrow(& parser->m_tempPool);
#line 5610
        if (tmp___16) {
#line 5610
          tmp___14 = parser->m_tempPool.ptr;
#line 5610
          (parser->m_tempPool.ptr) ++;
#line 5610
          *tmp___14 = (XML_Char )'\000';
#line 5610
          tmp___15 = 1;
        } else {
#line 5610
          tmp___15 = 0;
        }
      } else {
#line 5610
        tmp___14 = parser->m_tempPool.ptr;
#line 5610
        (parser->m_tempPool.ptr) ++;
#line 5610
        *tmp___14 = (XML_Char )'\000';
#line 5610
        tmp___15 = 1;
      }
#line 5610
      if (! tmp___15) {
#line 5611
        return ((XML_Bool )0);
      }
#line 5612
      tmp___17 = addBinding(parser, prefix, (ATTRIBUTE_ID const   *)((void *)0), (XML_Char const   *)parser->m_tempPool.start,
                            & parser->m_inheritedBindings);
#line 5612
      if ((unsigned int )tmp___17 != 0U) {
#line 5614
        return ((XML_Bool )0);
      }
#line 5615
      parser->m_tempPool.ptr = parser->m_tempPool.start;
#line 5616
      if ((int const   )*context != 0) {
#line 5617
        context ++;
      }
#line 5618
      s = context;
    } else {
#line 5621
      if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
#line 5621
        tmp___21 = poolGrow(& parser->m_tempPool);
#line 5621
        if (tmp___21) {
#line 5621
          tmp___19 = parser->m_tempPool.ptr;
#line 5621
          (parser->m_tempPool.ptr) ++;
#line 5621
          *tmp___19 = (XML_Char )*s;
#line 5621
          tmp___20 = 1;
        } else {
#line 5621
          tmp___20 = 0;
        }
      } else {
#line 5621
        tmp___19 = parser->m_tempPool.ptr;
#line 5621
        (parser->m_tempPool.ptr) ++;
#line 5621
        *tmp___19 = (XML_Char )*s;
#line 5621
        tmp___20 = 1;
      }
#line 5621
      if (! tmp___20) {
#line 5622
        return ((XML_Bool )0);
      }
#line 5623
      s ++;
    }
  }
#line 5626
  return ((XML_Bool )1);
}
}
#line 5629 "xmlparse.c"
static void normalizePublicId(XML_Char *publicId ) 
{ 
  XML_Char *p ;
  XML_Char *s ;
  XML_Char *tmp ;
  XML_Char *tmp___0 ;

  {
#line 5632
  p = publicId;
#line 5634
  s = publicId;
#line 5634
  while (*s) {
#line 5635
    switch ((int )*s) {
    case 10: 
    case 13: 
    case 32: 
#line 5639
    if ((unsigned long )p != (unsigned long )publicId) {
#line 5639
      if ((int )*(p + -1) != 32) {
#line 5640
        tmp = p;
#line 5640
        p ++;
#line 5640
        *tmp = (XML_Char )32;
      }
    }
#line 5641
    break;
    default: 
#line 5643
    tmp___0 = p;
#line 5643
    p ++;
#line 5643
    *tmp___0 = *s;
    }
#line 5634
    s ++;
  }
#line 5646
  if ((unsigned long )p != (unsigned long )publicId) {
#line 5646
    if ((int )*(p + -1) == 32) {
#line 5647
      p --;
    }
  }
#line 5648
  *p = (XML_Char )'\000';
#line 5649
  return;
}
}
#line 5651 "xmlparse.c"
static DTD *dtdCreate(XML_Memory_Handling_Suite const   *ms ) 
{ 
  DTD *p ;
  void *tmp ;

  {
#line 5654
  tmp = (*(ms->malloc_fcn))(sizeof(DTD ));
#line 5654
  p = (DTD *)tmp;
#line 5655
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 5656
    return (p);
  }
#line 5657
  poolInit(& p->pool, ms);
#line 5658
  poolInit(& p->entityValuePool, ms);
#line 5659
  hashTableInit(& p->generalEntities, ms);
#line 5660
  hashTableInit(& p->elementTypes, ms);
#line 5661
  hashTableInit(& p->attributeIds, ms);
#line 5662
  hashTableInit(& p->prefixes, ms);
#line 5664
  p->paramEntityRead = (XML_Bool )0;
#line 5665
  hashTableInit(& p->paramEntities, ms);
#line 5667
  p->defaultPrefix.name = (XML_Char const   *)((void *)0);
#line 5668
  p->defaultPrefix.binding = (BINDING *)((void *)0);
#line 5670
  p->in_eldecl = (XML_Bool )0;
#line 5671
  p->scaffIndex = (int *)((void *)0);
#line 5672
  p->scaffold = (CONTENT_SCAFFOLD *)((void *)0);
#line 5673
  p->scaffLevel = 0;
#line 5674
  p->scaffSize = 0U;
#line 5675
  p->scaffCount = 0U;
#line 5676
  p->contentStringLen = 0U;
#line 5678
  p->keepProcessing = (XML_Bool )1;
#line 5679
  p->hasParamEntityRefs = (XML_Bool )0;
#line 5680
  p->standalone = (XML_Bool )0;
#line 5681
  return (p);
}
}
#line 5684 "xmlparse.c"
static void dtdReset(DTD *p , XML_Memory_Handling_Suite const   *ms ) 
{ 
  HASH_TABLE_ITER iter ;
  ELEMENT_TYPE *e ;
  NAMED *tmp ;

  {
#line 5688
  hashTableIterInit(& iter, (HASH_TABLE const   *)(& p->elementTypes));
#line 5689
  while (1) {
#line 5690
    tmp = hashTableIterNext(& iter);
#line 5690
    e = (ELEMENT_TYPE *)tmp;
#line 5691
    if (! e) {
#line 5692
      break;
    }
#line 5693
    if (e->allocDefaultAtts != 0) {
#line 5694
      (*(ms->free_fcn))((void *)e->defaultAtts);
    }
  }
#line 5696
  hashTableClear(& p->generalEntities);
#line 5698
  p->paramEntityRead = (XML_Bool )0;
#line 5699
  hashTableClear(& p->paramEntities);
#line 5701
  hashTableClear(& p->elementTypes);
#line 5702
  hashTableClear(& p->attributeIds);
#line 5703
  hashTableClear(& p->prefixes);
#line 5704
  poolClear(& p->pool);
#line 5705
  poolClear(& p->entityValuePool);
#line 5706
  p->defaultPrefix.name = (XML_Char const   *)((void *)0);
#line 5707
  p->defaultPrefix.binding = (BINDING *)((void *)0);
#line 5709
  p->in_eldecl = (XML_Bool )0;
#line 5711
  (*(ms->free_fcn))((void *)p->scaffIndex);
#line 5712
  p->scaffIndex = (int *)((void *)0);
#line 5713
  (*(ms->free_fcn))((void *)p->scaffold);
#line 5714
  p->scaffold = (CONTENT_SCAFFOLD *)((void *)0);
#line 5716
  p->scaffLevel = 0;
#line 5717
  p->scaffSize = 0U;
#line 5718
  p->scaffCount = 0U;
#line 5719
  p->contentStringLen = 0U;
#line 5721
  p->keepProcessing = (XML_Bool )1;
#line 5722
  p->hasParamEntityRefs = (XML_Bool )0;
#line 5723
  p->standalone = (XML_Bool )0;
#line 5724
  return;
}
}
#line 5726 "xmlparse.c"
static void dtdDestroy(DTD *p , XML_Bool isDocEntity , XML_Memory_Handling_Suite const   *ms ) 
{ 
  HASH_TABLE_ITER iter ;
  ELEMENT_TYPE *e ;
  NAMED *tmp ;

  {
#line 5730
  hashTableIterInit(& iter, (HASH_TABLE const   *)(& p->elementTypes));
#line 5731
  while (1) {
#line 5732
    tmp = hashTableIterNext(& iter);
#line 5732
    e = (ELEMENT_TYPE *)tmp;
#line 5733
    if (! e) {
#line 5734
      break;
    }
#line 5735
    if (e->allocDefaultAtts != 0) {
#line 5736
      (*(ms->free_fcn))((void *)e->defaultAtts);
    }
  }
#line 5738
  hashTableDestroy(& p->generalEntities);
#line 5740
  hashTableDestroy(& p->paramEntities);
#line 5742
  hashTableDestroy(& p->elementTypes);
#line 5743
  hashTableDestroy(& p->attributeIds);
#line 5744
  hashTableDestroy(& p->prefixes);
#line 5745
  poolDestroy(& p->pool);
#line 5746
  poolDestroy(& p->entityValuePool);
#line 5747
  if (isDocEntity) {
#line 5748
    (*(ms->free_fcn))((void *)p->scaffIndex);
#line 5749
    (*(ms->free_fcn))((void *)p->scaffold);
  }
#line 5751
  (*(ms->free_fcn))((void *)p);
#line 5752
  return;
}
}
#line 5757 "xmlparse.c"
static int dtdCopy(XML_Parser oldParser , DTD *newDtd , DTD const   *oldDtd , XML_Memory_Handling_Suite const   *ms ) 
{ 
  HASH_TABLE_ITER iter ;
  XML_Char const   *name ;
  PREFIX const   *oldP ;
  NAMED *tmp ;
  NAMED *tmp___0 ;
  ATTRIBUTE_ID *newA ;
  XML_Char const   *name___0 ;
  ATTRIBUTE_ID const   *oldA ;
  NAMED *tmp___1 ;
  XML_Char *tmp___3 ;
  int tmp___4 ;
  XML_Bool tmp___5 ;
  NAMED *tmp___6 ;
  NAMED *tmp___7 ;
  int i ;
  ELEMENT_TYPE *newE ;
  XML_Char const   *name___1 ;
  ELEMENT_TYPE const   *oldE ;
  NAMED *tmp___8 ;
  NAMED *tmp___9 ;
  void *tmp___10 ;
  NAMED *tmp___11 ;
  int tmp___12 ;
  NAMED *tmp___13 ;
  NAMED *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 5764
  hashTableIterInit(& iter, & oldDtd->prefixes);
#line 5765
  while (1) {
#line 5767
    tmp = hashTableIterNext(& iter);
#line 5767
    oldP = (PREFIX const   *)((PREFIX *)tmp);
#line 5768
    if (! oldP) {
#line 5769
      break;
    }
#line 5770
    name = poolCopyString(& newDtd->pool, (XML_Char const   *)oldP->name);
#line 5771
    if (! name) {
#line 5772
      return (0);
    }
#line 5773
    tmp___0 = lookup(oldParser, & newDtd->prefixes, name, sizeof(PREFIX ));
#line 5773
    if (! tmp___0) {
#line 5774
      return (0);
    }
  }
#line 5777
  hashTableIterInit(& iter, & oldDtd->attributeIds);
#line 5781
  while (1) {
#line 5784
    tmp___1 = hashTableIterNext(& iter);
#line 5784
    oldA = (ATTRIBUTE_ID const   *)((ATTRIBUTE_ID *)tmp___1);
#line 5786
    if (! oldA) {
#line 5787
      break;
    }
#line 5789
    if ((unsigned long )newDtd->pool.ptr == (unsigned long )newDtd->pool.end) {
#line 5789
      tmp___5 = poolGrow(& newDtd->pool);
#line 5789
      if (tmp___5) {
#line 5789
        tmp___3 = newDtd->pool.ptr;
#line 5789
        (newDtd->pool.ptr) ++;
#line 5789
        *tmp___3 = (XML_Char )'\000';
#line 5789
        tmp___4 = 1;
      } else {
#line 5789
        tmp___4 = 0;
      }
    } else {
#line 5789
      tmp___3 = newDtd->pool.ptr;
#line 5789
      (newDtd->pool.ptr) ++;
#line 5789
      *tmp___3 = (XML_Char )'\000';
#line 5789
      tmp___4 = 1;
    }
#line 5789
    if (! tmp___4) {
#line 5790
      return (0);
    }
#line 5791
    name___0 = poolCopyString(& newDtd->pool, (XML_Char const   *)oldA->name);
#line 5792
    if (! name___0) {
#line 5793
      return (0);
    }
#line 5794
    name___0 ++;
#line 5795
    tmp___6 = lookup(oldParser, & newDtd->attributeIds, name___0, sizeof(ATTRIBUTE_ID ));
#line 5795
    newA = (ATTRIBUTE_ID *)tmp___6;
#line 5797
    if (! newA) {
#line 5798
      return (0);
    }
#line 5799
    newA->maybeTokenized = (XML_Bool )oldA->maybeTokenized;
#line 5800
    if (oldA->prefix) {
#line 5801
      newA->xmlns = (XML_Bool )oldA->xmlns;
#line 5802
      if ((unsigned long )oldA->prefix == (unsigned long )(& oldDtd->defaultPrefix)) {
#line 5803
        newA->prefix = & newDtd->defaultPrefix;
      } else {
#line 5805
        tmp___7 = lookup(oldParser, & newDtd->prefixes, (oldA->prefix)->name, (size_t )0);
#line 5805
        newA->prefix = (PREFIX *)tmp___7;
      }
    }
  }
#line 5812
  hashTableIterInit(& iter, & oldDtd->elementTypes);
#line 5814
  while (1) {
#line 5818
    tmp___8 = hashTableIterNext(& iter);
#line 5818
    oldE = (ELEMENT_TYPE const   *)((ELEMENT_TYPE *)tmp___8);
#line 5819
    if (! oldE) {
#line 5820
      break;
    }
#line 5821
    name___1 = poolCopyString(& newDtd->pool, (XML_Char const   *)oldE->name);
#line 5822
    if (! name___1) {
#line 5823
      return (0);
    }
#line 5824
    tmp___9 = lookup(oldParser, & newDtd->elementTypes, name___1, sizeof(ELEMENT_TYPE ));
#line 5824
    newE = (ELEMENT_TYPE *)tmp___9;
#line 5826
    if (! newE) {
#line 5827
      return (0);
    }
#line 5828
    if (oldE->nDefaultAtts) {
#line 5829
      tmp___10 = (*(ms->malloc_fcn))((unsigned long )oldE->nDefaultAtts * sizeof(DEFAULT_ATTRIBUTE ));
#line 5829
      newE->defaultAtts = (DEFAULT_ATTRIBUTE *)tmp___10;
#line 5831
      if (! newE->defaultAtts) {
#line 5832
        (*(ms->free_fcn))((void *)newE);
#line 5833
        return (0);
      }
    }
#line 5836
    if (oldE->idAtt) {
#line 5837
      tmp___11 = lookup(oldParser, & newDtd->attributeIds, (KEY )(oldE->idAtt)->name,
                        (size_t )0);
#line 5837
      newE->idAtt = (ATTRIBUTE_ID const   *)((ATTRIBUTE_ID *)tmp___11);
    }
#line 5839
    tmp___12 = (int )oldE->nDefaultAtts;
#line 5839
    newE->nDefaultAtts = tmp___12;
#line 5839
    newE->allocDefaultAtts = tmp___12;
#line 5840
    if (oldE->prefix) {
#line 5841
      tmp___13 = lookup(oldParser, & newDtd->prefixes, (oldE->prefix)->name, (size_t )0);
#line 5841
      newE->prefix = (PREFIX *)tmp___13;
    }
#line 5843
    i = 0;
#line 5843
    while (i < newE->nDefaultAtts) {
#line 5844
      tmp___14 = lookup(oldParser, & newDtd->attributeIds, (KEY )((oldE->defaultAtts + i)->id)->name,
                        (size_t )0);
#line 5844
      (newE->defaultAtts + i)->id = (ATTRIBUTE_ID const   *)((ATTRIBUTE_ID *)tmp___14);
#line 5846
      (newE->defaultAtts + i)->isCdata = (oldE->defaultAtts + i)->isCdata;
#line 5847
      if ((oldE->defaultAtts + i)->value) {
#line 5848
        (newE->defaultAtts + i)->value = poolCopyString(& newDtd->pool, (oldE->defaultAtts + i)->value);
#line 5850
        if (! (newE->defaultAtts + i)->value) {
#line 5851
          return (0);
        }
      } else {
#line 5854
        (newE->defaultAtts + i)->value = (XML_Char const   *)((void *)0);
      }
#line 5843
      i ++;
    }
  }
#line 5859
  tmp___15 = copyEntityTable(oldParser, & newDtd->generalEntities, & newDtd->pool,
                             & oldDtd->generalEntities);
#line 5859
  if (! tmp___15) {
#line 5863
    return (0);
  }
#line 5866
  tmp___16 = copyEntityTable(oldParser, & newDtd->paramEntities, & newDtd->pool, & oldDtd->paramEntities);
#line 5866
  if (! tmp___16) {
#line 5870
    return (0);
  }
#line 5871
  newDtd->paramEntityRead = (XML_Bool )oldDtd->paramEntityRead;
#line 5874
  newDtd->keepProcessing = (XML_Bool )oldDtd->keepProcessing;
#line 5875
  newDtd->hasParamEntityRefs = (XML_Bool )oldDtd->hasParamEntityRefs;
#line 5876
  newDtd->standalone = (XML_Bool )oldDtd->standalone;
#line 5879
  newDtd->in_eldecl = (XML_Bool )oldDtd->in_eldecl;
#line 5880
  newDtd->scaffold = (CONTENT_SCAFFOLD *)oldDtd->scaffold;
#line 5881
  newDtd->contentStringLen = (unsigned int )oldDtd->contentStringLen;
#line 5882
  newDtd->scaffSize = (unsigned int )oldDtd->scaffSize;
#line 5883
  newDtd->scaffLevel = (int )oldDtd->scaffLevel;
#line 5884
  newDtd->scaffIndex = (int *)oldDtd->scaffIndex;
#line 5886
  return (1);
}
}
#line 5889 "xmlparse.c"
static int copyEntityTable(XML_Parser oldParser , HASH_TABLE *newTable , STRING_POOL *newPool ,
                           HASH_TABLE const   *oldTable ) 
{ 
  HASH_TABLE_ITER iter ;
  XML_Char const   *cachedOldBase ;
  XML_Char const   *cachedNewBase ;
  ENTITY *newE ;
  XML_Char const   *name ;
  ENTITY const   *oldE ;
  NAMED *tmp ;
  NAMED *tmp___0 ;
  XML_Char const   *tem ;
  XML_Char const   *tmp___1 ;
  XML_Char const   *tmp___2 ;
  XML_Char const   *tem___0 ;
  XML_Char const   *tmp___3 ;
  XML_Char const   *tem___1 ;
  XML_Char const   *tmp___4 ;

  {
#line 5896
  cachedOldBase = (XML_Char const   *)((void *)0);
#line 5897
  cachedNewBase = (XML_Char const   *)((void *)0);
#line 5899
  hashTableIterInit(& iter, oldTable);
#line 5901
  while (1) {
#line 5904
    tmp = hashTableIterNext(& iter);
#line 5904
    oldE = (ENTITY const   *)((ENTITY *)tmp);
#line 5905
    if (! oldE) {
#line 5906
      break;
    }
#line 5907
    name = poolCopyString(newPool, (XML_Char const   *)oldE->name);
#line 5908
    if (! name) {
#line 5909
      return (0);
    }
#line 5910
    tmp___0 = lookup(oldParser, newTable, name, sizeof(ENTITY ));
#line 5910
    newE = (ENTITY *)tmp___0;
#line 5911
    if (! newE) {
#line 5912
      return (0);
    }
#line 5913
    if (oldE->systemId) {
#line 5914
      tmp___1 = poolCopyString(newPool, (XML_Char const   *)oldE->systemId);
#line 5914
      tem = tmp___1;
#line 5915
      if (! tem) {
#line 5916
        return (0);
      }
#line 5917
      newE->systemId = tem;
#line 5918
      if (oldE->base) {
#line 5919
        if ((unsigned long )oldE->base == (unsigned long )cachedOldBase) {
#line 5920
          newE->base = cachedNewBase;
        } else {
#line 5922
          cachedOldBase = (XML_Char const   *)oldE->base;
#line 5923
          tem = poolCopyString(newPool, cachedOldBase);
#line 5924
          if (! tem) {
#line 5925
            return (0);
          }
#line 5926
          tmp___2 = tem;
#line 5926
          newE->base = tmp___2;
#line 5926
          cachedNewBase = tmp___2;
        }
      }
#line 5929
      if (oldE->publicId) {
#line 5930
        tem = poolCopyString(newPool, (XML_Char const   *)oldE->publicId);
#line 5931
        if (! tem) {
#line 5932
          return (0);
        }
#line 5933
        newE->publicId = tem;
      }
    } else {
#line 5937
      tmp___3 = poolCopyStringN(newPool, (XML_Char const   *)oldE->textPtr, (int )oldE->textLen);
#line 5937
      tem___0 = tmp___3;
#line 5939
      if (! tem___0) {
#line 5940
        return (0);
      }
#line 5941
      newE->textPtr = tem___0;
#line 5942
      newE->textLen = (int )oldE->textLen;
    }
#line 5944
    if (oldE->notation) {
#line 5945
      tmp___4 = poolCopyString(newPool, (XML_Char const   *)oldE->notation);
#line 5945
      tem___1 = tmp___4;
#line 5946
      if (! tem___1) {
#line 5947
        return (0);
      }
#line 5948
      newE->notation = tem___1;
    }
#line 5950
    newE->is_param = (XML_Bool )oldE->is_param;
#line 5951
    newE->is_internal = (XML_Bool )oldE->is_internal;
  }
#line 5953
  return (1);
}
}
#line 5958 "xmlparse.c"
static XML_Bool keyeq(KEY s1 , KEY s2 ) 
{ 


  {
#line 5961
  while ((int const   )*s1 == (int const   )*s2) {
#line 5962
    if ((int const   )*s1 == 0) {
#line 5963
      return ((XML_Bool )1);
    }
#line 5961
    s1 ++;
#line 5961
    s2 ++;
  }
#line 5964
  return ((XML_Bool )0);
}
}
#line 5967 "xmlparse.c"
static unsigned long hash(XML_Parser parser , KEY s ) 
{ 
  unsigned long h ;
  KEY tmp ;

  {
#line 5970
  h = parser->m_hash_secret_salt;
#line 5971
  while (*s) {
#line 5972
    tmp = s;
#line 5972
    s ++;
#line 5972
    h = h * 1000003UL ^ (unsigned long )((unsigned char )*tmp);
  }
#line 5973
  return (h);
}
}
#line 5976 "xmlparse.c"
static NAMED *lookup(XML_Parser parser , HASH_TABLE *table , KEY name , size_t createSize ) 
{ 
  size_t i ;
  size_t tsize ;
  void *tmp ;
  unsigned long tmp___0 ;
  unsigned long h ;
  unsigned long tmp___1 ;
  unsigned long mask ;
  unsigned char step ;
  XML_Bool tmp___2 ;
  unsigned char newPower ;
  size_t newSize ;
  unsigned long newMask ;
  size_t tsize___0 ;
  NAMED **newV ;
  void *tmp___3 ;
  unsigned long newHash ;
  unsigned long tmp___4 ;
  size_t j ;
  void *tmp___5 ;

  {
#line 5980
  if (table->size == 0UL) {
#line 5982
    if (! createSize) {
#line 5983
      return ((NAMED *)((void *)0));
    }
#line 5984
    table->power = (unsigned char)6;
#line 5986
    table->size = 1UL << 6;
#line 5987
    tsize = table->size * sizeof(NAMED *);
#line 5988
    tmp = (*((table->mem)->malloc_fcn))(tsize);
#line 5988
    table->v = (NAMED **)tmp;
#line 5989
    if (! table->v) {
#line 5990
      table->size = (size_t )0;
#line 5991
      return ((NAMED *)((void *)0));
    }
#line 5993
    memset((void *)table->v, 0, tsize);
#line 5994
    tmp___0 = hash(parser, name);
#line 5994
    i = tmp___0 & (table->size - 1UL);
  } else {
#line 5997
    tmp___1 = hash(parser, name);
#line 5997
    h = tmp___1;
#line 5998
    mask = table->size - 1UL;
#line 5999
    step = (unsigned char)0;
#line 6000
    i = h & mask;
#line 6001
    while (*(table->v + i)) {
#line 6002
      tmp___2 = keyeq(name, (*(table->v + i))->name);
#line 6002
      if (tmp___2) {
#line 6003
        return (*(table->v + i));
      }
#line 6004
      if (! step) {
#line 6005
        step = (unsigned char )((((h & ~ mask) >> ((int )table->power - 1)) & (mask >> 2)) | 1UL);
      }
#line 6006
      if (i < (size_t )step) {
#line 6006
        i += table->size - (size_t )step;
      } else {
#line 6006
        i -= (size_t )step;
      }
    }
#line 6008
    if (! createSize) {
#line 6009
      return ((NAMED *)((void *)0));
    }
#line 6012
    if (table->used >> ((int )table->power - 1)) {
#line 6013
      newPower = (unsigned char )((int )table->power + 1);
#line 6014
      newSize = 1UL << (int )newPower;
#line 6015
      newMask = newSize - 1UL;
#line 6016
      tsize___0 = newSize * sizeof(NAMED *);
#line 6017
      tmp___3 = (*((table->mem)->malloc_fcn))(tsize___0);
#line 6017
      newV = (NAMED **)tmp___3;
#line 6018
      if (! newV) {
#line 6019
        return ((NAMED *)((void *)0));
      }
#line 6020
      memset((void *)newV, 0, tsize___0);
#line 6021
      i = (size_t )0;
#line 6021
      while (i < table->size) {
#line 6022
        if (*(table->v + i)) {
#line 6023
          tmp___4 = hash(parser, (*(table->v + i))->name);
#line 6023
          newHash = tmp___4;
#line 6024
          j = newHash & newMask;
#line 6025
          step = (unsigned char)0;
#line 6026
          while (*(newV + j)) {
#line 6027
            if (! step) {
#line 6028
              step = (unsigned char )((((newHash & ~ newMask) >> ((int )newPower - 1)) & (newMask >> 2)) | 1UL);
            }
#line 6029
            if (j < (size_t )step) {
#line 6029
              j += newSize - (size_t )step;
            } else {
#line 6029
              j -= (size_t )step;
            }
          }
#line 6031
          *(newV + j) = *(table->v + i);
        }
#line 6021
        i ++;
      }
#line 6033
      (*((table->mem)->free_fcn))((void *)table->v);
#line 6034
      table->v = newV;
#line 6035
      table->power = newPower;
#line 6036
      table->size = newSize;
#line 6037
      i = h & newMask;
#line 6038
      step = (unsigned char)0;
#line 6039
      while (*(table->v + i)) {
#line 6040
        if (! step) {
#line 6041
          step = (unsigned char )((((h & ~ newMask) >> ((int )newPower - 1)) & (newMask >> 2)) | 1UL);
        }
#line 6042
        if (i < (size_t )step) {
#line 6042
          i += newSize - (size_t )step;
        } else {
#line 6042
          i -= (size_t )step;
        }
      }
    }
  }
#line 6046
  tmp___5 = (*((table->mem)->malloc_fcn))(createSize);
#line 6046
  *(table->v + i) = (NAMED *)tmp___5;
#line 6047
  if (! *(table->v + i)) {
#line 6048
    return ((NAMED *)((void *)0));
  }
#line 6049
  memset((void *)*(table->v + i), 0, createSize);
#line 6050
  (*(table->v + i))->name = name;
#line 6051
  (table->used) ++;
#line 6052
  return (*(table->v + i));
}
}
#line 6055 "xmlparse.c"
static void hashTableClear(HASH_TABLE *table ) 
{ 
  size_t i ;

  {
#line 6059
  i = (size_t )0;
#line 6059
  while (i < table->size) {
#line 6060
    (*((table->mem)->free_fcn))((void *)*(table->v + i));
#line 6061
    *(table->v + i) = (NAMED *)((void *)0);
#line 6059
    i ++;
  }
#line 6063
  table->used = (size_t )0;
#line 6064
  return;
}
}
#line 6066 "xmlparse.c"
static void hashTableDestroy(HASH_TABLE *table ) 
{ 
  size_t i ;

  {
#line 6070
  i = (size_t )0;
#line 6070
  while (i < table->size) {
#line 6071
    (*((table->mem)->free_fcn))((void *)*(table->v + i));
#line 6070
    i ++;
  }
#line 6072
  (*((table->mem)->free_fcn))((void *)table->v);
#line 6073
  return;
}
}
#line 6075 "xmlparse.c"
static void hashTableInit(HASH_TABLE *p , XML_Memory_Handling_Suite const   *ms ) 
{ 


  {
#line 6078
  p->power = (unsigned char)0;
#line 6079
  p->size = (size_t )0;
#line 6080
  p->used = (size_t )0;
#line 6081
  p->v = (NAMED **)((void *)0);
#line 6082
  p->mem = ms;
#line 6083
  return;
}
}
#line 6085 "xmlparse.c"
static void hashTableIterInit(HASH_TABLE_ITER *iter , HASH_TABLE const   *table ) 
{ 


  {
#line 6088
  iter->p = (NAMED **)table->v;
#line 6089
  iter->end = iter->p + table->size;
#line 6090
  return;
}
}
#line 6092 "xmlparse.c"
static NAMED *hashTableIterNext(HASH_TABLE_ITER *iter ) 
{ 
  NAMED *tem ;
  NAMED **tmp ;

  {
#line 6095
  while ((unsigned long )iter->p != (unsigned long )iter->end) {
#line 6096
    tmp = iter->p;
#line 6096
    (iter->p) ++;
#line 6096
    tem = *tmp;
#line 6097
    if (tem) {
#line 6098
      return (tem);
    }
  }
#line 6100
  return ((NAMED *)((void *)0));
}
}
#line 6103 "xmlparse.c"
static void poolInit(STRING_POOL *pool , XML_Memory_Handling_Suite const   *ms ) 
{ 


  {
#line 6106
  pool->blocks = (BLOCK *)((void *)0);
#line 6107
  pool->freeBlocks = (BLOCK *)((void *)0);
#line 6108
  pool->start = (XML_Char *)((void *)0);
#line 6109
  pool->ptr = (XML_Char *)((void *)0);
#line 6110
  pool->end = (XML_Char const   *)((void *)0);
#line 6111
  pool->mem = ms;
#line 6112
  return;
}
}
#line 6114 "xmlparse.c"
static void poolClear(STRING_POOL *pool ) 
{ 
  BLOCK *p ;
  BLOCK *tem ;

  {
#line 6117
  if (! pool->freeBlocks) {
#line 6118
    pool->freeBlocks = pool->blocks;
  } else {
#line 6120
    p = pool->blocks;
#line 6121
    while (p) {
#line 6122
      tem = p->next;
#line 6123
      p->next = pool->freeBlocks;
#line 6124
      pool->freeBlocks = p;
#line 6125
      p = tem;
    }
  }
#line 6128
  pool->blocks = (BLOCK *)((void *)0);
#line 6129
  pool->start = (XML_Char *)((void *)0);
#line 6130
  pool->ptr = (XML_Char *)((void *)0);
#line 6131
  pool->end = (XML_Char const   *)((void *)0);
#line 6132
  return;
}
}
#line 6134 "xmlparse.c"
static void poolDestroy(STRING_POOL *pool ) 
{ 
  BLOCK *p ;
  BLOCK *tem ;
  BLOCK *tem___0 ;

  {
#line 6137
  p = pool->blocks;
#line 6138
  while (p) {
#line 6139
    tem = p->next;
#line 6140
    (*((pool->mem)->free_fcn))((void *)p);
#line 6141
    p = tem;
  }
#line 6143
  p = pool->freeBlocks;
#line 6144
  while (p) {
#line 6145
    tem___0 = p->next;
#line 6146
    (*((pool->mem)->free_fcn))((void *)p);
#line 6147
    p = tem___0;
  }
#line 6149
  return;
}
}
#line 6151 "xmlparse.c"
static XML_Char *poolAppend(STRING_POOL *pool , ENCODING const   *enc , char const   *ptr ,
                            char const   *end ) 
{ 
  XML_Bool tmp ;
  XML_Bool tmp___0 ;

  {
#line 6155
  if (! pool->ptr) {
#line 6155
    tmp = poolGrow(pool);
#line 6155
    if (! tmp) {
#line 6156
      return ((XML_Char *)((void *)0));
    }
  }
#line 6157
  while (1) {
#line 6158
    (*(enc->utf8Convert))(enc, & ptr, end, & pool->ptr, (char const   *)((ICHAR *)pool->end));
#line 6159
    if ((unsigned long )ptr == (unsigned long )end) {
#line 6160
      break;
    }
#line 6161
    tmp___0 = poolGrow(pool);
#line 6161
    if (! tmp___0) {
#line 6162
      return ((XML_Char *)((void *)0));
    }
  }
#line 6164
  return (pool->start);
}
}
#line 6167 "xmlparse.c"
static XML_Char const   *poolCopyString(STRING_POOL *pool , XML_Char const   *s ) 
{ 
  XML_Char *tmp___0 ;
  int tmp___1 ;
  XML_Bool tmp___2 ;
  XML_Char const   *tmp___3 ;

  {
#line 6170
  while (1) {
#line 6171
    if ((unsigned long )pool->ptr == (unsigned long )pool->end) {
#line 6171
      tmp___2 = poolGrow(pool);
#line 6171
      if (tmp___2) {
#line 6171
        tmp___0 = pool->ptr;
#line 6171
        (pool->ptr) ++;
#line 6171
        *tmp___0 = (XML_Char )*s;
#line 6171
        tmp___1 = 1;
      } else {
#line 6171
        tmp___1 = 0;
      }
    } else {
#line 6171
      tmp___0 = pool->ptr;
#line 6171
      (pool->ptr) ++;
#line 6171
      *tmp___0 = (XML_Char )*s;
#line 6171
      tmp___1 = 1;
    }
#line 6171
    if (! tmp___1) {
#line 6172
      return ((XML_Char const   *)((void *)0));
    }
#line 6170
    tmp___3 = s;
#line 6170
    s ++;
#line 6170
    if (! *tmp___3) {
#line 6170
      break;
    }
  }
#line 6174
  s = (XML_Char const   *)pool->start;
#line 6175
  pool->start = pool->ptr;
#line 6176
  return (s);
}
}
#line 6179 "xmlparse.c"
static XML_Char const   *poolCopyStringN(STRING_POOL *pool , XML_Char const   *s ,
                                         int n ) 
{ 
  XML_Bool tmp ;
  XML_Char *tmp___1 ;
  int tmp___2 ;
  XML_Bool tmp___3 ;

  {
#line 6182
  if (! pool->ptr) {
#line 6182
    tmp = poolGrow(pool);
#line 6182
    if (! tmp) {
#line 6183
      return ((XML_Char const   *)((void *)0));
    }
  }
#line 6184
  while (n > 0) {
#line 6185
    if ((unsigned long )pool->ptr == (unsigned long )pool->end) {
#line 6185
      tmp___3 = poolGrow(pool);
#line 6185
      if (tmp___3) {
#line 6185
        tmp___1 = pool->ptr;
#line 6185
        (pool->ptr) ++;
#line 6185
        *tmp___1 = (XML_Char )*s;
#line 6185
        tmp___2 = 1;
      } else {
#line 6185
        tmp___2 = 0;
      }
    } else {
#line 6185
      tmp___1 = pool->ptr;
#line 6185
      (pool->ptr) ++;
#line 6185
      *tmp___1 = (XML_Char )*s;
#line 6185
      tmp___2 = 1;
    }
#line 6185
    if (! tmp___2) {
#line 6186
      return ((XML_Char const   *)((void *)0));
    }
#line 6184
    n --;
#line 6184
    s ++;
  }
#line 6188
  s = (XML_Char const   *)pool->start;
#line 6189
  pool->start = pool->ptr;
#line 6190
  return (s);
}
}
#line 6193 "xmlparse.c"
static XML_Char const   *poolAppendString(STRING_POOL *pool , XML_Char const   *s ) 
{ 
  XML_Char *tmp___0 ;
  int tmp___1 ;
  XML_Bool tmp___2 ;

  {
#line 6196
  while (*s) {
#line 6197
    if ((unsigned long )pool->ptr == (unsigned long )pool->end) {
#line 6197
      tmp___2 = poolGrow(pool);
#line 6197
      if (tmp___2) {
#line 6197
        tmp___0 = pool->ptr;
#line 6197
        (pool->ptr) ++;
#line 6197
        *tmp___0 = (XML_Char )*s;
#line 6197
        tmp___1 = 1;
      } else {
#line 6197
        tmp___1 = 0;
      }
    } else {
#line 6197
      tmp___0 = pool->ptr;
#line 6197
      (pool->ptr) ++;
#line 6197
      *tmp___0 = (XML_Char )*s;
#line 6197
      tmp___1 = 1;
    }
#line 6197
    if (! tmp___1) {
#line 6198
      return ((XML_Char const   *)((void *)0));
    }
#line 6199
    s ++;
  }
#line 6201
  return ((XML_Char const   *)pool->start);
}
}
#line 6204 "xmlparse.c"
static XML_Char *poolStoreString(STRING_POOL *pool , ENCODING const   *enc , char const   *ptr ,
                                 char const   *end ) 
{ 
  XML_Char *tmp ;
  XML_Bool tmp___0 ;
  XML_Char *tmp___1 ;

  {
#line 6208
  tmp = poolAppend(pool, enc, ptr, end);
#line 6208
  if (! tmp) {
#line 6209
    return ((XML_Char *)((void *)0));
  }
#line 6210
  if ((unsigned long )pool->ptr == (unsigned long )pool->end) {
#line 6210
    tmp___0 = poolGrow(pool);
#line 6210
    if (! tmp___0) {
#line 6211
      return ((XML_Char *)((void *)0));
    }
  }
#line 6212
  tmp___1 = pool->ptr;
#line 6212
  (pool->ptr) ++;
#line 6212
  *tmp___1 = (XML_Char )0;
#line 6213
  return (pool->start);
}
}
#line 6216 "xmlparse.c"
static XML_Bool poolGrow(STRING_POOL *pool ) 
{ 
  BLOCK *tem ;
  int blockSize ;
  BLOCK *temp ;
  void *tmp ;
  BLOCK *tem___0 ;
  int blockSize___0 ;
  void *tmp___0 ;

  {
#line 6219
  if (pool->freeBlocks) {
#line 6220
    if ((unsigned long )pool->start == (unsigned long )((XML_Char *)0)) {
#line 6221
      pool->blocks = pool->freeBlocks;
#line 6222
      pool->freeBlocks = (pool->freeBlocks)->next;
#line 6223
      (pool->blocks)->next = (struct block *)((void *)0);
#line 6224
      pool->start = (pool->blocks)->s;
#line 6225
      pool->end = (XML_Char const   *)(pool->start + (pool->blocks)->size);
#line 6226
      pool->ptr = pool->start;
#line 6227
      return ((XML_Bool )1);
    }
#line 6229
    if (pool->end - (XML_Char const   *)pool->start < (long )(pool->freeBlocks)->size) {
#line 6230
      tem = (pool->freeBlocks)->next;
#line 6231
      (pool->freeBlocks)->next = pool->blocks;
#line 6232
      pool->blocks = pool->freeBlocks;
#line 6233
      pool->freeBlocks = tem;
#line 6234
      sym_memcpy((pool->blocks)->s, pool->start, (unsigned long )(pool->end - (XML_Char const   *)pool->start) * sizeof(XML_Char ));
#line 6236
      pool->ptr = (pool->blocks)->s + (pool->ptr - pool->start);
#line 6237
      pool->start = (pool->blocks)->s;
#line 6238
      pool->end = (XML_Char const   *)(pool->start + (pool->blocks)->size);
#line 6239
      return ((XML_Bool )1);
    }
  }
#line 6242
  if (pool->blocks) {
#line 6242
    if ((unsigned long )pool->start == (unsigned long )((pool->blocks)->s)) {
#line 6243
      blockSize = (int )(pool->end - (XML_Char const   *)pool->start) * 2;
#line 6244
      tmp = (*((pool->mem)->realloc_fcn))((void *)pool->blocks, (unsigned long )(& ((BLOCK *)0)->s) + (unsigned long )blockSize * sizeof(XML_Char ));
#line 6244
      temp = (BLOCK *)tmp;
#line 6248
      if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 6249
        return ((XML_Bool )0);
      }
#line 6250
      pool->blocks = temp;
#line 6251
      (pool->blocks)->size = blockSize;
#line 6252
      pool->ptr = (pool->blocks)->s + (pool->ptr - pool->start);
#line 6253
      pool->start = (pool->blocks)->s;
#line 6254
      pool->end = (XML_Char const   *)(pool->start + blockSize);
    } else {
#line 6242
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 6258
    blockSize___0 = (int )(pool->end - (XML_Char const   *)pool->start);
#line 6259
    if (blockSize___0 < 1024) {
#line 6260
      blockSize___0 = 1024;
    } else {
#line 6262
      blockSize___0 *= 2;
    }
#line 6263
    tmp___0 = (*((pool->mem)->malloc_fcn))((unsigned long )(& ((BLOCK *)0)->s) + (unsigned long )blockSize___0 * sizeof(XML_Char ));
#line 6263
    tem___0 = (BLOCK *)tmp___0;
#line 6265
    if (! tem___0) {
#line 6266
      return ((XML_Bool )0);
    }
#line 6267
    tem___0->size = blockSize___0;
#line 6268
    tem___0->next = pool->blocks;
#line 6269
    pool->blocks = tem___0;
#line 6270
    if ((unsigned long )pool->ptr != (unsigned long )pool->start) {
#line 6271
      sym_memcpy(tem___0->s, pool->start, (unsigned long )(pool->ptr - pool->start) * sizeof(XML_Char ));
    }
#line 6273
    pool->ptr = tem___0->s + (pool->ptr - pool->start);
#line 6274
    pool->start = tem___0->s;
#line 6275
    pool->end = (XML_Char const   *)(tem___0->s + blockSize___0);
  }
#line 6277
  return ((XML_Bool )1);
}
}
#line 6280 "xmlparse.c"
static int nextScaffoldPart(XML_Parser parser ) 
{ 
  DTD *dtd ;
  CONTENT_SCAFFOLD *me ;
  int next ;
  void *tmp ;
  CONTENT_SCAFFOLD *temp ;
  void *tmp___0 ;
  void *tmp___1 ;
  unsigned int tmp___2 ;
  CONTENT_SCAFFOLD *parent ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 6283
  dtd = parser->m_dtd;
#line 6287
  if (! dtd->scaffIndex) {
#line 6288
    tmp = (*(parser->m_mem.malloc_fcn))((unsigned long )parser->m_groupSize * sizeof(int ));
#line 6288
    dtd->scaffIndex = (int *)tmp;
#line 6289
    if (! dtd->scaffIndex) {
#line 6290
      return (-1);
    }
#line 6291
    *(dtd->scaffIndex + 0) = 0;
  }
#line 6294
  if (dtd->scaffCount >= dtd->scaffSize) {
#line 6296
    if (dtd->scaffold) {
#line 6297
      tmp___0 = (*(parser->m_mem.realloc_fcn))((void *)dtd->scaffold, (unsigned long )(dtd->scaffSize * 2U) * sizeof(CONTENT_SCAFFOLD ));
#line 6297
      temp = (CONTENT_SCAFFOLD *)tmp___0;
#line 6299
      if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 6300
        return (-1);
      }
#line 6301
      dtd->scaffSize *= 2U;
    } else {
#line 6304
      tmp___1 = (*(parser->m_mem.malloc_fcn))(32UL * sizeof(CONTENT_SCAFFOLD ));
#line 6304
      temp = (CONTENT_SCAFFOLD *)tmp___1;
#line 6306
      if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 6307
        return (-1);
      }
#line 6308
      dtd->scaffSize = 32U;
    }
#line 6310
    dtd->scaffold = temp;
  }
#line 6312
  tmp___2 = dtd->scaffCount;
#line 6312
  (dtd->scaffCount) ++;
#line 6312
  next = (int )tmp___2;
#line 6313
  me = dtd->scaffold + next;
#line 6314
  if (dtd->scaffLevel) {
#line 6315
    parent = dtd->scaffold + *(dtd->scaffIndex + (dtd->scaffLevel - 1));
#line 6316
    if (parent->lastchild) {
#line 6317
      (dtd->scaffold + parent->lastchild)->nextsib = next;
    }
#line 6319
    if (! parent->childcnt) {
#line 6320
      parent->firstchild = next;
    }
#line 6321
    parent->lastchild = next;
#line 6322
    (parent->childcnt) ++;
  }
#line 6324
  tmp___5 = 0;
#line 6324
  me->nextsib = tmp___5;
#line 6324
  tmp___4 = tmp___5;
#line 6324
  me->childcnt = tmp___4;
#line 6324
  tmp___3 = tmp___4;
#line 6324
  me->lastchild = tmp___3;
#line 6324
  me->firstchild = tmp___3;
#line 6325
  return (next);
}
}
#line 6328 "xmlparse.c"
static void build_node(XML_Parser parser , int src_node , XML_Content *dest , XML_Content **contpos ,
                       XML_Char **strpos ) 
{ 
  DTD *dtd ;
  XML_Char const   *src ;
  XML_Char *tmp ;
  unsigned int i ;
  int cn ;

  {
#line 6335
  dtd = parser->m_dtd;
#line 6336
  dest->type = (dtd->scaffold + src_node)->type;
#line 6337
  dest->quant = (dtd->scaffold + src_node)->quant;
#line 6338
  if ((unsigned int )dest->type == 4U) {
#line 6340
    dest->name = *strpos;
#line 6341
    src = (dtd->scaffold + src_node)->name;
#line 6342
    while (1) {
#line 6343
      tmp = *strpos;
#line 6343
      (*strpos) ++;
#line 6343
      *tmp = (XML_Char )*src;
#line 6344
      if (! *src) {
#line 6345
        break;
      }
#line 6346
      src ++;
    }
#line 6348
    dest->numchildren = 0U;
#line 6349
    dest->children = (XML_Content *)((void *)0);
  } else {
#line 6354
    dest->numchildren = (unsigned int )(dtd->scaffold + src_node)->childcnt;
#line 6355
    dest->children = *contpos;
#line 6356
    *contpos += dest->numchildren;
#line 6357
    i = 0U;
#line 6357
    cn = (dtd->scaffold + src_node)->firstchild;
#line 6357
    while (i < dest->numchildren) {
#line 6360
      build_node(parser, cn, dest->children + i, contpos, strpos);
#line 6357
      i ++;
#line 6357
      cn = (dtd->scaffold + cn)->nextsib;
    }
#line 6362
    dest->name = (XML_Char *)((void *)0);
  }
#line 6364
  return;
}
}
#line 6366 "xmlparse.c"
static XML_Content *build_model(XML_Parser parser ) 
{ 
  DTD *dtd ;
  XML_Content *ret ;
  XML_Content *cpos ;
  XML_Char *str ;
  int allocsize ;
  void *tmp ;

  {
#line 6369
  dtd = parser->m_dtd;
#line 6373
  allocsize = (int )((unsigned long )dtd->scaffCount * sizeof(XML_Content ) + (unsigned long )dtd->contentStringLen * sizeof(XML_Char ));
#line 6376
  tmp = (*(parser->m_mem.malloc_fcn))((size_t )allocsize);
#line 6376
  ret = (XML_Content *)tmp;
#line 6377
  if (! ret) {
#line 6378
    return ((XML_Content *)((void *)0));
  }
#line 6380
  str = (XML_Char *)(ret + dtd->scaffCount);
#line 6381
  cpos = ret + 1;
#line 6383
  build_node(parser, 0, ret, & cpos, & str);
#line 6384
  return (ret);
}
}
#line 6387 "xmlparse.c"
static ELEMENT_TYPE *getElementType(XML_Parser parser , ENCODING const   *enc , char const   *ptr ,
                                    char const   *end ) 
{ 
  DTD *dtd ;
  XML_Char const   *name ;
  XML_Char *tmp ;
  ELEMENT_TYPE *ret ;
  NAMED *tmp___0 ;
  int tmp___1 ;

  {
#line 6393
  dtd = parser->m_dtd;
#line 6394
  tmp = poolStoreString(& dtd->pool, enc, ptr, end);
#line 6394
  name = (XML_Char const   *)tmp;
#line 6397
  if (! name) {
#line 6398
    return ((ELEMENT_TYPE *)((void *)0));
  }
#line 6399
  tmp___0 = lookup(parser, & dtd->elementTypes, name, sizeof(ELEMENT_TYPE ));
#line 6399
  ret = (ELEMENT_TYPE *)tmp___0;
#line 6400
  if (! ret) {
#line 6401
    return ((ELEMENT_TYPE *)((void *)0));
  }
#line 6402
  if ((unsigned long )ret->name != (unsigned long )name) {
#line 6403
    dtd->pool.ptr = dtd->pool.start;
  } else {
#line 6405
    dtd->pool.start = dtd->pool.ptr;
#line 6406
    tmp___1 = setElementTypePrefix(parser, ret);
#line 6406
    if (! tmp___1) {
#line 6407
      return ((ELEMENT_TYPE *)((void *)0));
    }
  }
#line 6409
  return (ret);
}
}
#line 1 "xmltok.o"
#pragma merger("0","./xmltok.i","-std=gnu99,-g,-O0,-Wall,-Wmissing-prototypes,-Wstrict-prototypes,-fexceptions")
#line 279 "xmltok.h"
ENCODING const   *XmlGetUtf16InternalEncoding(void) ;
#line 281
int XmlUtf16Encode(int charNum , unsigned short *buf ) ;
#line 306
ENCODING const   *XmlGetUtf16InternalEncodingNS(void) ;
#line 1 "nametab.h"
static unsigned int const   namingBitmap[320]  = 
#line 1 "nametab.h"
  {      (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U, 
        (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U, 
        (unsigned int const   )0,      (unsigned int const   )67108864,      (unsigned int const   )2281701374U,      (unsigned int const   )134217726, 
        (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )4286578687U,      (unsigned int const   )4286578687U, 
        (unsigned int const   )4294967295U,      (unsigned int const   )2146697215,      (unsigned int const   )4294966782U,      (unsigned int const   )2147483647, 
        (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U,      (unsigned int const   )4294959119U,      (unsigned int const   )4231135231U, 
        (unsigned int const   )16777215,      (unsigned int const   )0,      (unsigned int const   )4294901760U,      (unsigned int const   )4294967295U, 
        (unsigned int const   )4294967295U,      (unsigned int const   )4160750079U,      (unsigned int const   )3,      (unsigned int const   )0, 
        (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )4294956864U,      (unsigned int const   )4294967291U,      (unsigned int const   )1417641983,      (unsigned int const   )1048573, 
        (unsigned int const   )4294959102U,      (unsigned int const   )4294967295U,      (unsigned int const   )3758030847U,      (unsigned int const   )4294967295U, 
        (unsigned int const   )4294901763U,      (unsigned int const   )4294967295U,      (unsigned int const   )4294908319U,      (unsigned int const   )54513663, 
        (unsigned int const   )0,      (unsigned int const   )4294836224U,      (unsigned int const   )41943039,      (unsigned int const   )4294967294U, 
        (unsigned int const   )127,      (unsigned int const   )0,      (unsigned int const   )4294901760U,      (unsigned int const   )460799, 
        (unsigned int const   )0,      (unsigned int const   )134217726,      (unsigned int const   )2046,      (unsigned int const   )4294836224U, 
        (unsigned int const   )4294967295U,      (unsigned int const   )2097151999,      (unsigned int const   )3112959,      (unsigned int const   )96, 
        (unsigned int const   )4294967264U,      (unsigned int const   )603979775,      (unsigned int const   )4278190080U,      (unsigned int const   )3, 
        (unsigned int const   )4294549472U,      (unsigned int const   )63307263,      (unsigned int const   )2952790016U,      (unsigned int const   )196611, 
        (unsigned int const   )4294543328U,      (unsigned int const   )57540095,      (unsigned int const   )1577058304,      (unsigned int const   )1835008, 
        (unsigned int const   )4294684640U,      (unsigned int const   )602799615,      (unsigned int const   )0,      (unsigned int const   )1, 
        (unsigned int const   )4294549472U,      (unsigned int const   )600702463,      (unsigned int const   )2952790016U,      (unsigned int const   )3, 
        (unsigned int const   )3594373088U,      (unsigned int const   )62899992,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )4294828000U,      (unsigned int const   )66059775,      (unsigned int const   )0,      (unsigned int const   )3, 
        (unsigned int const   )4294828000U,      (unsigned int const   )66059775,      (unsigned int const   )1073741824,      (unsigned int const   )3, 
        (unsigned int const   )4294828000U,      (unsigned int const   )67108351,      (unsigned int const   )0,      (unsigned int const   )3, 
        (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )4294967294U,      (unsigned int const   )884735,      (unsigned int const   )63,      (unsigned int const   )0, 
        (unsigned int const   )4277151126U,      (unsigned int const   )537750702,      (unsigned int const   )31,      (unsigned int const   )0, 
        (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )4294967039U,      (unsigned int const   )1023, 
        (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )0,      (unsigned int const   )4294967295U,      (unsigned int const   )4294901823U,      (unsigned int const   )8388607, 
        (unsigned int const   )514797,      (unsigned int const   )1342177280,      (unsigned int const   )2184269825U,      (unsigned int const   )2908843, 
        (unsigned int const   )1073741824,      (unsigned int const   )4118857984U,      (unsigned int const   )7,      (unsigned int const   )33622016, 
        (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U, 
        (unsigned int const   )268435455,      (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U,      (unsigned int const   )67108863, 
        (unsigned int const   )1061158911,      (unsigned int const   )4294967295U,      (unsigned int const   )2868854591U,      (unsigned int const   )1073741823, 
        (unsigned int const   )4294967295U,      (unsigned int const   )1608515583,      (unsigned int const   )265232348,      (unsigned int const   )534519807, 
        (unsigned int const   )0,      (unsigned int const   )19520,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )7,      (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )128,      (unsigned int const   )1022,      (unsigned int const   )4294967294U,      (unsigned int const   )4294967295U, 
        (unsigned int const   )2097151,      (unsigned int const   )4294967294U,      (unsigned int const   )4294967295U,      (unsigned int const   )134217727, 
        (unsigned int const   )4294967264U,      (unsigned int const   )8191,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U, 
        (unsigned int const   )4294967295U,      (unsigned int const   )63,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U, 
        (unsigned int const   )4294967295U,      (unsigned int const   )15,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )0,      (unsigned int const   )134176768,      (unsigned int const   )2281701374U,      (unsigned int const   )134217726, 
        (unsigned int const   )0,      (unsigned int const   )8388608,      (unsigned int const   )4286578687U,      (unsigned int const   )4286578687U, 
        (unsigned int const   )16777215,      (unsigned int const   )0,      (unsigned int const   )4294901760U,      (unsigned int const   )4294967295U, 
        (unsigned int const   )4294967295U,      (unsigned int const   )4160750079U,      (unsigned int const   )196611,      (unsigned int const   )0, 
        (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U,      (unsigned int const   )63,      (unsigned int const   )3, 
        (unsigned int const   )4294956992U,      (unsigned int const   )4294967291U,      (unsigned int const   )1417641983,      (unsigned int const   )1048573, 
        (unsigned int const   )4294959102U,      (unsigned int const   )4294967295U,      (unsigned int const   )3758030847U,      (unsigned int const   )4294967295U, 
        (unsigned int const   )4294901883U,      (unsigned int const   )4294967295U,      (unsigned int const   )4294908319U,      (unsigned int const   )54513663, 
        (unsigned int const   )0,      (unsigned int const   )4294836224U,      (unsigned int const   )41943039,      (unsigned int const   )4294967294U, 
        (unsigned int const   )4294836351U,      (unsigned int const   )3154116603U,      (unsigned int const   )4294901782U,      (unsigned int const   )460799, 
        (unsigned int const   )0,      (unsigned int const   )134217726,      (unsigned int const   )524287,      (unsigned int const   )4294902783U, 
        (unsigned int const   )4294967295U,      (unsigned int const   )2097151999,      (unsigned int const   )4293885951U,      (unsigned int const   )67059199, 
        (unsigned int const   )4294967278U,      (unsigned int const   )4093640703U,      (unsigned int const   )4280172543U,      (unsigned int const   )65487, 
        (unsigned int const   )4294549486U,      (unsigned int const   )3552968191U,      (unsigned int const   )2961193375U,      (unsigned int const   )262095, 
        (unsigned int const   )4294543332U,      (unsigned int const   )3547201023U,      (unsigned int const   )1577073031,      (unsigned int const   )2097088, 
        (unsigned int const   )4294684654U,      (unsigned int const   )4092460543U,      (unsigned int const   )15295,      (unsigned int const   )65473, 
        (unsigned int const   )4294549486U,      (unsigned int const   )4090363391U,      (unsigned int const   )2965387663U,      (unsigned int const   )65475, 
        (unsigned int const   )3594373100U,      (unsigned int const   )3284125464U,      (unsigned int const   )8404423,      (unsigned int const   )65408, 
        (unsigned int const   )4294828014U,      (unsigned int const   )3287285247U,      (unsigned int const   )6307295,      (unsigned int const   )65475, 
        (unsigned int const   )4294828012U,      (unsigned int const   )3287285247U,      (unsigned int const   )1080049119,      (unsigned int const   )65475, 
        (unsigned int const   )4294828012U,      (unsigned int const   )3288333823U,      (unsigned int const   )8404431,      (unsigned int const   )65475, 
        (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )4294967294U,      (unsigned int const   )134184959,      (unsigned int const   )67076095,      (unsigned int const   )0, 
        (unsigned int const   )4277151126U,      (unsigned int const   )1006595246,      (unsigned int const   )67059551,      (unsigned int const   )0, 
        (unsigned int const   )50331648,      (unsigned int const   )3265266687U,      (unsigned int const   )4294967039U,      (unsigned int const   )4294837247U, 
        (unsigned int const   )4273934303U,      (unsigned int const   )50216959,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )536805376,      (unsigned int const   )2, 
        (unsigned int const   )160,      (unsigned int const   )4128766,      (unsigned int const   )4294967294U,      (unsigned int const   )4294967295U, 
        (unsigned int const   )1713373183,      (unsigned int const   )4294967294U,      (unsigned int const   )4294967295U,      (unsigned int const   )2013265919};
#line 83 "nametab.h"
static unsigned char const   nmstrtPages[256]  = 
#line 83
  {      (unsigned char const   )2,      (unsigned char const   )3,      (unsigned char const   )4,      (unsigned char const   )5, 
        (unsigned char const   )6,      (unsigned char const   )7,      (unsigned char const   )8,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )9,      (unsigned char const   )10,      (unsigned char const   )11, 
        (unsigned char const   )12,      (unsigned char const   )13,      (unsigned char const   )14,      (unsigned char const   )15, 
        (unsigned char const   )16,      (unsigned char const   )17,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )18,      (unsigned char const   )19, 
        (unsigned char const   )0,      (unsigned char const   )20,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )21,      (unsigned char const   )22,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )23, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )24, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0};
#line 117 "nametab.h"
static unsigned char const   namePages[256]  = 
#line 117
  {      (unsigned char const   )25,      (unsigned char const   )3,      (unsigned char const   )26,      (unsigned char const   )27, 
        (unsigned char const   )28,      (unsigned char const   )29,      (unsigned char const   )30,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )31,      (unsigned char const   )32,      (unsigned char const   )33, 
        (unsigned char const   )34,      (unsigned char const   )35,      (unsigned char const   )36,      (unsigned char const   )37, 
        (unsigned char const   )16,      (unsigned char const   )17,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )18,      (unsigned char const   )19, 
        (unsigned char const   )38,      (unsigned char const   )20,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )39,      (unsigned char const   )22,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )23, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )24, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0};
#line 124 "xmltok.c"
static int isNever(ENCODING const   *enc , char const   *p ) 
{ 


  {
#line 127
  return (0);
}
}
#line 130 "xmltok.c"
static int utf8_isName2(ENCODING const   *enc , char const   *p ) 
{ 


  {
#line 133
  return ((int )(namingBitmap[(((int const   )namePages[((int const   )*((unsigned char const   *)p + 0) >> 2) & 7] << 3) + (((int const   )*((unsigned char const   *)p + 0) & 3) << 1)) + (((int const   )*((unsigned char const   *)p + 1) >> 5) & 1)] & (unsigned int const   )(1 << ((int const   )*((unsigned char const   *)p + 1) & 31))));
}
}
#line 136 "xmltok.c"
static int utf8_isName3(ENCODING const   *enc , char const   *p ) 
{ 


  {
#line 139
  return ((int )(namingBitmap[(((int const   )namePages[(((int const   )*((unsigned char const   *)p + 0) & 15) << 4) + (((int const   )*((unsigned char const   *)p + 1) >> 2) & 15)] << 3) + (((int const   )*((unsigned char const   *)p + 1) & 3) << 1)) + (((int const   )*((unsigned char const   *)p + 2) >> 5) & 1)] & (unsigned int const   )(1 << ((int const   )*((unsigned char const   *)p + 2) & 31))));
}
}
#line 144 "xmltok.c"
static int utf8_isNmstrt2(ENCODING const   *enc , char const   *p ) 
{ 


  {
#line 147
  return ((int )(namingBitmap[(((int const   )nmstrtPages[((int const   )*((unsigned char const   *)p + 0) >> 2) & 7] << 3) + (((int const   )*((unsigned char const   *)p + 0) & 3) << 1)) + (((int const   )*((unsigned char const   *)p + 1) >> 5) & 1)] & (unsigned int const   )(1 << ((int const   )*((unsigned char const   *)p + 1) & 31))));
}
}
#line 150 "xmltok.c"
static int utf8_isNmstrt3(ENCODING const   *enc , char const   *p ) 
{ 


  {
#line 153
  return ((int )(namingBitmap[(((int const   )nmstrtPages[(((int const   )*((unsigned char const   *)p + 0) & 15) << 4) + (((int const   )*((unsigned char const   *)p + 1) >> 2) & 15)] << 3) + (((int const   )*((unsigned char const   *)p + 1) & 3) << 1)) + (((int const   )*((unsigned char const   *)p + 2) >> 5) & 1)] & (unsigned int const   )(1 << ((int const   )*((unsigned char const   *)p + 2) & 31))));
}
}
#line 158 "xmltok.c"
static int utf8_isInvalid2(ENCODING const   *enc , char const   *p ) 
{ 
  int tmp ;

  {
#line 161
  if ((int const   )*((unsigned char const   *)p) < 194) {
#line 161
    tmp = 1;
  } else
#line 161
  if (((int const   )*((unsigned char const   *)p + 1) & 128) == 0) {
#line 161
    tmp = 1;
  } else
#line 161
  if (((int const   )*((unsigned char const   *)p + 1) & 192) == 192) {
#line 161
    tmp = 1;
  } else {
#line 161
    tmp = 0;
  }
#line 161
  return (tmp);
}
}
#line 164 "xmltok.c"
static int utf8_isInvalid3(ENCODING const   *enc , char const   *p ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 167
  if (((int const   )*((unsigned char const   *)p + 2) & 128) == 0) {
#line 167
    tmp___4 = 1;
  } else {
#line 167
    if ((int const   )*((unsigned char const   *)p) == 239) {
#line 167
      if ((int const   )*((unsigned char const   *)p + 1) == 191) {
#line 167
        tmp = (int const   )*((unsigned char const   *)p + 2) > 189;
      } else {
#line 167
        tmp = ((int const   )*((unsigned char const   *)p + 2) & 192) == 192;
      }
    } else {
#line 167
      tmp = ((int const   )*((unsigned char const   *)p + 2) & 192) == 192;
    }
#line 167
    if (tmp) {
#line 167
      tmp___4 = 1;
    } else {
#line 167
      if ((int const   )*((unsigned char const   *)p) == 224) {
#line 167
        if ((int const   )*((unsigned char const   *)p + 1) < 160) {
#line 167
          tmp___0 = 1;
        } else
#line 167
        if (((int const   )*((unsigned char const   *)p + 1) & 192) == 192) {
#line 167
          tmp___0 = 1;
        } else {
#line 167
          tmp___0 = 0;
        }
#line 167
        tmp___3 = tmp___0;
      } else {
#line 167
        if (((int const   )*((unsigned char const   *)p + 1) & 128) == 0) {
#line 167
          tmp___2 = 1;
        } else {
#line 167
          if ((int const   )*((unsigned char const   *)p) == 237) {
#line 167
            tmp___1 = (int const   )*((unsigned char const   *)p + 1) > 159;
          } else {
#line 167
            tmp___1 = ((int const   )*((unsigned char const   *)p + 1) & 192) == 192;
          }
#line 167
          if (tmp___1) {
#line 167
            tmp___2 = 1;
          } else {
#line 167
            tmp___2 = 0;
          }
        }
#line 167
        tmp___3 = tmp___2;
      }
#line 167
      if (tmp___3) {
#line 167
        tmp___4 = 1;
      } else {
#line 167
        tmp___4 = 0;
      }
    }
  }
#line 167
  return (tmp___4);
}
}
#line 170 "xmltok.c"
static int utf8_isInvalid4(ENCODING const   *enc , char const   *p ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 173
  if (((int const   )*((unsigned char const   *)p + 3) & 128) == 0) {
#line 173
    tmp___3 = 1;
  } else
#line 173
  if (((int const   )*((unsigned char const   *)p + 3) & 192) == 192) {
#line 173
    tmp___3 = 1;
  } else
#line 173
  if (((int const   )*((unsigned char const   *)p + 2) & 128) == 0) {
#line 173
    tmp___3 = 1;
  } else
#line 173
  if (((int const   )*((unsigned char const   *)p + 2) & 192) == 192) {
#line 173
    tmp___3 = 1;
  } else {
#line 173
    if ((int const   )*((unsigned char const   *)p) == 240) {
#line 173
      if ((int const   )*((unsigned char const   *)p + 1) < 144) {
#line 173
        tmp = 1;
      } else
#line 173
      if (((int const   )*((unsigned char const   *)p + 1) & 192) == 192) {
#line 173
        tmp = 1;
      } else {
#line 173
        tmp = 0;
      }
#line 173
      tmp___2 = tmp;
    } else {
#line 173
      if (((int const   )*((unsigned char const   *)p + 1) & 128) == 0) {
#line 173
        tmp___1 = 1;
      } else {
#line 173
        if ((int const   )*((unsigned char const   *)p) == 244) {
#line 173
          tmp___0 = (int const   )*((unsigned char const   *)p + 1) > 143;
        } else {
#line 173
          tmp___0 = ((int const   )*((unsigned char const   *)p + 1) & 192) == 192;
        }
#line 173
        if (tmp___0) {
#line 173
          tmp___1 = 1;
        } else {
#line 173
          tmp___1 = 0;
        }
      }
#line 173
      tmp___2 = tmp___1;
    }
#line 173
    if (tmp___2) {
#line 173
      tmp___3 = 1;
    } else {
#line 173
      tmp___3 = 0;
    }
  }
#line 173
  return (tmp___3);
}
}
#line 225
static int checkCharRefNumber(int result ) ;
#line 92 "xmltok_impl.c"
static int normal_scanComment(ENCODING const   *enc , char const   *ptr , char const   *end ,
                              char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 96
  if ((unsigned long )ptr != (unsigned long )end) {
#line 97
    if (! ((int const   )*ptr == 45)) {
#line 98
      *nextTokPtr = ptr;
#line 99
      return (0);
    }
#line 101
    ptr ++;
#line 102
    while ((unsigned long )ptr != (unsigned long )end) {
#line 103
      switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
      case 5: 
#line 104
      if (end - ptr < 2L) {
#line 104
        return (-2);
      }
#line 104
      tmp = (*(((struct normal_encoding  const  *)enc)->isInvalid2))(enc, ptr);
#line 104
      if (tmp) {
#line 104
        *nextTokPtr = ptr;
#line 104
        return (0);
      }
#line 104
      ptr += 2;
#line 104
      break;
      case 6: 
#line 104
      if (end - ptr < 3L) {
#line 104
        return (-2);
      }
#line 104
      tmp___0 = (*(((struct normal_encoding  const  *)enc)->isInvalid3))(enc, ptr);
#line 104
      if (tmp___0) {
#line 104
        *nextTokPtr = ptr;
#line 104
        return (0);
      }
#line 104
      ptr += 3;
#line 104
      break;
      case 7: 
#line 104
      if (end - ptr < 4L) {
#line 104
        return (-2);
      }
#line 104
      tmp___1 = (*(((struct normal_encoding  const  *)enc)->isInvalid4))(enc, ptr);
#line 104
      if (tmp___1) {
#line 104
        *nextTokPtr = ptr;
#line 104
        return (0);
      }
#line 104
      ptr += 4;
#line 104
      break;
      case 8: 
      case 1: 
      case 0: 
#line 104
      *nextTokPtr = ptr;
#line 104
      return (0);
      case 27: 
#line 106
      ptr ++;
#line 106
      if ((unsigned long )ptr == (unsigned long )end) {
#line 107
        return (-1);
      }
#line 108
      if ((int const   )*ptr == 45) {
#line 109
        ptr ++;
#line 109
        if ((unsigned long )ptr == (unsigned long )end) {
#line 110
          return (-1);
        }
#line 111
        if (! ((int const   )*ptr == 62)) {
#line 112
          *nextTokPtr = ptr;
#line 113
          return (0);
        }
#line 115
        *nextTokPtr = ptr + 1;
#line 116
        return (13);
      }
#line 118
      break;
      default: 
#line 120
      ptr ++;
#line 121
      break;
      }
    }
  }
#line 125
  return (-1);
}
}
#line 130 "xmltok_impl.c"
static int normal_scanDecl(ENCODING const   *enc , char const   *ptr , char const   *end ,
                           char const   **nextTokPtr ) 
{ 
  int tmp ;

  {
#line 134
  if ((unsigned long )ptr == (unsigned long )end) {
#line 135
    return (-1);
  }
#line 136
  switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
  case 27: 
#line 138
  tmp = normal_scanComment(enc, ptr + 1, end, nextTokPtr);
#line 138
  return (tmp);
  case 20: 
#line 140
  *nextTokPtr = ptr + 1;
#line 141
  return (33);
  case 24: 
  case 22: 
#line 144
  ptr ++;
#line 145
  break;
  default: 
#line 147
  *nextTokPtr = ptr;
#line 148
  return (0);
  }
#line 150
  while ((unsigned long )ptr != (unsigned long )end) {
#line 151
    switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
    case 30: 
#line 153
    if ((unsigned long )(ptr + 1) == (unsigned long )end) {
#line 154
      return (-1);
    }
#line 156
    switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)]) {
    case 30: 
    case 10: 
    case 9: 
    case 21: 
#line 158
    *nextTokPtr = ptr;
#line 159
    return (0);
    }
    case 10: 
    case 9: 
    case 21: 
#line 163
    *nextTokPtr = ptr;
#line 164
    return (16);
    case 24: 
    case 22: 
#line 167
    ptr ++;
#line 168
    break;
    default: 
#line 170
    *nextTokPtr = ptr;
#line 171
    return (0);
    }
  }
#line 174
  return (-1);
}
}
#line 177 "xmltok_impl.c"
static int normal_checkPiTarget(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                int *tokPtr ) 
{ 
  int upper ;

  {
#line 181
  upper = 0;
#line 182
  *tokPtr = 11;
#line 183
  if (end - ptr != 3L) {
#line 184
    return (1);
  }
#line 185
  switch ((int const   )*ptr) {
  case 120: 
#line 187
  break;
  case 88: 
#line 189
  upper = 1;
#line 190
  break;
  default: 
#line 192
  return (1);
  }
#line 194
  ptr ++;
#line 195
  switch ((int const   )*ptr) {
  case 109: 
#line 197
  break;
  case 77: 
#line 199
  upper = 1;
#line 200
  break;
  default: 
#line 202
  return (1);
  }
#line 204
  ptr ++;
#line 205
  switch ((int const   )*ptr) {
  case 108: 
#line 207
  break;
  case 76: 
#line 209
  upper = 1;
#line 210
  break;
  default: 
#line 212
  return (1);
  }
#line 214
  if (upper) {
#line 215
    return (0);
  }
#line 216
  *tokPtr = 12;
#line 217
  return (1);
}
}
#line 222 "xmltok_impl.c"
static int normal_scanPi(ENCODING const   *enc , char const   *ptr , char const   *end ,
                         char const   **nextTokPtr ) 
{ 
  int tok ;
  char const   *target ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 227
  target = ptr;
#line 228
  if ((unsigned long )ptr == (unsigned long )end) {
#line 229
    return (-1);
  }
#line 230
  switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
  case 29: 
#line 231
  *nextTokPtr = ptr;
#line 231
  return (0);
  case 24: 
  case 22: 
#line 231
  ptr ++;
#line 231
  break;
  case 5: 
#line 231
  if (end - ptr < 2L) {
#line 231
    return (-2);
  }
#line 231
  tmp = (*(((struct normal_encoding  const  *)enc)->isNmstrt2))(enc, ptr);
#line 231
  if (! tmp) {
#line 231
    *nextTokPtr = ptr;
#line 231
    return (0);
  }
#line 231
  ptr += 2;
#line 231
  break;
  case 6: 
#line 231
  if (end - ptr < 3L) {
#line 231
    return (-2);
  }
#line 231
  tmp___0 = (*(((struct normal_encoding  const  *)enc)->isNmstrt3))(enc, ptr);
#line 231
  if (! tmp___0) {
#line 231
    *nextTokPtr = ptr;
#line 231
    return (0);
  }
#line 231
  ptr += 3;
#line 231
  break;
  case 7: 
#line 231
  if (end - ptr < 4L) {
#line 231
    return (-2);
  }
#line 231
  tmp___1 = (*(((struct normal_encoding  const  *)enc)->isNmstrt4))(enc, ptr);
#line 231
  if (! tmp___1) {
#line 231
    *nextTokPtr = ptr;
#line 231
    return (0);
  }
#line 231
  ptr += 4;
#line 231
  break;
  default: 
#line 233
  *nextTokPtr = ptr;
#line 234
  return (0);
  }
#line 236
  while ((unsigned long )ptr != (unsigned long )end) {
#line 237
    switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
    case 29: 
#line 238
    *nextTokPtr = ptr;
#line 238
    return (0);
    case 27: 
    case 26: 
    case 25: 
    case 24: 
    case 22: 
#line 238
    ptr ++;
#line 238
    break;
    case 5: 
#line 238
    if (end - ptr < 2L) {
#line 238
      return (-2);
    }
#line 238
    tmp___2 = (*(((struct normal_encoding  const  *)enc)->isName2))(enc, ptr);
#line 238
    if (! tmp___2) {
#line 238
      *nextTokPtr = ptr;
#line 238
      return (0);
    }
#line 238
    ptr += 2;
#line 238
    break;
    case 6: 
#line 238
    if (end - ptr < 3L) {
#line 238
      return (-2);
    }
#line 238
    tmp___3 = (*(((struct normal_encoding  const  *)enc)->isName3))(enc, ptr);
#line 238
    if (! tmp___3) {
#line 238
      *nextTokPtr = ptr;
#line 238
      return (0);
    }
#line 238
    ptr += 3;
#line 238
    break;
    case 7: 
#line 238
    if (end - ptr < 4L) {
#line 238
      return (-2);
    }
#line 238
    tmp___4 = (*(((struct normal_encoding  const  *)enc)->isName4))(enc, ptr);
#line 238
    if (! tmp___4) {
#line 238
      *nextTokPtr = ptr;
#line 238
      return (0);
    }
#line 238
    ptr += 4;
#line 238
    break;
    case 10: 
    case 9: 
    case 21: 
#line 240
    tmp___5 = normal_checkPiTarget(enc, target, ptr, & tok);
#line 240
    if (! tmp___5) {
#line 241
      *nextTokPtr = ptr;
#line 242
      return (0);
    }
#line 244
    ptr ++;
#line 245
    while ((unsigned long )ptr != (unsigned long )end) {
#line 246
      switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
      case 5: 
#line 247
      if (end - ptr < 2L) {
#line 247
        return (-2);
      }
#line 247
      tmp___6 = (*(((struct normal_encoding  const  *)enc)->isInvalid2))(enc, ptr);
#line 247
      if (tmp___6) {
#line 247
        *nextTokPtr = ptr;
#line 247
        return (0);
      }
#line 247
      ptr += 2;
#line 247
      break;
      case 6: 
#line 247
      if (end - ptr < 3L) {
#line 247
        return (-2);
      }
#line 247
      tmp___7 = (*(((struct normal_encoding  const  *)enc)->isInvalid3))(enc, ptr);
#line 247
      if (tmp___7) {
#line 247
        *nextTokPtr = ptr;
#line 247
        return (0);
      }
#line 247
      ptr += 3;
#line 247
      break;
      case 7: 
#line 247
      if (end - ptr < 4L) {
#line 247
        return (-2);
      }
#line 247
      tmp___8 = (*(((struct normal_encoding  const  *)enc)->isInvalid4))(enc, ptr);
#line 247
      if (tmp___8) {
#line 247
        *nextTokPtr = ptr;
#line 247
        return (0);
      }
#line 247
      ptr += 4;
#line 247
      break;
      case 8: 
      case 1: 
      case 0: 
#line 247
      *nextTokPtr = ptr;
#line 247
      return (0);
      case 15: 
#line 249
      ptr ++;
#line 250
      if ((unsigned long )ptr == (unsigned long )end) {
#line 251
        return (-1);
      }
#line 252
      if ((int const   )*ptr == 62) {
#line 253
        *nextTokPtr = ptr + 1;
#line 254
        return (tok);
      }
#line 256
      break;
      default: 
#line 258
      ptr ++;
#line 259
      break;
      }
    }
#line 262
    return (-1);
    case 15: 
#line 264
    tmp___9 = normal_checkPiTarget(enc, target, ptr, & tok);
#line 264
    if (! tmp___9) {
#line 265
      *nextTokPtr = ptr;
#line 266
      return (0);
    }
#line 268
    ptr ++;
#line 269
    if ((unsigned long )ptr == (unsigned long )end) {
#line 270
      return (-1);
    }
#line 271
    if ((int const   )*ptr == 62) {
#line 272
      *nextTokPtr = ptr + 1;
#line 273
      return (tok);
    }
    default: 
#line 277
    *nextTokPtr = ptr;
#line 278
    return (0);
    }
  }
#line 281
  return (-1);
}
}
#line 288
static int normal_scanCdataSection(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                   char const   **nextTokPtr ) ;
#line 288 "xmltok_impl.c"
static char const   CDATA_LSQB[6]  = {      (char const   )67,      (char const   )68,      (char const   )65,      (char const   )84, 
        (char const   )65,      (char const   )91};
#line 284 "xmltok_impl.c"
static int normal_scanCdataSection(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                   char const   **nextTokPtr ) 
{ 
  int i ;

  {
#line 292
  if (end - ptr < 6L) {
#line 293
    return (-1);
  }
#line 294
  i = 0;
#line 294
  while (i < 6) {
#line 295
    if (! ((int const   )*ptr == (int const   )CDATA_LSQB[i])) {
#line 296
      *nextTokPtr = ptr;
#line 297
      return (0);
    }
#line 294
    i ++;
#line 294
    ptr ++;
  }
#line 300
  *nextTokPtr = ptr;
#line 301
  return (8);
}
}
#line 304 "xmltok_impl.c"
static int normal_cdataSectionTok(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                  char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 308
  if ((unsigned long )ptr == (unsigned long )end) {
#line 309
    return (-4);
  }
#line 319
  switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
  case 4: 
#line 321
  ptr ++;
#line 322
  if ((unsigned long )ptr == (unsigned long )end) {
#line 323
    return (-1);
  }
#line 324
  if (! ((int const   )*ptr == 93)) {
#line 325
    break;
  }
#line 326
  ptr ++;
#line 327
  if ((unsigned long )ptr == (unsigned long )end) {
#line 328
    return (-1);
  }
#line 329
  if (! ((int const   )*ptr == 62)) {
#line 330
    ptr --;
#line 331
    break;
  }
#line 333
  *nextTokPtr = ptr + 1;
#line 334
  return (40);
  case 9: 
#line 336
  ptr ++;
#line 337
  if ((unsigned long )ptr == (unsigned long )end) {
#line 338
    return (-1);
  }
#line 339
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 340
    ptr ++;
  }
#line 341
  *nextTokPtr = ptr;
#line 342
  return (7);
  case 10: 
#line 344
  *nextTokPtr = ptr + 1;
#line 345
  return (7);
  case 5: 
#line 346
  if (end - ptr < 2L) {
#line 346
    return (-2);
  }
#line 346
  tmp = (*(((struct normal_encoding  const  *)enc)->isInvalid2))(enc, ptr);
#line 346
  if (tmp) {
#line 346
    *nextTokPtr = ptr;
#line 346
    return (0);
  }
#line 346
  ptr += 2;
#line 346
  break;
  case 6: 
#line 346
  if (end - ptr < 3L) {
#line 346
    return (-2);
  }
#line 346
  tmp___0 = (*(((struct normal_encoding  const  *)enc)->isInvalid3))(enc, ptr);
#line 346
  if (tmp___0) {
#line 346
    *nextTokPtr = ptr;
#line 346
    return (0);
  }
#line 346
  ptr += 3;
#line 346
  break;
  case 7: 
#line 346
  if (end - ptr < 4L) {
#line 346
    return (-2);
  }
#line 346
  tmp___1 = (*(((struct normal_encoding  const  *)enc)->isInvalid4))(enc, ptr);
#line 346
  if (tmp___1) {
#line 346
    *nextTokPtr = ptr;
#line 346
    return (0);
  }
#line 346
  ptr += 4;
#line 346
  break;
  case 8: 
  case 1: 
  case 0: 
#line 346
  *nextTokPtr = ptr;
#line 346
  return (0);
  default: 
#line 348
  ptr ++;
#line 349
  break;
  }
#line 351
  while ((unsigned long )ptr != (unsigned long )end) {
#line 352
    switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
    case 5: 
#line 361
    if (end - ptr < 2L) {
#line 361
      *nextTokPtr = ptr;
#line 361
      return (6);
    } else {
#line 361
      tmp___2 = (*(((struct normal_encoding  const  *)enc)->isInvalid2))(enc, ptr);
#line 361
      if (tmp___2) {
#line 361
        *nextTokPtr = ptr;
#line 361
        return (6);
      }
    }
#line 361
    ptr += 2;
#line 361
    break;
    case 6: 
#line 361
    if (end - ptr < 3L) {
#line 361
      *nextTokPtr = ptr;
#line 361
      return (6);
    } else {
#line 361
      tmp___3 = (*(((struct normal_encoding  const  *)enc)->isInvalid3))(enc, ptr);
#line 361
      if (tmp___3) {
#line 361
        *nextTokPtr = ptr;
#line 361
        return (6);
      }
    }
#line 361
    ptr += 3;
#line 361
    break;
    case 7: 
#line 361
    if (end - ptr < 4L) {
#line 361
      *nextTokPtr = ptr;
#line 361
      return (6);
    } else {
#line 361
      tmp___4 = (*(((struct normal_encoding  const  *)enc)->isInvalid4))(enc, ptr);
#line 361
      if (tmp___4) {
#line 361
        *nextTokPtr = ptr;
#line 361
        return (6);
      }
    }
#line 361
    ptr += 4;
#line 361
    break;
    case 4: 
    case 10: 
    case 9: 
    case 8: 
    case 1: 
    case 0: 
#line 369
    *nextTokPtr = ptr;
#line 370
    return (6);
    default: 
#line 372
    ptr ++;
#line 373
    break;
    }
  }
#line 376
  *nextTokPtr = ptr;
#line 377
  return (6);
}
}
#line 382 "xmltok_impl.c"
static int normal_scanEndTag(ENCODING const   *enc , char const   *ptr , char const   *end ,
                             char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 386
  if ((unsigned long )ptr == (unsigned long )end) {
#line 387
    return (-1);
  }
#line 388
  switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
  case 29: 
#line 389
  *nextTokPtr = ptr;
#line 389
  return (0);
  case 24: 
  case 22: 
#line 389
  ptr ++;
#line 389
  break;
  case 5: 
#line 389
  if (end - ptr < 2L) {
#line 389
    return (-2);
  }
#line 389
  tmp = (*(((struct normal_encoding  const  *)enc)->isNmstrt2))(enc, ptr);
#line 389
  if (! tmp) {
#line 389
    *nextTokPtr = ptr;
#line 389
    return (0);
  }
#line 389
  ptr += 2;
#line 389
  break;
  case 6: 
#line 389
  if (end - ptr < 3L) {
#line 389
    return (-2);
  }
#line 389
  tmp___0 = (*(((struct normal_encoding  const  *)enc)->isNmstrt3))(enc, ptr);
#line 389
  if (! tmp___0) {
#line 389
    *nextTokPtr = ptr;
#line 389
    return (0);
  }
#line 389
  ptr += 3;
#line 389
  break;
  case 7: 
#line 389
  if (end - ptr < 4L) {
#line 389
    return (-2);
  }
#line 389
  tmp___1 = (*(((struct normal_encoding  const  *)enc)->isNmstrt4))(enc, ptr);
#line 389
  if (! tmp___1) {
#line 389
    *nextTokPtr = ptr;
#line 389
    return (0);
  }
#line 389
  ptr += 4;
#line 389
  break;
  default: 
#line 391
  *nextTokPtr = ptr;
#line 392
  return (0);
  }
#line 394
  while ((unsigned long )ptr != (unsigned long )end) {
#line 395
    switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
    case 29: 
#line 396
    *nextTokPtr = ptr;
#line 396
    return (0);
    case 27: 
    case 26: 
    case 25: 
    case 24: 
    case 22: 
#line 396
    ptr ++;
#line 396
    break;
    case 5: 
#line 396
    if (end - ptr < 2L) {
#line 396
      return (-2);
    }
#line 396
    tmp___2 = (*(((struct normal_encoding  const  *)enc)->isName2))(enc, ptr);
#line 396
    if (! tmp___2) {
#line 396
      *nextTokPtr = ptr;
#line 396
      return (0);
    }
#line 396
    ptr += 2;
#line 396
    break;
    case 6: 
#line 396
    if (end - ptr < 3L) {
#line 396
      return (-2);
    }
#line 396
    tmp___3 = (*(((struct normal_encoding  const  *)enc)->isName3))(enc, ptr);
#line 396
    if (! tmp___3) {
#line 396
      *nextTokPtr = ptr;
#line 396
      return (0);
    }
#line 396
    ptr += 3;
#line 396
    break;
    case 7: 
#line 396
    if (end - ptr < 4L) {
#line 396
      return (-2);
    }
#line 396
    tmp___4 = (*(((struct normal_encoding  const  *)enc)->isName4))(enc, ptr);
#line 396
    if (! tmp___4) {
#line 396
      *nextTokPtr = ptr;
#line 396
      return (0);
    }
#line 396
    ptr += 4;
#line 396
    break;
    case 10: 
    case 9: 
    case 21: 
#line 398
    ptr ++;
#line 398
    while ((unsigned long )ptr != (unsigned long )end) {
#line 399
      switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
      case 10: 
      case 9: 
      case 21: 
#line 401
      break;
      case 11: 
#line 403
      *nextTokPtr = ptr + 1;
#line 404
      return (5);
      default: 
#line 406
      *nextTokPtr = ptr;
#line 407
      return (0);
      }
#line 398
      ptr ++;
    }
#line 410
    return (-1);
    case 23: 
#line 415
    ptr ++;
#line 416
    break;
    case 11: 
#line 419
    *nextTokPtr = ptr + 1;
#line 420
    return (5);
    default: 
#line 422
    *nextTokPtr = ptr;
#line 423
    return (0);
    }
  }
#line 426
  return (-1);
}
}
#line 431 "xmltok_impl.c"
static int normal_scanHexCharRef(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                 char const   **nextTokPtr ) 
{ 


  {
#line 435
  if ((unsigned long )ptr != (unsigned long )end) {
#line 436
    switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
    case 24: 
    case 25: 
#line 439
    break;
    default: 
#line 441
    *nextTokPtr = ptr;
#line 442
    return (0);
    }
#line 444
    ptr ++;
#line 444
    while ((unsigned long )ptr != (unsigned long )end) {
#line 445
      switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
      case 24: 
      case 25: 
#line 448
      break;
      case 18: 
#line 450
      *nextTokPtr = ptr + 1;
#line 451
      return (10);
      default: 
#line 453
      *nextTokPtr = ptr;
#line 454
      return (0);
      }
#line 444
      ptr ++;
    }
  }
#line 458
  return (-1);
}
}
#line 463 "xmltok_impl.c"
static int normal_scanCharRef(ENCODING const   *enc , char const   *ptr , char const   *end ,
                              char const   **nextTokPtr ) 
{ 
  int tmp ;

  {
#line 467
  if ((unsigned long )ptr != (unsigned long )end) {
#line 468
    if ((int const   )*ptr == 120) {
#line 469
      tmp = normal_scanHexCharRef(enc, ptr + 1, end, nextTokPtr);
#line 469
      return (tmp);
    }
#line 470
    switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
    case 25: 
#line 472
    break;
    default: 
#line 474
    *nextTokPtr = ptr;
#line 475
    return (0);
    }
#line 477
    ptr ++;
#line 477
    while ((unsigned long )ptr != (unsigned long )end) {
#line 478
      switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
      case 25: 
#line 480
      break;
      case 18: 
#line 482
      *nextTokPtr = ptr + 1;
#line 483
      return (10);
      default: 
#line 485
      *nextTokPtr = ptr;
#line 486
      return (0);
      }
#line 477
      ptr ++;
    }
  }
#line 490
  return (-1);
}
}
#line 495 "xmltok_impl.c"
static int normal_scanRef(ENCODING const   *enc , char const   *ptr , char const   *end ,
                          char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 499
  if ((unsigned long )ptr == (unsigned long )end) {
#line 500
    return (-1);
  }
#line 501
  switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
  case 29: 
#line 502
  *nextTokPtr = ptr;
#line 502
  return (0);
  case 24: 
  case 22: 
#line 502
  ptr ++;
#line 502
  break;
  case 5: 
#line 502
  if (end - ptr < 2L) {
#line 502
    return (-2);
  }
#line 502
  tmp = (*(((struct normal_encoding  const  *)enc)->isNmstrt2))(enc, ptr);
#line 502
  if (! tmp) {
#line 502
    *nextTokPtr = ptr;
#line 502
    return (0);
  }
#line 502
  ptr += 2;
#line 502
  break;
  case 6: 
#line 502
  if (end - ptr < 3L) {
#line 502
    return (-2);
  }
#line 502
  tmp___0 = (*(((struct normal_encoding  const  *)enc)->isNmstrt3))(enc, ptr);
#line 502
  if (! tmp___0) {
#line 502
    *nextTokPtr = ptr;
#line 502
    return (0);
  }
#line 502
  ptr += 3;
#line 502
  break;
  case 7: 
#line 502
  if (end - ptr < 4L) {
#line 502
    return (-2);
  }
#line 502
  tmp___1 = (*(((struct normal_encoding  const  *)enc)->isNmstrt4))(enc, ptr);
#line 502
  if (! tmp___1) {
#line 502
    *nextTokPtr = ptr;
#line 502
    return (0);
  }
#line 502
  ptr += 4;
#line 502
  break;
  case 19: 
#line 504
  tmp___2 = normal_scanCharRef(enc, ptr + 1, end, nextTokPtr);
#line 504
  return (tmp___2);
  default: 
#line 506
  *nextTokPtr = ptr;
#line 507
  return (0);
  }
#line 509
  while ((unsigned long )ptr != (unsigned long )end) {
#line 510
    switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
    case 29: 
#line 511
    *nextTokPtr = ptr;
#line 511
    return (0);
    case 27: 
    case 26: 
    case 25: 
    case 24: 
    case 22: 
#line 511
    ptr ++;
#line 511
    break;
    case 5: 
#line 511
    if (end - ptr < 2L) {
#line 511
      return (-2);
    }
#line 511
    tmp___3 = (*(((struct normal_encoding  const  *)enc)->isName2))(enc, ptr);
#line 511
    if (! tmp___3) {
#line 511
      *nextTokPtr = ptr;
#line 511
      return (0);
    }
#line 511
    ptr += 2;
#line 511
    break;
    case 6: 
#line 511
    if (end - ptr < 3L) {
#line 511
      return (-2);
    }
#line 511
    tmp___4 = (*(((struct normal_encoding  const  *)enc)->isName3))(enc, ptr);
#line 511
    if (! tmp___4) {
#line 511
      *nextTokPtr = ptr;
#line 511
      return (0);
    }
#line 511
    ptr += 3;
#line 511
    break;
    case 7: 
#line 511
    if (end - ptr < 4L) {
#line 511
      return (-2);
    }
#line 511
    tmp___5 = (*(((struct normal_encoding  const  *)enc)->isName4))(enc, ptr);
#line 511
    if (! tmp___5) {
#line 511
      *nextTokPtr = ptr;
#line 511
      return (0);
    }
#line 511
    ptr += 4;
#line 511
    break;
    case 18: 
#line 513
    *nextTokPtr = ptr + 1;
#line 514
    return (9);
    default: 
#line 516
    *nextTokPtr = ptr;
#line 517
    return (0);
    }
  }
#line 520
  return (-1);
}
}
#line 525 "xmltok_impl.c"
static int normal_scanAtts(ENCODING const   *enc , char const   *ptr , char const   *end ,
                           char const   **nextTokPtr ) 
{ 
  int hadColon ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int t ;
  int open ;
  int t___0 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tok ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 530
  hadColon = 0;
#line 532
  while ((unsigned long )ptr != (unsigned long )end) {
#line 533
    switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
    case 29: 
#line 534
    *nextTokPtr = ptr;
#line 534
    return (0);
    case 27: 
    case 26: 
    case 25: 
    case 24: 
    case 22: 
#line 534
    ptr ++;
#line 534
    break;
    case 5: 
#line 534
    if (end - ptr < 2L) {
#line 534
      return (-2);
    }
#line 534
    tmp = (*(((struct normal_encoding  const  *)enc)->isName2))(enc, ptr);
#line 534
    if (! tmp) {
#line 534
      *nextTokPtr = ptr;
#line 534
      return (0);
    }
#line 534
    ptr += 2;
#line 534
    break;
    case 6: 
#line 534
    if (end - ptr < 3L) {
#line 534
      return (-2);
    }
#line 534
    tmp___0 = (*(((struct normal_encoding  const  *)enc)->isName3))(enc, ptr);
#line 534
    if (! tmp___0) {
#line 534
      *nextTokPtr = ptr;
#line 534
      return (0);
    }
#line 534
    ptr += 3;
#line 534
    break;
    case 7: 
#line 534
    if (end - ptr < 4L) {
#line 534
      return (-2);
    }
#line 534
    tmp___1 = (*(((struct normal_encoding  const  *)enc)->isName4))(enc, ptr);
#line 534
    if (! tmp___1) {
#line 534
      *nextTokPtr = ptr;
#line 534
      return (0);
    }
#line 534
    ptr += 4;
#line 534
    break;
    case 23: 
#line 537
    if (hadColon) {
#line 538
      *nextTokPtr = ptr;
#line 539
      return (0);
    }
#line 541
    hadColon = 1;
#line 542
    ptr ++;
#line 543
    if ((unsigned long )ptr == (unsigned long )end) {
#line 544
      return (-1);
    }
#line 545
    switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
    case 29: 
#line 546
    *nextTokPtr = ptr;
#line 546
    return (0);
    case 24: 
    case 22: 
#line 546
    ptr ++;
#line 546
    break;
    case 5: 
#line 546
    if (end - ptr < 2L) {
#line 546
      return (-2);
    }
#line 546
    tmp___2 = (*(((struct normal_encoding  const  *)enc)->isNmstrt2))(enc, ptr);
#line 546
    if (! tmp___2) {
#line 546
      *nextTokPtr = ptr;
#line 546
      return (0);
    }
#line 546
    ptr += 2;
#line 546
    break;
    case 6: 
#line 546
    if (end - ptr < 3L) {
#line 546
      return (-2);
    }
#line 546
    tmp___3 = (*(((struct normal_encoding  const  *)enc)->isNmstrt3))(enc, ptr);
#line 546
    if (! tmp___3) {
#line 546
      *nextTokPtr = ptr;
#line 546
      return (0);
    }
#line 546
    ptr += 3;
#line 546
    break;
    case 7: 
#line 546
    if (end - ptr < 4L) {
#line 546
      return (-2);
    }
#line 546
    tmp___4 = (*(((struct normal_encoding  const  *)enc)->isNmstrt4))(enc, ptr);
#line 546
    if (! tmp___4) {
#line 546
      *nextTokPtr = ptr;
#line 546
      return (0);
    }
#line 546
    ptr += 4;
#line 546
    break;
    default: 
#line 548
    *nextTokPtr = ptr;
#line 549
    return (0);
    }
#line 551
    break;
    case 10: 
    case 9: 
    case 21: 
#line 554
    while (1) {
#line 557
      ptr ++;
#line 558
      if ((unsigned long )ptr == (unsigned long )end) {
#line 559
        return (-1);
      }
#line 560
      t = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
#line 561
      if (t == 14) {
#line 562
        break;
      }
#line 563
      switch (t) {
      case 9: 
      case 10: 
      case 21: 
#line 567
      break;
      default: 
#line 569
      *nextTokPtr = ptr;
#line 570
      return (0);
      }
    }
    case 14: 
#line 578
    hadColon = 0;
#line 580
    while (1) {
#line 581
      ptr ++;
#line 582
      if ((unsigned long )ptr == (unsigned long )end) {
#line 583
        return (-1);
      }
#line 584
      open = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
#line 585
      if (open == 12) {
#line 586
        break;
      } else
#line 585
      if (open == 13) {
#line 586
        break;
      }
#line 587
      switch (open) {
      case 9: 
      case 10: 
      case 21: 
#line 591
      break;
      default: 
#line 593
      *nextTokPtr = ptr;
#line 594
      return (0);
      }
    }
#line 597
    ptr ++;
#line 599
    while (1) {
#line 601
      if ((unsigned long )ptr == (unsigned long )end) {
#line 602
        return (-1);
      }
#line 603
      t___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
#line 604
      if (t___0 == open) {
#line 605
        break;
      }
#line 606
      switch (t___0) {
      case 5: 
#line 607
      if (end - ptr < 2L) {
#line 607
        return (-2);
      }
#line 607
      tmp___5 = (*(((struct normal_encoding  const  *)enc)->isInvalid2))(enc, ptr);
#line 607
      if (tmp___5) {
#line 607
        *nextTokPtr = ptr;
#line 607
        return (0);
      }
#line 607
      ptr += 2;
#line 607
      break;
      case 6: 
#line 607
      if (end - ptr < 3L) {
#line 607
        return (-2);
      }
#line 607
      tmp___6 = (*(((struct normal_encoding  const  *)enc)->isInvalid3))(enc, ptr);
#line 607
      if (tmp___6) {
#line 607
        *nextTokPtr = ptr;
#line 607
        return (0);
      }
#line 607
      ptr += 3;
#line 607
      break;
      case 7: 
#line 607
      if (end - ptr < 4L) {
#line 607
        return (-2);
      }
#line 607
      tmp___7 = (*(((struct normal_encoding  const  *)enc)->isInvalid4))(enc, ptr);
#line 607
      if (tmp___7) {
#line 607
        *nextTokPtr = ptr;
#line 607
        return (0);
      }
#line 607
      ptr += 4;
#line 607
      break;
      case 8: 
      case 1: 
      case 0: 
#line 607
      *nextTokPtr = ptr;
#line 607
      return (0);
      case 3: 
#line 610
      tmp___8 = normal_scanRef(enc, ptr + 1, end, & ptr);
#line 610
      tok = tmp___8;
#line 611
      if (tok <= 0) {
#line 612
        if (tok == 0) {
#line 613
          *nextTokPtr = ptr;
        }
#line 614
        return (tok);
      }
#line 616
      break;
      case 2: 
#line 619
      *nextTokPtr = ptr;
#line 620
      return (0);
      default: 
#line 622
      ptr ++;
#line 623
      break;
      }
    }
#line 626
    ptr ++;
#line 627
    if ((unsigned long )ptr == (unsigned long )end) {
#line 628
      return (-1);
    }
#line 629
    switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
    case 10: 
    case 9: 
    case 21: 
#line 633
    break;
    case 17: 
#line 635
    goto sol;
    case 11: 
#line 637
    goto gt;
    default: 
#line 639
    *nextTokPtr = ptr;
#line 640
    return (0);
    }
#line 643
    while (1) {
#line 644
      ptr ++;
#line 645
      if ((unsigned long )ptr == (unsigned long )end) {
#line 646
        return (-1);
      }
#line 647
      switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
      case 29: 
#line 648
      *nextTokPtr = ptr;
#line 648
      return (0);
      case 24: 
      case 22: 
#line 648
      ptr ++;
#line 648
      break;
      case 5: 
#line 648
      if (end - ptr < 2L) {
#line 648
        return (-2);
      }
#line 648
      tmp___9 = (*(((struct normal_encoding  const  *)enc)->isNmstrt2))(enc, ptr);
#line 648
      if (! tmp___9) {
#line 648
        *nextTokPtr = ptr;
#line 648
        return (0);
      }
#line 648
      ptr += 2;
#line 648
      break;
      case 6: 
#line 648
      if (end - ptr < 3L) {
#line 648
        return (-2);
      }
#line 648
      tmp___10 = (*(((struct normal_encoding  const  *)enc)->isNmstrt3))(enc, ptr);
#line 648
      if (! tmp___10) {
#line 648
        *nextTokPtr = ptr;
#line 648
        return (0);
      }
#line 648
      ptr += 3;
#line 648
      break;
      case 7: 
#line 648
      if (end - ptr < 4L) {
#line 648
        return (-2);
      }
#line 648
      tmp___11 = (*(((struct normal_encoding  const  *)enc)->isNmstrt4))(enc, ptr);
#line 648
      if (! tmp___11) {
#line 648
        *nextTokPtr = ptr;
#line 648
        return (0);
      }
#line 648
      ptr += 4;
#line 648
      break;
      case 10: 
      case 9: 
      case 21: 
#line 650
      goto __Cont;
      gt: 
      case 11: 
#line 653
      *nextTokPtr = ptr + 1;
#line 654
      return (1);
      sol: 
      case 17: 
#line 657
      ptr ++;
#line 658
      if ((unsigned long )ptr == (unsigned long )end) {
#line 659
        return (-1);
      }
#line 660
      if (! ((int const   )*ptr == 62)) {
#line 661
        *nextTokPtr = ptr;
#line 662
        return (0);
      }
#line 664
      *nextTokPtr = ptr + 1;
#line 665
      return (3);
      default: 
#line 667
      *nextTokPtr = ptr;
#line 668
      return (0);
      }
#line 670
      break;
      __Cont: /* CIL Label */ ;
    }
#line 672
    break;
    default: 
#line 675
    *nextTokPtr = ptr;
#line 676
    return (0);
    }
  }
#line 679
  return (-1);
}
}
#line 684 "xmltok_impl.c"
static int normal_scanLt(ENCODING const   *enc , char const   *ptr , char const   *end ,
                         char const   **nextTokPtr ) 
{ 
  int hadColon ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
#line 691
  if ((unsigned long )ptr == (unsigned long )end) {
#line 692
    return (-1);
  }
#line 693
  switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
  case 29: 
#line 694
  *nextTokPtr = ptr;
#line 694
  return (0);
  case 24: 
  case 22: 
#line 694
  ptr ++;
#line 694
  break;
  case 5: 
#line 694
  if (end - ptr < 2L) {
#line 694
    return (-2);
  }
#line 694
  tmp = (*(((struct normal_encoding  const  *)enc)->isNmstrt2))(enc, ptr);
#line 694
  if (! tmp) {
#line 694
    *nextTokPtr = ptr;
#line 694
    return (0);
  }
#line 694
  ptr += 2;
#line 694
  break;
  case 6: 
#line 694
  if (end - ptr < 3L) {
#line 694
    return (-2);
  }
#line 694
  tmp___0 = (*(((struct normal_encoding  const  *)enc)->isNmstrt3))(enc, ptr);
#line 694
  if (! tmp___0) {
#line 694
    *nextTokPtr = ptr;
#line 694
    return (0);
  }
#line 694
  ptr += 3;
#line 694
  break;
  case 7: 
#line 694
  if (end - ptr < 4L) {
#line 694
    return (-2);
  }
#line 694
  tmp___1 = (*(((struct normal_encoding  const  *)enc)->isNmstrt4))(enc, ptr);
#line 694
  if (! tmp___1) {
#line 694
    *nextTokPtr = ptr;
#line 694
    return (0);
  }
#line 694
  ptr += 4;
#line 694
  break;
  case 16: 
#line 696
  ptr ++;
#line 696
  if ((unsigned long )ptr == (unsigned long )end) {
#line 697
    return (-1);
  }
#line 698
  switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
  case 27: 
#line 700
  tmp___2 = normal_scanComment(enc, ptr + 1, end, nextTokPtr);
#line 700
  return (tmp___2);
  case 20: 
#line 702
  tmp___3 = normal_scanCdataSection(enc, ptr + 1, end, nextTokPtr);
#line 702
  return (tmp___3);
  }
#line 705
  *nextTokPtr = ptr;
#line 706
  return (0);
  case 15: 
#line 708
  tmp___4 = normal_scanPi(enc, ptr + 1, end, nextTokPtr);
#line 708
  return (tmp___4);
  case 17: 
#line 710
  tmp___5 = normal_scanEndTag(enc, ptr + 1, end, nextTokPtr);
#line 710
  return (tmp___5);
  default: 
#line 712
  *nextTokPtr = ptr;
#line 713
  return (0);
  }
#line 716
  hadColon = 0;
#line 719
  while ((unsigned long )ptr != (unsigned long )end) {
#line 720
    switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
    case 29: 
#line 721
    *nextTokPtr = ptr;
#line 721
    return (0);
    case 27: 
    case 26: 
    case 25: 
    case 24: 
    case 22: 
#line 721
    ptr ++;
#line 721
    break;
    case 5: 
#line 721
    if (end - ptr < 2L) {
#line 721
      return (-2);
    }
#line 721
    tmp___6 = (*(((struct normal_encoding  const  *)enc)->isName2))(enc, ptr);
#line 721
    if (! tmp___6) {
#line 721
      *nextTokPtr = ptr;
#line 721
      return (0);
    }
#line 721
    ptr += 2;
#line 721
    break;
    case 6: 
#line 721
    if (end - ptr < 3L) {
#line 721
      return (-2);
    }
#line 721
    tmp___7 = (*(((struct normal_encoding  const  *)enc)->isName3))(enc, ptr);
#line 721
    if (! tmp___7) {
#line 721
      *nextTokPtr = ptr;
#line 721
      return (0);
    }
#line 721
    ptr += 3;
#line 721
    break;
    case 7: 
#line 721
    if (end - ptr < 4L) {
#line 721
      return (-2);
    }
#line 721
    tmp___8 = (*(((struct normal_encoding  const  *)enc)->isName4))(enc, ptr);
#line 721
    if (! tmp___8) {
#line 721
      *nextTokPtr = ptr;
#line 721
      return (0);
    }
#line 721
    ptr += 4;
#line 721
    break;
    case 23: 
#line 724
    if (hadColon) {
#line 725
      *nextTokPtr = ptr;
#line 726
      return (0);
    }
#line 728
    hadColon = 1;
#line 729
    ptr ++;
#line 730
    if ((unsigned long )ptr == (unsigned long )end) {
#line 731
      return (-1);
    }
#line 732
    switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
    case 29: 
#line 733
    *nextTokPtr = ptr;
#line 733
    return (0);
    case 24: 
    case 22: 
#line 733
    ptr ++;
#line 733
    break;
    case 5: 
#line 733
    if (end - ptr < 2L) {
#line 733
      return (-2);
    }
#line 733
    tmp___9 = (*(((struct normal_encoding  const  *)enc)->isNmstrt2))(enc, ptr);
#line 733
    if (! tmp___9) {
#line 733
      *nextTokPtr = ptr;
#line 733
      return (0);
    }
#line 733
    ptr += 2;
#line 733
    break;
    case 6: 
#line 733
    if (end - ptr < 3L) {
#line 733
      return (-2);
    }
#line 733
    tmp___10 = (*(((struct normal_encoding  const  *)enc)->isNmstrt3))(enc, ptr);
#line 733
    if (! tmp___10) {
#line 733
      *nextTokPtr = ptr;
#line 733
      return (0);
    }
#line 733
    ptr += 3;
#line 733
    break;
    case 7: 
#line 733
    if (end - ptr < 4L) {
#line 733
      return (-2);
    }
#line 733
    tmp___11 = (*(((struct normal_encoding  const  *)enc)->isNmstrt4))(enc, ptr);
#line 733
    if (! tmp___11) {
#line 733
      *nextTokPtr = ptr;
#line 733
      return (0);
    }
#line 733
    ptr += 4;
#line 733
    break;
    default: 
#line 735
    *nextTokPtr = ptr;
#line 736
    return (0);
    }
#line 738
    break;
    case 10: 
    case 9: 
    case 21: 
#line 742
    ptr ++;
#line 743
    while ((unsigned long )ptr != (unsigned long )end) {
#line 744
      switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
      case 29: 
#line 745
      *nextTokPtr = ptr;
#line 745
      return (0);
      case 24: 
      case 22: 
#line 745
      ptr ++;
#line 745
      break;
      case 5: 
#line 745
      if (end - ptr < 2L) {
#line 745
        return (-2);
      }
#line 745
      tmp___12 = (*(((struct normal_encoding  const  *)enc)->isNmstrt2))(enc, ptr);
#line 745
      if (! tmp___12) {
#line 745
        *nextTokPtr = ptr;
#line 745
        return (0);
      }
#line 745
      ptr += 2;
#line 745
      break;
      case 6: 
#line 745
      if (end - ptr < 3L) {
#line 745
        return (-2);
      }
#line 745
      tmp___13 = (*(((struct normal_encoding  const  *)enc)->isNmstrt3))(enc, ptr);
#line 745
      if (! tmp___13) {
#line 745
        *nextTokPtr = ptr;
#line 745
        return (0);
      }
#line 745
      ptr += 3;
#line 745
      break;
      case 7: 
#line 745
      if (end - ptr < 4L) {
#line 745
        return (-2);
      }
#line 745
      tmp___14 = (*(((struct normal_encoding  const  *)enc)->isNmstrt4))(enc, ptr);
#line 745
      if (! tmp___14) {
#line 745
        *nextTokPtr = ptr;
#line 745
        return (0);
      }
#line 745
      ptr += 4;
#line 745
      break;
      case 11: 
#line 747
      goto gt;
      case 17: 
#line 749
      goto sol;
      case 10: 
      case 9: 
      case 21: 
#line 751
      ptr ++;
#line 752
      continue;
      default: 
#line 754
      *nextTokPtr = ptr;
#line 755
      return (0);
      }
#line 757
      tmp___15 = normal_scanAtts(enc, ptr, end, nextTokPtr);
#line 757
      return (tmp___15);
    }
#line 759
    return (-1);
    gt: 
    case 11: 
#line 763
    *nextTokPtr = ptr + 1;
#line 764
    return (2);
    sol: 
    case 17: 
#line 767
    ptr ++;
#line 768
    if ((unsigned long )ptr == (unsigned long )end) {
#line 769
      return (-1);
    }
#line 770
    if (! ((int const   )*ptr == 62)) {
#line 771
      *nextTokPtr = ptr;
#line 772
      return (0);
    }
#line 774
    *nextTokPtr = ptr + 1;
#line 775
    return (4);
    default: 
#line 777
    *nextTokPtr = ptr;
#line 778
    return (0);
    }
  }
#line 781
  return (-1);
}
}
#line 784 "xmltok_impl.c"
static int normal_contentTok(ENCODING const   *enc , char const   *ptr , char const   *end ,
                             char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 788
  if ((unsigned long )ptr == (unsigned long )end) {
#line 789
    return (-4);
  }
#line 799
  switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
  case 2: 
#line 801
  tmp = normal_scanLt(enc, ptr + 1, end, nextTokPtr);
#line 801
  return (tmp);
  case 3: 
#line 803
  tmp___0 = normal_scanRef(enc, ptr + 1, end, nextTokPtr);
#line 803
  return (tmp___0);
  case 9: 
#line 805
  ptr ++;
#line 806
  if ((unsigned long )ptr == (unsigned long )end) {
#line 807
    return (-3);
  }
#line 808
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 809
    ptr ++;
  }
#line 810
  *nextTokPtr = ptr;
#line 811
  return (7);
  case 10: 
#line 813
  *nextTokPtr = ptr + 1;
#line 814
  return (7);
  case 4: 
#line 816
  ptr ++;
#line 817
  if ((unsigned long )ptr == (unsigned long )end) {
#line 818
    return (-5);
  }
#line 819
  if (! ((int const   )*ptr == 93)) {
#line 820
    break;
  }
#line 821
  ptr ++;
#line 822
  if ((unsigned long )ptr == (unsigned long )end) {
#line 823
    return (-5);
  }
#line 824
  if (! ((int const   )*ptr == 62)) {
#line 825
    ptr --;
#line 826
    break;
  }
#line 828
  *nextTokPtr = ptr;
#line 829
  return (0);
  case 5: 
#line 830
  if (end - ptr < 2L) {
#line 830
    return (-2);
  }
#line 830
  tmp___1 = (*(((struct normal_encoding  const  *)enc)->isInvalid2))(enc, ptr);
#line 830
  if (tmp___1) {
#line 830
    *nextTokPtr = ptr;
#line 830
    return (0);
  }
#line 830
  ptr += 2;
#line 830
  break;
  case 6: 
#line 830
  if (end - ptr < 3L) {
#line 830
    return (-2);
  }
#line 830
  tmp___2 = (*(((struct normal_encoding  const  *)enc)->isInvalid3))(enc, ptr);
#line 830
  if (tmp___2) {
#line 830
    *nextTokPtr = ptr;
#line 830
    return (0);
  }
#line 830
  ptr += 3;
#line 830
  break;
  case 7: 
#line 830
  if (end - ptr < 4L) {
#line 830
    return (-2);
  }
#line 830
  tmp___3 = (*(((struct normal_encoding  const  *)enc)->isInvalid4))(enc, ptr);
#line 830
  if (tmp___3) {
#line 830
    *nextTokPtr = ptr;
#line 830
    return (0);
  }
#line 830
  ptr += 4;
#line 830
  break;
  case 8: 
  case 1: 
  case 0: 
#line 830
  *nextTokPtr = ptr;
#line 830
  return (0);
  default: 
#line 832
  ptr ++;
#line 833
  break;
  }
#line 835
  while ((unsigned long )ptr != (unsigned long )end) {
#line 836
    switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
    case 5: 
#line 845
    if (end - ptr < 2L) {
#line 845
      *nextTokPtr = ptr;
#line 845
      return (6);
    } else {
#line 845
      tmp___4 = (*(((struct normal_encoding  const  *)enc)->isInvalid2))(enc, ptr);
#line 845
      if (tmp___4) {
#line 845
        *nextTokPtr = ptr;
#line 845
        return (6);
      }
    }
#line 845
    ptr += 2;
#line 845
    break;
    case 6: 
#line 845
    if (end - ptr < 3L) {
#line 845
      *nextTokPtr = ptr;
#line 845
      return (6);
    } else {
#line 845
      tmp___5 = (*(((struct normal_encoding  const  *)enc)->isInvalid3))(enc, ptr);
#line 845
      if (tmp___5) {
#line 845
        *nextTokPtr = ptr;
#line 845
        return (6);
      }
    }
#line 845
    ptr += 3;
#line 845
    break;
    case 7: 
#line 845
    if (end - ptr < 4L) {
#line 845
      *nextTokPtr = ptr;
#line 845
      return (6);
    } else {
#line 845
      tmp___6 = (*(((struct normal_encoding  const  *)enc)->isInvalid4))(enc, ptr);
#line 845
      if (tmp___6) {
#line 845
        *nextTokPtr = ptr;
#line 845
        return (6);
      }
    }
#line 845
    ptr += 4;
#line 845
    break;
    case 4: 
#line 848
    if ((unsigned long )(ptr + 1) != (unsigned long )end) {
#line 849
      if (! ((int const   )*(ptr + 1) == 93)) {
#line 850
        ptr ++;
#line 851
        break;
      }
#line 853
      if ((unsigned long )(ptr + 2) != (unsigned long )end) {
#line 854
        if (! ((int const   )*(ptr + 2) == 62)) {
#line 855
          ptr ++;
#line 856
          break;
        }
#line 858
        *nextTokPtr = ptr + 2;
#line 859
        return (0);
      }
    }
    case 10: 
    case 9: 
    case 8: 
    case 1: 
    case 0: 
    case 2: 
    case 3: 
#line 870
    *nextTokPtr = ptr;
#line 871
    return (6);
    default: 
#line 873
    ptr ++;
#line 874
    break;
    }
  }
#line 877
  *nextTokPtr = ptr;
#line 878
  return (6);
}
}
#line 883 "xmltok_impl.c"
static int normal_scanPercent(ENCODING const   *enc , char const   *ptr , char const   *end ,
                              char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 887
  if ((unsigned long )ptr == (unsigned long )end) {
#line 888
    return (-1);
  }
#line 889
  switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
  case 29: 
#line 890
  *nextTokPtr = ptr;
#line 890
  return (0);
  case 24: 
  case 22: 
#line 890
  ptr ++;
#line 890
  break;
  case 5: 
#line 890
  if (end - ptr < 2L) {
#line 890
    return (-2);
  }
#line 890
  tmp = (*(((struct normal_encoding  const  *)enc)->isNmstrt2))(enc, ptr);
#line 890
  if (! tmp) {
#line 890
    *nextTokPtr = ptr;
#line 890
    return (0);
  }
#line 890
  ptr += 2;
#line 890
  break;
  case 6: 
#line 890
  if (end - ptr < 3L) {
#line 890
    return (-2);
  }
#line 890
  tmp___0 = (*(((struct normal_encoding  const  *)enc)->isNmstrt3))(enc, ptr);
#line 890
  if (! tmp___0) {
#line 890
    *nextTokPtr = ptr;
#line 890
    return (0);
  }
#line 890
  ptr += 3;
#line 890
  break;
  case 7: 
#line 890
  if (end - ptr < 4L) {
#line 890
    return (-2);
  }
#line 890
  tmp___1 = (*(((struct normal_encoding  const  *)enc)->isNmstrt4))(enc, ptr);
#line 890
  if (! tmp___1) {
#line 890
    *nextTokPtr = ptr;
#line 890
    return (0);
  }
#line 890
  ptr += 4;
#line 890
  break;
  case 30: 
  case 9: 
  case 10: 
  case 21: 
#line 892
  *nextTokPtr = ptr;
#line 893
  return (22);
  default: 
#line 895
  *nextTokPtr = ptr;
#line 896
  return (0);
  }
#line 898
  while ((unsigned long )ptr != (unsigned long )end) {
#line 899
    switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
    case 29: 
#line 900
    *nextTokPtr = ptr;
#line 900
    return (0);
    case 27: 
    case 26: 
    case 25: 
    case 24: 
    case 22: 
#line 900
    ptr ++;
#line 900
    break;
    case 5: 
#line 900
    if (end - ptr < 2L) {
#line 900
      return (-2);
    }
#line 900
    tmp___2 = (*(((struct normal_encoding  const  *)enc)->isName2))(enc, ptr);
#line 900
    if (! tmp___2) {
#line 900
      *nextTokPtr = ptr;
#line 900
      return (0);
    }
#line 900
    ptr += 2;
#line 900
    break;
    case 6: 
#line 900
    if (end - ptr < 3L) {
#line 900
      return (-2);
    }
#line 900
    tmp___3 = (*(((struct normal_encoding  const  *)enc)->isName3))(enc, ptr);
#line 900
    if (! tmp___3) {
#line 900
      *nextTokPtr = ptr;
#line 900
      return (0);
    }
#line 900
    ptr += 3;
#line 900
    break;
    case 7: 
#line 900
    if (end - ptr < 4L) {
#line 900
      return (-2);
    }
#line 900
    tmp___4 = (*(((struct normal_encoding  const  *)enc)->isName4))(enc, ptr);
#line 900
    if (! tmp___4) {
#line 900
      *nextTokPtr = ptr;
#line 900
      return (0);
    }
#line 900
    ptr += 4;
#line 900
    break;
    case 18: 
#line 902
    *nextTokPtr = ptr + 1;
#line 903
    return (28);
    default: 
#line 905
    *nextTokPtr = ptr;
#line 906
    return (0);
    }
  }
#line 909
  return (-1);
}
}
#line 912 "xmltok_impl.c"
static int normal_scanPoundName(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 916
  if ((unsigned long )ptr == (unsigned long )end) {
#line 917
    return (-1);
  }
#line 918
  switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
  case 29: 
#line 919
  *nextTokPtr = ptr;
#line 919
  return (0);
  case 24: 
  case 22: 
#line 919
  ptr ++;
#line 919
  break;
  case 5: 
#line 919
  if (end - ptr < 2L) {
#line 919
    return (-2);
  }
#line 919
  tmp = (*(((struct normal_encoding  const  *)enc)->isNmstrt2))(enc, ptr);
#line 919
  if (! tmp) {
#line 919
    *nextTokPtr = ptr;
#line 919
    return (0);
  }
#line 919
  ptr += 2;
#line 919
  break;
  case 6: 
#line 919
  if (end - ptr < 3L) {
#line 919
    return (-2);
  }
#line 919
  tmp___0 = (*(((struct normal_encoding  const  *)enc)->isNmstrt3))(enc, ptr);
#line 919
  if (! tmp___0) {
#line 919
    *nextTokPtr = ptr;
#line 919
    return (0);
  }
#line 919
  ptr += 3;
#line 919
  break;
  case 7: 
#line 919
  if (end - ptr < 4L) {
#line 919
    return (-2);
  }
#line 919
  tmp___1 = (*(((struct normal_encoding  const  *)enc)->isNmstrt4))(enc, ptr);
#line 919
  if (! tmp___1) {
#line 919
    *nextTokPtr = ptr;
#line 919
    return (0);
  }
#line 919
  ptr += 4;
#line 919
  break;
  default: 
#line 921
  *nextTokPtr = ptr;
#line 922
  return (0);
  }
#line 924
  while ((unsigned long )ptr != (unsigned long )end) {
#line 925
    switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
    case 29: 
#line 926
    *nextTokPtr = ptr;
#line 926
    return (0);
    case 27: 
    case 26: 
    case 25: 
    case 24: 
    case 22: 
#line 926
    ptr ++;
#line 926
    break;
    case 5: 
#line 926
    if (end - ptr < 2L) {
#line 926
      return (-2);
    }
#line 926
    tmp___2 = (*(((struct normal_encoding  const  *)enc)->isName2))(enc, ptr);
#line 926
    if (! tmp___2) {
#line 926
      *nextTokPtr = ptr;
#line 926
      return (0);
    }
#line 926
    ptr += 2;
#line 926
    break;
    case 6: 
#line 926
    if (end - ptr < 3L) {
#line 926
      return (-2);
    }
#line 926
    tmp___3 = (*(((struct normal_encoding  const  *)enc)->isName3))(enc, ptr);
#line 926
    if (! tmp___3) {
#line 926
      *nextTokPtr = ptr;
#line 926
      return (0);
    }
#line 926
    ptr += 3;
#line 926
    break;
    case 7: 
#line 926
    if (end - ptr < 4L) {
#line 926
      return (-2);
    }
#line 926
    tmp___4 = (*(((struct normal_encoding  const  *)enc)->isName4))(enc, ptr);
#line 926
    if (! tmp___4) {
#line 926
      *nextTokPtr = ptr;
#line 926
      return (0);
    }
#line 926
    ptr += 4;
#line 926
    break;
    case 36: 
    case 30: 
    case 11: 
    case 32: 
    case 21: 
    case 10: 
    case 9: 
#line 929
    *nextTokPtr = ptr;
#line 930
    return (20);
    default: 
#line 932
    *nextTokPtr = ptr;
#line 933
    return (0);
    }
  }
#line 936
  return (-20);
}
}
#line 939 "xmltok_impl.c"
static int normal_scanLit(int open , ENCODING const   *enc , char const   *ptr , char const   *end ,
                          char const   **nextTokPtr ) 
{ 
  int t ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 944
  while ((unsigned long )ptr != (unsigned long )end) {
#line 945
    t = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
#line 946
    switch (t) {
    case 5: 
#line 947
    if (end - ptr < 2L) {
#line 947
      return (-2);
    }
#line 947
    tmp = (*(((struct normal_encoding  const  *)enc)->isInvalid2))(enc, ptr);
#line 947
    if (tmp) {
#line 947
      *nextTokPtr = ptr;
#line 947
      return (0);
    }
#line 947
    ptr += 2;
#line 947
    break;
    case 6: 
#line 947
    if (end - ptr < 3L) {
#line 947
      return (-2);
    }
#line 947
    tmp___0 = (*(((struct normal_encoding  const  *)enc)->isInvalid3))(enc, ptr);
#line 947
    if (tmp___0) {
#line 947
      *nextTokPtr = ptr;
#line 947
      return (0);
    }
#line 947
    ptr += 3;
#line 947
    break;
    case 7: 
#line 947
    if (end - ptr < 4L) {
#line 947
      return (-2);
    }
#line 947
    tmp___1 = (*(((struct normal_encoding  const  *)enc)->isInvalid4))(enc, ptr);
#line 947
    if (tmp___1) {
#line 947
      *nextTokPtr = ptr;
#line 947
      return (0);
    }
#line 947
    ptr += 4;
#line 947
    break;
    case 8: 
    case 1: 
    case 0: 
#line 947
    *nextTokPtr = ptr;
#line 947
    return (0);
    case 13: 
    case 12: 
#line 950
    ptr ++;
#line 951
    if (t != open) {
#line 952
      break;
    }
#line 953
    if ((unsigned long )ptr == (unsigned long )end) {
#line 954
      return (-27);
    }
#line 955
    *nextTokPtr = ptr;
#line 956
    switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
    case 20: 
    case 30: 
    case 11: 
    case 10: 
    case 9: 
    case 21: 
#line 959
    return (27);
    default: 
#line 961
    return (0);
    }
    default: 
#line 964
    ptr ++;
#line 965
    break;
    }
  }
#line 968
  return (-1);
}
}
#line 971 "xmltok_impl.c"
static int normal_prologTok(ENCODING const   *enc , char const   *ptr , char const   *end ,
                            char const   **nextTokPtr ) 
{ 
  int tok ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 976
  if ((unsigned long )ptr == (unsigned long )end) {
#line 977
    return (-4);
  }
#line 987
  switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
  case 12: 
#line 989
  tmp = normal_scanLit(12, enc, ptr + 1, end, nextTokPtr);
#line 989
  return (tmp);
  case 13: 
#line 991
  tmp___0 = normal_scanLit(13, enc, ptr + 1, end, nextTokPtr);
#line 991
  return (tmp___0);
  case 2: 
#line 994
  ptr ++;
#line 995
  if ((unsigned long )ptr == (unsigned long )end) {
#line 996
    return (-1);
  }
#line 997
  switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
  case 16: 
#line 999
  tmp___1 = normal_scanDecl(enc, ptr + 1, end, nextTokPtr);
#line 999
  return (tmp___1);
  case 15: 
#line 1001
  tmp___2 = normal_scanPi(enc, ptr + 1, end, nextTokPtr);
#line 1001
  return (tmp___2);
  case 7: 
  case 6: 
  case 5: 
  case 29: 
  case 24: 
  case 22: 
#line 1008
  *nextTokPtr = ptr - 1;
#line 1009
  return (29);
  }
#line 1011
  *nextTokPtr = ptr;
#line 1012
  return (0);
  case 9: 
#line 1015
  if ((unsigned long )(ptr + 1) == (unsigned long )end) {
#line 1016
    *nextTokPtr = end;
#line 1018
    return (-15);
  }
  case 10: 
  case 21: 
#line 1022
  while (1) {
#line 1023
    ptr ++;
#line 1024
    if ((unsigned long )ptr == (unsigned long )end) {
#line 1025
      break;
    }
#line 1026
    switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
    case 10: 
    case 21: 
#line 1028
    break;
    case 9: 
#line 1031
    if ((unsigned long )(ptr + 1) != (unsigned long )end) {
#line 1032
      break;
    }
    default: 
#line 1035
    *nextTokPtr = ptr;
#line 1036
    return (15);
    }
  }
#line 1039
  *nextTokPtr = ptr;
#line 1040
  return (15);
  case 30: 
#line 1042
  tmp___3 = normal_scanPercent(enc, ptr + 1, end, nextTokPtr);
#line 1042
  return (tmp___3);
  case 35: 
#line 1044
  *nextTokPtr = ptr + 1;
#line 1045
  return (38);
  case 20: 
#line 1047
  *nextTokPtr = ptr + 1;
#line 1048
  return (25);
  case 4: 
#line 1050
  ptr ++;
#line 1051
  if ((unsigned long )ptr == (unsigned long )end) {
#line 1052
    return (-26);
  }
#line 1053
  if ((int const   )*ptr == 93) {
#line 1054
    if ((unsigned long )(ptr + 1) == (unsigned long )end) {
#line 1055
      return (-1);
    }
#line 1056
    if ((int const   )*(ptr + 1) == 62) {
#line 1057
      *nextTokPtr = ptr + 2;
#line 1058
      return (34);
    }
  }
#line 1061
  *nextTokPtr = ptr;
#line 1062
  return (26);
  case 31: 
#line 1064
  *nextTokPtr = ptr + 1;
#line 1065
  return (23);
  case 32: 
#line 1067
  ptr ++;
#line 1068
  if ((unsigned long )ptr == (unsigned long )end) {
#line 1069
    return (-24);
  }
#line 1070
  switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
  case 33: 
#line 1072
  *nextTokPtr = ptr + 1;
#line 1073
  return (36);
  case 15: 
#line 1075
  *nextTokPtr = ptr + 1;
#line 1076
  return (35);
  case 34: 
#line 1078
  *nextTokPtr = ptr + 1;
#line 1079
  return (37);
  case 32: 
  case 36: 
  case 35: 
  case 11: 
  case 21: 
  case 10: 
  case 9: 
#line 1083
  *nextTokPtr = ptr;
#line 1084
  return (24);
  }
#line 1086
  *nextTokPtr = ptr;
#line 1087
  return (0);
  case 36: 
#line 1089
  *nextTokPtr = ptr + 1;
#line 1090
  return (21);
  case 11: 
#line 1092
  *nextTokPtr = ptr + 1;
#line 1093
  return (17);
  case 19: 
#line 1095
  tmp___4 = normal_scanPoundName(enc, ptr + 1, end, nextTokPtr);
#line 1095
  return (tmp___4);
  case 5: 
#line 1112
  if (end - ptr < 2L) {
#line 1112
    return (-2);
  }
#line 1112
  tmp___5 = (*(((struct normal_encoding  const  *)enc)->isNmstrt2))(enc, ptr);
#line 1112
  if (tmp___5) {
#line 1112
    ptr += 2;
#line 1112
    tok = 18;
#line 1112
    break;
  }
#line 1112
  tmp___6 = (*(((struct normal_encoding  const  *)enc)->isName2))(enc, ptr);
#line 1112
  if (tmp___6) {
#line 1112
    ptr += 2;
#line 1112
    tok = 19;
#line 1112
    break;
  }
#line 1112
  *nextTokPtr = ptr;
#line 1112
  return (0);
  case 6: 
#line 1112
  if (end - ptr < 3L) {
#line 1112
    return (-2);
  }
#line 1112
  tmp___7 = (*(((struct normal_encoding  const  *)enc)->isNmstrt3))(enc, ptr);
#line 1112
  if (tmp___7) {
#line 1112
    ptr += 3;
#line 1112
    tok = 18;
#line 1112
    break;
  }
#line 1112
  tmp___8 = (*(((struct normal_encoding  const  *)enc)->isName3))(enc, ptr);
#line 1112
  if (tmp___8) {
#line 1112
    ptr += 3;
#line 1112
    tok = 19;
#line 1112
    break;
  }
#line 1112
  *nextTokPtr = ptr;
#line 1112
  return (0);
  case 7: 
#line 1112
  if (end - ptr < 4L) {
#line 1112
    return (-2);
  }
#line 1112
  tmp___9 = (*(((struct normal_encoding  const  *)enc)->isNmstrt4))(enc, ptr);
#line 1112
  if (tmp___9) {
#line 1112
    ptr += 4;
#line 1112
    tok = 18;
#line 1112
    break;
  }
#line 1112
  tmp___10 = (*(((struct normal_encoding  const  *)enc)->isName4))(enc, ptr);
#line 1112
  if (tmp___10) {
#line 1112
    ptr += 4;
#line 1112
    tok = 19;
#line 1112
    break;
  }
#line 1112
  *nextTokPtr = ptr;
#line 1112
  return (0);
  case 24: 
  case 22: 
#line 1116
  tok = 18;
#line 1117
  ptr ++;
#line 1118
  break;
  case 23: 
  case 27: 
  case 26: 
  case 25: 
#line 1125
  tok = 19;
#line 1126
  ptr ++;
#line 1127
  break;
  case 29: ;
  default: 
#line 1141
  *nextTokPtr = ptr;
#line 1142
  return (0);
  }
#line 1144
  while ((unsigned long )ptr != (unsigned long )end) {
#line 1145
    switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
    case 29: 
#line 1146
    *nextTokPtr = ptr;
#line 1146
    return (0);
    case 27: 
    case 26: 
    case 25: 
    case 24: 
    case 22: 
#line 1146
    ptr ++;
#line 1146
    break;
    case 5: 
#line 1146
    if (end - ptr < 2L) {
#line 1146
      return (-2);
    }
#line 1146
    tmp___11 = (*(((struct normal_encoding  const  *)enc)->isName2))(enc, ptr);
#line 1146
    if (! tmp___11) {
#line 1146
      *nextTokPtr = ptr;
#line 1146
      return (0);
    }
#line 1146
    ptr += 2;
#line 1146
    break;
    case 6: 
#line 1146
    if (end - ptr < 3L) {
#line 1146
      return (-2);
    }
#line 1146
    tmp___12 = (*(((struct normal_encoding  const  *)enc)->isName3))(enc, ptr);
#line 1146
    if (! tmp___12) {
#line 1146
      *nextTokPtr = ptr;
#line 1146
      return (0);
    }
#line 1146
    ptr += 3;
#line 1146
    break;
    case 7: 
#line 1146
    if (end - ptr < 4L) {
#line 1146
      return (-2);
    }
#line 1146
    tmp___13 = (*(((struct normal_encoding  const  *)enc)->isName4))(enc, ptr);
#line 1146
    if (! tmp___13) {
#line 1146
      *nextTokPtr = ptr;
#line 1146
      return (0);
    }
#line 1146
    ptr += 4;
#line 1146
    break;
    case 10: 
    case 9: 
    case 21: 
    case 30: 
    case 20: 
    case 36: 
    case 35: 
    case 32: 
    case 11: 
#line 1150
    *nextTokPtr = ptr;
#line 1151
    return (tok);
    case 23: 
#line 1154
    ptr ++;
#line 1155
    switch (tok) {
    case 18: 
#line 1157
    if ((unsigned long )ptr == (unsigned long )end) {
#line 1158
      return (-1);
    }
#line 1159
    tok = 41;
#line 1160
    switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
    case 29: 
#line 1161
    *nextTokPtr = ptr;
#line 1161
    return (0);
    case 27: 
    case 26: 
    case 25: 
    case 24: 
    case 22: 
#line 1161
    ptr ++;
#line 1161
    break;
    case 5: 
#line 1161
    if (end - ptr < 2L) {
#line 1161
      return (-2);
    }
#line 1161
    tmp___14 = (*(((struct normal_encoding  const  *)enc)->isName2))(enc, ptr);
#line 1161
    if (! tmp___14) {
#line 1161
      *nextTokPtr = ptr;
#line 1161
      return (0);
    }
#line 1161
    ptr += 2;
#line 1161
    break;
    case 6: 
#line 1161
    if (end - ptr < 3L) {
#line 1161
      return (-2);
    }
#line 1161
    tmp___15 = (*(((struct normal_encoding  const  *)enc)->isName3))(enc, ptr);
#line 1161
    if (! tmp___15) {
#line 1161
      *nextTokPtr = ptr;
#line 1161
      return (0);
    }
#line 1161
    ptr += 3;
#line 1161
    break;
    case 7: 
#line 1161
    if (end - ptr < 4L) {
#line 1161
      return (-2);
    }
#line 1161
    tmp___16 = (*(((struct normal_encoding  const  *)enc)->isName4))(enc, ptr);
#line 1161
    if (! tmp___16) {
#line 1161
      *nextTokPtr = ptr;
#line 1161
      return (0);
    }
#line 1161
    ptr += 4;
#line 1161
    break;
    default: 
#line 1163
    tok = 19;
#line 1164
    break;
    }
#line 1166
    break;
    case 41: 
#line 1168
    tok = 19;
#line 1169
    break;
    }
#line 1171
    break;
    case 34: 
#line 1174
    if (tok == 19) {
#line 1175
      *nextTokPtr = ptr;
#line 1176
      return (0);
    }
#line 1178
    *nextTokPtr = ptr + 1;
#line 1179
    return (32);
    case 33: 
#line 1181
    if (tok == 19) {
#line 1182
      *nextTokPtr = ptr;
#line 1183
      return (0);
    }
#line 1185
    *nextTokPtr = ptr + 1;
#line 1186
    return (31);
    case 15: 
#line 1188
    if (tok == 19) {
#line 1189
      *nextTokPtr = ptr;
#line 1190
      return (0);
    }
#line 1192
    *nextTokPtr = ptr + 1;
#line 1193
    return (30);
    default: 
#line 1195
    *nextTokPtr = ptr;
#line 1196
    return (0);
    }
  }
#line 1199
  return (- tok);
}
}
#line 1202 "xmltok_impl.c"
static int normal_attributeValueTok(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                    char const   **nextTokPtr ) 
{ 
  char const   *start ;
  int tmp ;

  {
#line 1207
  if ((unsigned long )ptr == (unsigned long )end) {
#line 1208
    return (-4);
  }
#line 1209
  start = ptr;
#line 1210
  while ((unsigned long )ptr != (unsigned long )end) {
#line 1211
    switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
    case 5: 
#line 1214
    ptr += 2;
#line 1214
    break;
    case 6: 
#line 1214
    ptr += 3;
#line 1214
    break;
    case 7: 
#line 1214
    ptr += 4;
#line 1214
    break;
    case 3: 
#line 1217
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1218
      tmp = normal_scanRef(enc, ptr + 1, end, nextTokPtr);
#line 1218
      return (tmp);
    }
#line 1219
    *nextTokPtr = ptr;
#line 1220
    return (6);
    case 2: 
#line 1223
    *nextTokPtr = ptr;
#line 1224
    return (0);
    case 10: 
#line 1226
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1227
      *nextTokPtr = ptr + 1;
#line 1228
      return (7);
    }
#line 1230
    *nextTokPtr = ptr;
#line 1231
    return (6);
    case 9: 
#line 1233
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1234
      ptr ++;
#line 1235
      if ((unsigned long )ptr == (unsigned long )end) {
#line 1236
        return (-3);
      }
#line 1237
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 1238
        ptr ++;
      }
#line 1239
      *nextTokPtr = ptr;
#line 1240
      return (7);
    }
#line 1242
    *nextTokPtr = ptr;
#line 1243
    return (6);
    case 21: 
#line 1245
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1246
      *nextTokPtr = ptr + 1;
#line 1247
      return (39);
    }
#line 1249
    *nextTokPtr = ptr;
#line 1250
    return (6);
    default: 
#line 1252
    ptr ++;
#line 1253
    break;
    }
  }
#line 1256
  *nextTokPtr = ptr;
#line 1257
  return (6);
}
}
#line 1260 "xmltok_impl.c"
static int normal_entityValueTok(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                 char const   **nextTokPtr ) 
{ 
  char const   *start ;
  int tmp ;
  int tok ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1265
  if ((unsigned long )ptr == (unsigned long )end) {
#line 1266
    return (-4);
  }
#line 1267
  start = ptr;
#line 1268
  while ((unsigned long )ptr != (unsigned long )end) {
#line 1269
    switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
    case 5: 
#line 1272
    ptr += 2;
#line 1272
    break;
    case 6: 
#line 1272
    ptr += 3;
#line 1272
    break;
    case 7: 
#line 1272
    ptr += 4;
#line 1272
    break;
    case 3: 
#line 1275
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1276
      tmp = normal_scanRef(enc, ptr + 1, end, nextTokPtr);
#line 1276
      return (tmp);
    }
#line 1277
    *nextTokPtr = ptr;
#line 1278
    return (6);
    case 30: 
#line 1280
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1281
      tmp___0 = normal_scanPercent(enc, ptr + 1, end, nextTokPtr);
#line 1281
      tok = tmp___0;
#line 1283
      if (tok == 22) {
#line 1283
        tmp___1 = 0;
      } else {
#line 1283
        tmp___1 = tok;
      }
#line 1283
      return (tmp___1);
    }
#line 1285
    *nextTokPtr = ptr;
#line 1286
    return (6);
    case 10: 
#line 1288
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1289
      *nextTokPtr = ptr + 1;
#line 1290
      return (7);
    }
#line 1292
    *nextTokPtr = ptr;
#line 1293
    return (6);
    case 9: 
#line 1295
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1296
      ptr ++;
#line 1297
      if ((unsigned long )ptr == (unsigned long )end) {
#line 1298
        return (-3);
      }
#line 1299
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 1300
        ptr ++;
      }
#line 1301
      *nextTokPtr = ptr;
#line 1302
      return (7);
    }
#line 1304
    *nextTokPtr = ptr;
#line 1305
    return (6);
    default: 
#line 1307
    ptr ++;
#line 1308
    break;
    }
  }
#line 1311
  *nextTokPtr = ptr;
#line 1312
  return (6);
}
}
#line 1317 "xmltok_impl.c"
static int normal_ignoreSectionTok(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                   char const   **nextTokPtr ) 
{ 
  int level ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1321
  level = 0;
#line 1329
  while ((unsigned long )ptr != (unsigned long )end) {
#line 1330
    switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
    case 5: 
#line 1331
    if (end - ptr < 2L) {
#line 1331
      return (-2);
    }
#line 1331
    tmp = (*(((struct normal_encoding  const  *)enc)->isInvalid2))(enc, ptr);
#line 1331
    if (tmp) {
#line 1331
      *nextTokPtr = ptr;
#line 1331
      return (0);
    }
#line 1331
    ptr += 2;
#line 1331
    break;
    case 6: 
#line 1331
    if (end - ptr < 3L) {
#line 1331
      return (-2);
    }
#line 1331
    tmp___0 = (*(((struct normal_encoding  const  *)enc)->isInvalid3))(enc, ptr);
#line 1331
    if (tmp___0) {
#line 1331
      *nextTokPtr = ptr;
#line 1331
      return (0);
    }
#line 1331
    ptr += 3;
#line 1331
    break;
    case 7: 
#line 1331
    if (end - ptr < 4L) {
#line 1331
      return (-2);
    }
#line 1331
    tmp___1 = (*(((struct normal_encoding  const  *)enc)->isInvalid4))(enc, ptr);
#line 1331
    if (tmp___1) {
#line 1331
      *nextTokPtr = ptr;
#line 1331
      return (0);
    }
#line 1331
    ptr += 4;
#line 1331
    break;
    case 8: 
    case 1: 
    case 0: 
#line 1331
    *nextTokPtr = ptr;
#line 1331
    return (0);
    case 2: 
#line 1333
    ptr ++;
#line 1333
    if ((unsigned long )ptr == (unsigned long )end) {
#line 1334
      return (-1);
    }
#line 1335
    if ((int const   )*ptr == 33) {
#line 1336
      ptr ++;
#line 1336
      if ((unsigned long )ptr == (unsigned long )end) {
#line 1337
        return (-1);
      }
#line 1338
      if ((int const   )*ptr == 91) {
#line 1339
        level ++;
#line 1340
        ptr ++;
      }
    }
#line 1343
    break;
    case 4: 
#line 1345
    ptr ++;
#line 1345
    if ((unsigned long )ptr == (unsigned long )end) {
#line 1346
      return (-1);
    }
#line 1347
    if ((int const   )*ptr == 93) {
#line 1348
      ptr ++;
#line 1348
      if ((unsigned long )ptr == (unsigned long )end) {
#line 1349
        return (-1);
      }
#line 1350
      if ((int const   )*ptr == 62) {
#line 1351
        ptr ++;
#line 1352
        if (level == 0) {
#line 1353
          *nextTokPtr = ptr;
#line 1354
          return (42);
        }
#line 1356
        level --;
      }
    }
#line 1359
    break;
    default: 
#line 1361
    ptr ++;
#line 1362
    break;
    }
  }
#line 1365
  return (-1);
}
}
#line 1370 "xmltok_impl.c"
static int normal_isPublicId(ENCODING const   *enc , char const   *ptr , char const   *end ,
                             char const   **badPtr ) 
{ 


  {
#line 1374
  ptr ++;
#line 1375
  end --;
#line 1376
  while ((unsigned long )ptr != (unsigned long )end) {
#line 1377
    switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
    case 23: 
    case 19: 
    case 30: 
    case 33: 
    case 16: 
    case 18: 
    case 10: 
    case 9: 
    case 15: 
    case 14: 
    case 17: 
    case 35: 
    case 34: 
    case 32: 
    case 31: 
    case 13: 
    case 27: 
    case 24: 
    case 25: 
#line 1399
    break;
    case 21: 
#line 1401
    if ((int const   )*ptr == 9) {
#line 1402
      *badPtr = ptr;
#line 1403
      return (0);
    }
#line 1405
    break;
    case 22: 
    case 26: 
#line 1408
    if (! ((int const   )*ptr & -128)) {
#line 1409
      break;
    }
    default: 
#line 1411
    switch ((int const   )*ptr) {
    case 64: 
    case 36: 
#line 1414
    break;
    default: 
#line 1416
    *badPtr = ptr;
#line 1417
    return (0);
    }
#line 1419
    break;
    }
#line 1376
    ptr ++;
  }
#line 1422
  return (1);
}
}
#line 1430 "xmltok_impl.c"
static int normal_getAtts(ENCODING const   *enc , char const   *ptr , int attsMax ,
                          ATTRIBUTE *atts ) 
{ 
  enum __anonenum_state_81194955 state ;
  int nAtts ;
  int open ;

  {
#line 1434
  state = (enum __anonenum_state_81194955 )1;
#line 1435
  nAtts = 0;
#line 1436
  open = 0;
#line 1439
  ptr ++;
#line 1439
  while (1) {
#line 1440
    switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
    case 5: 
#line 1451
    if ((unsigned int )state == 0U) {
#line 1451
      if (nAtts < attsMax) {
#line 1451
        (atts + nAtts)->name = ptr;
#line 1451
        (atts + nAtts)->normalized = (char)1;
      }
#line 1451
      state = (enum __anonenum_state_81194955 )1;
    }
#line 1451
    ptr ++;
#line 1451
    break;
    case 6: 
#line 1451
    if ((unsigned int )state == 0U) {
#line 1451
      if (nAtts < attsMax) {
#line 1451
        (atts + nAtts)->name = ptr;
#line 1451
        (atts + nAtts)->normalized = (char)1;
      }
#line 1451
      state = (enum __anonenum_state_81194955 )1;
    }
#line 1451
    ptr += 2;
#line 1451
    break;
    case 7: 
#line 1451
    if ((unsigned int )state == 0U) {
#line 1451
      if (nAtts < attsMax) {
#line 1451
        (atts + nAtts)->name = ptr;
#line 1451
        (atts + nAtts)->normalized = (char)1;
      }
#line 1451
      state = (enum __anonenum_state_81194955 )1;
    }
#line 1451
    ptr += 3;
#line 1451
    break;
    case 24: 
    case 22: 
    case 29: 
#line 1456
    if ((unsigned int )state == 0U) {
#line 1456
      if (nAtts < attsMax) {
#line 1456
        (atts + nAtts)->name = ptr;
#line 1456
        (atts + nAtts)->normalized = (char)1;
      }
#line 1456
      state = (enum __anonenum_state_81194955 )1;
    }
#line 1457
    break;
    case 12: 
#line 1460
    if ((unsigned int )state != 2U) {
#line 1461
      if (nAtts < attsMax) {
#line 1462
        (atts + nAtts)->valuePtr = ptr + 1;
      }
#line 1463
      state = (enum __anonenum_state_81194955 )2;
#line 1464
      open = 12;
    } else
#line 1466
    if (open == 12) {
#line 1467
      state = (enum __anonenum_state_81194955 )0;
#line 1468
      if (nAtts < attsMax) {
#line 1469
        (atts + nAtts)->valueEnd = ptr;
      }
#line 1470
      nAtts ++;
    }
#line 1472
    break;
    case 13: 
#line 1474
    if ((unsigned int )state != 2U) {
#line 1475
      if (nAtts < attsMax) {
#line 1476
        (atts + nAtts)->valuePtr = ptr + 1;
      }
#line 1477
      state = (enum __anonenum_state_81194955 )2;
#line 1478
      open = 13;
    } else
#line 1480
    if (open == 13) {
#line 1481
      state = (enum __anonenum_state_81194955 )0;
#line 1482
      if (nAtts < attsMax) {
#line 1483
        (atts + nAtts)->valueEnd = ptr;
      }
#line 1484
      nAtts ++;
    }
#line 1486
    break;
    case 3: 
#line 1488
    if (nAtts < attsMax) {
#line 1489
      (atts + nAtts)->normalized = (char)0;
    }
#line 1490
    break;
    case 21: 
#line 1492
    if ((unsigned int )state == 1U) {
#line 1493
      state = (enum __anonenum_state_81194955 )0;
    } else
#line 1494
    if ((unsigned int )state == 2U) {
#line 1494
      if (nAtts < attsMax) {
#line 1494
        if ((atts + nAtts)->normalized) {
#line 1494
          if ((unsigned long )ptr == (unsigned long )(atts + nAtts)->valuePtr) {
#line 1501
            (atts + nAtts)->normalized = (char)0;
          } else
#line 1494
          if ((int const   )*ptr != 32) {
#line 1501
            (atts + nAtts)->normalized = (char)0;
          } else
#line 1494
          if ((int const   )*(ptr + 1) == 32) {
#line 1501
            (atts + nAtts)->normalized = (char)0;
          } else
#line 1494
          if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)] == open) {
#line 1501
            (atts + nAtts)->normalized = (char)0;
          }
        }
      }
    }
#line 1502
    break;
    case 10: 
    case 9: 
#line 1506
    if ((unsigned int )state == 1U) {
#line 1507
      state = (enum __anonenum_state_81194955 )0;
    } else
#line 1508
    if ((unsigned int )state == 2U) {
#line 1508
      if (nAtts < attsMax) {
#line 1509
        (atts + nAtts)->normalized = (char)0;
      }
    }
#line 1510
    break;
    case 17: 
    case 11: 
#line 1513
    if ((unsigned int )state != 2U) {
#line 1514
      return (nAtts);
    }
#line 1515
    break;
    default: 
#line 1517
    break;
    }
#line 1439
    ptr ++;
  }
}
}
#line 1523 "xmltok_impl.c"
static int normal_charRefNumber(ENCODING const   *enc , char const   *ptr ) 
{ 
  int result ;
  int c ;
  int c___0 ;
  int tmp ;

  {
#line 1526
  result = 0;
#line 1528
  ptr += 2;
#line 1529
  if ((int const   )*ptr == 120) {
#line 1530
    ptr ++;
#line 1530
    while (! ((int const   )*ptr == 59)) {
#line 1533
      c = (int )*ptr;
#line 1534
      switch (c) {
      case 57: 
      case 56: 
      case 55: 
      case 54: 
      case 53: 
      case 52: 
      case 51: 
      case 50: 
      case 49: 
      case 48: 
#line 1537
      result <<= 4;
#line 1538
      result |= c - 48;
#line 1539
      break;
      case 70: 
      case 69: 
      case 68: 
      case 67: 
      case 66: 
      case 65: 
#line 1542
      result <<= 4;
#line 1543
      result += 10 + (c - 65);
#line 1544
      break;
      case 102: 
      case 101: 
      case 100: 
      case 99: 
      case 98: 
      case 97: 
#line 1547
      result <<= 4;
#line 1548
      result += 10 + (c - 97);
#line 1549
      break;
      }
#line 1551
      if (result >= 1114112) {
#line 1552
        return (-1);
      }
#line 1530
      ptr ++;
    }
  } else {
#line 1556
    while (! ((int const   )*ptr == 59)) {
#line 1557
      c___0 = (int )*ptr;
#line 1558
      result *= 10;
#line 1559
      result += c___0 - 48;
#line 1560
      if (result >= 1114112) {
#line 1561
        return (-1);
      }
#line 1556
      ptr ++;
    }
  }
#line 1564
  tmp = checkCharRefNumber(result);
#line 1564
  return (tmp);
}
}
#line 1567 "xmltok_impl.c"
static int normal_predefinedEntityName(ENCODING const   *enc , char const   *ptr ,
                                       char const   *end ) 
{ 


  {
#line 1571
  switch (end - ptr) {
  case 2L: 
#line 1573
  if ((int const   )*(ptr + 1) == 116) {
#line 1574
    switch ((int const   )*ptr) {
    case 108: 
#line 1576
    return (60);
    case 103: 
#line 1578
    return (62);
    }
  }
#line 1581
  break;
  case 3L: 
#line 1583
  if ((int const   )*ptr == 97) {
#line 1584
    ptr ++;
#line 1585
    if ((int const   )*ptr == 109) {
#line 1586
      ptr ++;
#line 1587
      if ((int const   )*ptr == 112) {
#line 1588
        return (38);
      }
    }
  }
#line 1591
  break;
  case 4L: 
#line 1593
  switch ((int const   )*ptr) {
  case 113: 
#line 1595
  ptr ++;
#line 1596
  if ((int const   )*ptr == 117) {
#line 1597
    ptr ++;
#line 1598
    if ((int const   )*ptr == 111) {
#line 1599
      ptr ++;
#line 1600
      if ((int const   )*ptr == 116) {
#line 1601
        return (34);
      }
    }
  }
#line 1604
  break;
  case 97: 
#line 1606
  ptr ++;
#line 1607
  if ((int const   )*ptr == 112) {
#line 1608
    ptr ++;
#line 1609
    if ((int const   )*ptr == 111) {
#line 1610
      ptr ++;
#line 1611
      if ((int const   )*ptr == 115) {
#line 1612
        return (39);
      }
    }
  }
#line 1615
  break;
  }
  }
#line 1618
  return (0);
}
}
#line 1621 "xmltok_impl.c"
static int normal_sameName(ENCODING const   *enc , char const   *ptr1 , char const   *ptr2 ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;

  {
#line 1624
  while (1) {
#line 1625
    switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr1]) {
    case 7: 
#line 1630
    tmp = ptr1;
#line 1630
    ptr1 ++;
#line 1630
    tmp___0 = ptr2;
#line 1630
    ptr2 ++;
#line 1630
    if ((int const   )*tmp != (int const   )*tmp___0) {
#line 1630
      return (0);
    }
    case 6: 
#line 1630
    tmp___1 = ptr1;
#line 1630
    ptr1 ++;
#line 1630
    tmp___2 = ptr2;
#line 1630
    ptr2 ++;
#line 1630
    if ((int const   )*tmp___1 != (int const   )*tmp___2) {
#line 1630
      return (0);
    }
    case 5: 
#line 1630
    tmp___3 = ptr1;
#line 1630
    ptr1 ++;
#line 1630
    tmp___4 = ptr2;
#line 1630
    ptr2 ++;
#line 1630
    if ((int const   )*tmp___3 != (int const   )*tmp___4) {
#line 1630
      return (0);
    }
#line 1633
    tmp___5 = ptr1;
#line 1633
    ptr1 ++;
#line 1633
    tmp___6 = ptr2;
#line 1633
    ptr2 ++;
#line 1633
    if ((int const   )*tmp___5 != (int const   )*tmp___6) {
#line 1634
      return (0);
    }
#line 1635
    break;
    case 27: 
    case 26: 
    case 25: 
    case 24: 
    case 23: 
    case 22: 
    case 29: 
#line 1645
    tmp___7 = ptr2;
#line 1645
    ptr2 ++;
#line 1645
    tmp___8 = ptr1;
#line 1645
    ptr1 ++;
#line 1645
    if ((int const   )*tmp___7 != (int const   )*tmp___8) {
#line 1646
      return (0);
    }
#line 1659
    break;
    default: 
#line 1661
    if ((int const   )*ptr1 == (int const   )*ptr2) {
#line 1662
      return (1);
    }
#line 1663
    switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr2]) {
    case 27: 
    case 26: 
    case 25: 
    case 24: 
    case 23: 
    case 22: 
    case 29: 
    case 7: 
    case 6: 
    case 5: 
#line 1676
    return (0);
    default: 
#line 1678
    return (1);
    }
    }
  }
}
}
#line 1685 "xmltok_impl.c"
static int normal_nameMatchesAscii(ENCODING const   *enc , char const   *ptr1 , char const   *end1 ,
                                   char const   *ptr2 ) 
{ 


  {
#line 1689
  while (*ptr2) {
#line 1690
    if ((unsigned long )ptr1 == (unsigned long )end1) {
#line 1691
      return (0);
    }
#line 1692
    if (! ((int const   )*ptr1 == (int const   )*ptr2)) {
#line 1693
      return (0);
    }
#line 1689
    ptr1 ++;
#line 1689
    ptr2 ++;
  }
#line 1695
  return ((unsigned long )ptr1 == (unsigned long )end1);
}
}
#line 1698 "xmltok_impl.c"
static int normal_nameLength(ENCODING const   *enc , char const   *ptr ) 
{ 
  char const   *start ;

  {
#line 1701
  start = ptr;
#line 1702
  while (1) {
#line 1703
    switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
    case 5: 
#line 1706
    ptr += 2;
#line 1706
    break;
    case 6: 
#line 1706
    ptr += 3;
#line 1706
    break;
    case 7: 
#line 1706
    ptr += 4;
#line 1706
    break;
    case 27: 
    case 26: 
    case 25: 
    case 24: 
    case 23: 
    case 22: 
    case 29: 
#line 1717
    ptr ++;
#line 1718
    break;
    default: 
#line 1720
    return ((int )(ptr - start));
    }
  }
}
}
#line 1725 "xmltok_impl.c"
static char const   *normal_skipS(ENCODING const   *enc , char const   *ptr ) 
{ 


  {
#line 1728
  while (1) {
#line 1729
    switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
    case 21: 
    case 9: 
    case 10: 
#line 1733
    ptr ++;
#line 1734
    break;
    default: 
#line 1736
    return (ptr);
    }
  }
}
}
#line 1741 "xmltok_impl.c"
static void normal_updatePosition(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                  POSITION *pos ) 
{ 


  {
#line 1747
  while ((unsigned long )ptr < (unsigned long )end) {
#line 1748
    switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr]) {
    case 5: 
#line 1753
    ptr += 2;
#line 1753
    break;
    case 6: 
#line 1753
    ptr += 3;
#line 1753
    break;
    case 7: 
#line 1753
    ptr += 4;
#line 1753
    break;
    case 10: 
#line 1756
    pos->columnNumber = (XML_Size )-1;
#line 1757
    (pos->lineNumber) ++;
#line 1758
    ptr ++;
#line 1759
    break;
    case 9: 
#line 1761
    (pos->lineNumber) ++;
#line 1762
    ptr ++;
#line 1763
    if ((unsigned long )ptr != (unsigned long )end) {
#line 1763
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 1764
        ptr ++;
      }
    }
#line 1765
    pos->columnNumber = (XML_Size )-1;
#line 1766
    break;
    default: 
#line 1768
    ptr ++;
#line 1769
    break;
    }
#line 1771
    (pos->columnNumber) ++;
  }
#line 1773
  return;
}
}
#line 321 "xmltok.c"
static void utf8_toUtf8(ENCODING const   *enc , char const   **fromP , char const   *fromLim ,
                        char **toP , char const   *toLim ) 
{ 
  char *to ;
  char const   *from ;

  {
#line 328
  if (fromLim - *fromP > toLim - (char const   *)*toP) {
#line 330
    fromLim = *fromP + (toLim - (char const   *)*toP);
#line 330
    while ((unsigned long )fromLim > (unsigned long )*fromP) {
#line 331
      if (((int )((unsigned char )*(fromLim + -1)) & 192) != 128) {
#line 332
        break;
      }
#line 330
      fromLim --;
    }
  }
#line 334
  to = *toP;
#line 334
  from = *fromP;
#line 334
  while ((unsigned long )from != (unsigned long )fromLim) {
#line 335
    *to = (char )*from;
#line 334
    from ++;
#line 334
    to ++;
  }
#line 336
  *fromP = from;
#line 337
  *toP = to;
#line 338
  return;
}
}
#line 340 "xmltok.c"
static void utf8_toUtf16(ENCODING const   *enc , char const   **fromP , char const   *fromLim ,
                         unsigned short **toP , unsigned short const   *toLim ) 
{ 
  unsigned short *to ;
  char const   *from ;
  unsigned short *tmp ;
  unsigned short *tmp___0 ;
  unsigned long n ;
  unsigned short *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 345
  to = *toP;
#line 346
  from = *fromP;
#line 347
  while (1) {
#line 347
    if ((unsigned long )from != (unsigned long )fromLim) {
#line 347
      if (! ((unsigned long )to != (unsigned long )toLim)) {
#line 347
        break;
      }
    } else {
#line 347
      break;
    }
#line 348
    switch ((int )((struct normal_encoding *)enc)->type[(unsigned char )*from]) {
    case 5: 
#line 350
    tmp = to;
#line 350
    to ++;
#line 350
    *tmp = (unsigned short )((((int const   )*(from + 0) & 31) << 6) | ((int const   )*(from + 1) & 63));
#line 351
    from += 2;
#line 352
    break;
    case 6: 
#line 354
    tmp___0 = to;
#line 354
    to ++;
#line 354
    *tmp___0 = (unsigned short )(((((int const   )*(from + 0) & 15) << 12) | (((int const   )*(from + 1) & 63) << 6)) | ((int const   )*(from + 2) & 63));
#line 356
    from += 3;
#line 357
    break;
    case 7: 
#line 361
    if ((unsigned long )(to + 1) == (unsigned long )toLim) {
#line 362
      goto after;
    }
#line 363
    n = (unsigned long )((((((int const   )*(from + 0) & 7) << 18) | (((int const   )*(from + 1) & 63) << 12)) | (((int const   )*(from + 2) & 63) << 6)) | ((int const   )*(from + 3) & 63));
#line 365
    n -= 65536UL;
#line 366
    *(to + 0) = (unsigned short )((n >> 10) | 55296UL);
#line 367
    *(to + 1) = (unsigned short )((n & 1023UL) | 56320UL);
#line 368
    to += 2;
#line 369
    from += 4;
#line 371
    break;
    default: 
#line 373
    tmp___1 = to;
#line 373
    to ++;
#line 373
    tmp___2 = from;
#line 373
    from ++;
#line 373
    *tmp___1 = (unsigned short )*tmp___2;
#line 374
    break;
    }
  }
  after: 
#line 378
  *fromP = from;
#line 379
  *toP = to;
#line 380
  return;
}
}
#line 383 "xmltok.c"
static struct normal_encoding  const  utf8_encoding_ns  = 
#line 383
     {{{& normal_prologTok, & normal_contentTok, & normal_cdataSectionTok, & normal_ignoreSectionTok},
     {& normal_attributeValueTok, & normal_entityValueTok}, & normal_sameName, & normal_nameMatchesAscii,
     & normal_nameLength, & normal_skipS, & normal_getAtts, & normal_charRefNumber,
     & normal_predefinedEntityName, & normal_updatePosition, & normal_isPublicId,
     & utf8_toUtf8, & utf8_toUtf16, 1, (char)1, (char)0}, {(unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)21,
                                                           (unsigned char)10, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)9,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)21, (unsigned char)16,
                                                           (unsigned char)12, (unsigned char)19,
                                                           (unsigned char)28, (unsigned char)30,
                                                           (unsigned char)3, (unsigned char)13,
                                                           (unsigned char)31, (unsigned char)32,
                                                           (unsigned char)33, (unsigned char)34,
                                                           (unsigned char)35, (unsigned char)27,
                                                           (unsigned char)26, (unsigned char)17,
                                                           (unsigned char)25, (unsigned char)25,
                                                           (unsigned char)25, (unsigned char)25,
                                                           (unsigned char)25, (unsigned char)25,
                                                           (unsigned char)25, (unsigned char)25,
                                                           (unsigned char)25, (unsigned char)25,
                                                           (unsigned char)23, (unsigned char)18,
                                                           (unsigned char)2, (unsigned char)14,
                                                           (unsigned char)11, (unsigned char)15,
                                                           (unsigned char)28, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)20,
                                                           (unsigned char)28, (unsigned char)4,
                                                           (unsigned char)28, (unsigned char)22,
                                                           (unsigned char)28, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)28,
                                                           (unsigned char)36, (unsigned char)28,
                                                           (unsigned char)28, (unsigned char)28,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)7, (unsigned char)7,
                                                           (unsigned char)7, (unsigned char)7,
                                                           (unsigned char)7, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)1, (unsigned char)1},
    & utf8_isName2, & utf8_isName3, & isNever, & utf8_isNmstrt2, & utf8_isNmstrt3,
    & isNever, & utf8_isInvalid2, & utf8_isInvalid3, & utf8_isInvalid4};
#line 393 "xmltok.c"
static struct normal_encoding  const  utf8_encoding  = 
#line 393
     {{{& normal_prologTok, & normal_contentTok, & normal_cdataSectionTok, & normal_ignoreSectionTok},
     {& normal_attributeValueTok, & normal_entityValueTok}, & normal_sameName, & normal_nameMatchesAscii,
     & normal_nameLength, & normal_skipS, & normal_getAtts, & normal_charRefNumber,
     & normal_predefinedEntityName, & normal_updatePosition, & normal_isPublicId,
     & utf8_toUtf8, & utf8_toUtf16, 1, (char)1, (char)0}, {(unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)21,
                                                           (unsigned char)10, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)9,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)21, (unsigned char)16,
                                                           (unsigned char)12, (unsigned char)19,
                                                           (unsigned char)28, (unsigned char)30,
                                                           (unsigned char)3, (unsigned char)13,
                                                           (unsigned char)31, (unsigned char)32,
                                                           (unsigned char)33, (unsigned char)34,
                                                           (unsigned char)35, (unsigned char)27,
                                                           (unsigned char)26, (unsigned char)17,
                                                           (unsigned char)25, (unsigned char)25,
                                                           (unsigned char)25, (unsigned char)25,
                                                           (unsigned char)25, (unsigned char)25,
                                                           (unsigned char)25, (unsigned char)25,
                                                           (unsigned char)25, (unsigned char)25,
                                                           (unsigned char)22, (unsigned char)18,
                                                           (unsigned char)2, (unsigned char)14,
                                                           (unsigned char)11, (unsigned char)15,
                                                           (unsigned char)28, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)20,
                                                           (unsigned char)28, (unsigned char)4,
                                                           (unsigned char)28, (unsigned char)22,
                                                           (unsigned char)28, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)28,
                                                           (unsigned char)36, (unsigned char)28,
                                                           (unsigned char)28, (unsigned char)28,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)7, (unsigned char)7,
                                                           (unsigned char)7, (unsigned char)7,
                                                           (unsigned char)7, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)1, (unsigned char)1},
    & utf8_isName2, & utf8_isName3, & isNever, & utf8_isNmstrt2, & utf8_isNmstrt3,
    & isNever, & utf8_isInvalid2, & utf8_isInvalid3, & utf8_isInvalid4};
#line 406 "xmltok.c"
static struct normal_encoding  const  internal_utf8_encoding_ns  = 
#line 406
     {{{& normal_prologTok, & normal_contentTok, & normal_cdataSectionTok, & normal_ignoreSectionTok},
     {& normal_attributeValueTok, & normal_entityValueTok}, & normal_sameName, & normal_nameMatchesAscii,
     & normal_nameLength, & normal_skipS, & normal_getAtts, & normal_charRefNumber,
     & normal_predefinedEntityName, & normal_updatePosition, & normal_isPublicId,
     & utf8_toUtf8, & utf8_toUtf16, 1, (char)1, (char)0}, {(unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)21,
                                                           (unsigned char)10, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)21,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)21, (unsigned char)16,
                                                           (unsigned char)12, (unsigned char)19,
                                                           (unsigned char)28, (unsigned char)30,
                                                           (unsigned char)3, (unsigned char)13,
                                                           (unsigned char)31, (unsigned char)32,
                                                           (unsigned char)33, (unsigned char)34,
                                                           (unsigned char)35, (unsigned char)27,
                                                           (unsigned char)26, (unsigned char)17,
                                                           (unsigned char)25, (unsigned char)25,
                                                           (unsigned char)25, (unsigned char)25,
                                                           (unsigned char)25, (unsigned char)25,
                                                           (unsigned char)25, (unsigned char)25,
                                                           (unsigned char)25, (unsigned char)25,
                                                           (unsigned char)23, (unsigned char)18,
                                                           (unsigned char)2, (unsigned char)14,
                                                           (unsigned char)11, (unsigned char)15,
                                                           (unsigned char)28, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)20,
                                                           (unsigned char)28, (unsigned char)4,
                                                           (unsigned char)28, (unsigned char)22,
                                                           (unsigned char)28, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)28,
                                                           (unsigned char)36, (unsigned char)28,
                                                           (unsigned char)28, (unsigned char)28,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)7, (unsigned char)7,
                                                           (unsigned char)7, (unsigned char)7,
                                                           (unsigned char)7, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)1, (unsigned char)1},
    & utf8_isName2, & utf8_isName3, & isNever, & utf8_isNmstrt2, & utf8_isNmstrt3,
    & isNever, & utf8_isInvalid2, & utf8_isInvalid3, & utf8_isInvalid4};
#line 417 "xmltok.c"
static struct normal_encoding  const  internal_utf8_encoding  = 
#line 417
     {{{& normal_prologTok, & normal_contentTok, & normal_cdataSectionTok, & normal_ignoreSectionTok},
     {& normal_attributeValueTok, & normal_entityValueTok}, & normal_sameName, & normal_nameMatchesAscii,
     & normal_nameLength, & normal_skipS, & normal_getAtts, & normal_charRefNumber,
     & normal_predefinedEntityName, & normal_updatePosition, & normal_isPublicId,
     & utf8_toUtf8, & utf8_toUtf16, 1, (char)1, (char)0}, {(unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)21,
                                                           (unsigned char)10, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)21,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)21, (unsigned char)16,
                                                           (unsigned char)12, (unsigned char)19,
                                                           (unsigned char)28, (unsigned char)30,
                                                           (unsigned char)3, (unsigned char)13,
                                                           (unsigned char)31, (unsigned char)32,
                                                           (unsigned char)33, (unsigned char)34,
                                                           (unsigned char)35, (unsigned char)27,
                                                           (unsigned char)26, (unsigned char)17,
                                                           (unsigned char)25, (unsigned char)25,
                                                           (unsigned char)25, (unsigned char)25,
                                                           (unsigned char)25, (unsigned char)25,
                                                           (unsigned char)25, (unsigned char)25,
                                                           (unsigned char)25, (unsigned char)25,
                                                           (unsigned char)22, (unsigned char)18,
                                                           (unsigned char)2, (unsigned char)14,
                                                           (unsigned char)11, (unsigned char)15,
                                                           (unsigned char)28, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)20,
                                                           (unsigned char)28, (unsigned char)4,
                                                           (unsigned char)28, (unsigned char)22,
                                                           (unsigned char)28, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)28,
                                                           (unsigned char)36, (unsigned char)28,
                                                           (unsigned char)28, (unsigned char)28,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)7, (unsigned char)7,
                                                           (unsigned char)7, (unsigned char)7,
                                                           (unsigned char)7, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)1, (unsigned char)1},
    & utf8_isName2, & utf8_isName3, & isNever, & utf8_isNmstrt2, & utf8_isNmstrt3,
    & isNever, & utf8_isInvalid2, & utf8_isInvalid3, & utf8_isInvalid4};
#line 428 "xmltok.c"
static void latin1_toUtf8(ENCODING const   *enc , char const   **fromP , char const   *fromLim ,
                          char **toP , char const   *toLim ) 
{ 
  unsigned char c ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 433
  while (! ((unsigned long )*fromP == (unsigned long )fromLim)) {
#line 437
    c = (unsigned char )*(*fromP);
#line 438
    if ((int )c & 128) {
#line 439
      if (toLim - (char const   *)*toP < 2L) {
#line 440
        break;
      }
#line 441
      tmp = *toP;
#line 441
      (*toP) ++;
#line 441
      *tmp = (char )(((int )c >> 6) | 192);
#line 442
      tmp___0 = *toP;
#line 442
      (*toP) ++;
#line 442
      *tmp___0 = (char )(((int )c & 63) | 128);
#line 443
      (*fromP) ++;
    } else {
#line 446
      if ((unsigned long )*toP == (unsigned long )toLim) {
#line 447
        break;
      }
#line 448
      tmp___1 = *toP;
#line 448
      (*toP) ++;
#line 448
      tmp___2 = *fromP;
#line 448
      (*fromP) ++;
#line 448
      *tmp___1 = (char )*tmp___2;
    }
  }
#line 451
  return;
}
}
#line 453 "xmltok.c"
static void latin1_toUtf16(ENCODING const   *enc , char const   **fromP , char const   *fromLim ,
                           unsigned short **toP , unsigned short const   *toLim ) 
{ 
  unsigned short *tmp ;
  char const   *tmp___0 ;

  {
#line 458
  while (1) {
#line 458
    if ((unsigned long )*fromP != (unsigned long )fromLim) {
#line 458
      if (! ((unsigned long )*toP != (unsigned long )toLim)) {
#line 458
        break;
      }
    } else {
#line 458
      break;
    }
#line 459
    tmp = *toP;
#line 459
    (*toP) ++;
#line 459
    tmp___0 = *fromP;
#line 459
    (*fromP) ++;
#line 459
    *tmp = (unsigned short )((unsigned char )*tmp___0);
  }
#line 460
  return;
}
}
#line 464 "xmltok.c"
static struct normal_encoding  const  latin1_encoding_ns  = 
#line 464
     {{{& normal_prologTok, & normal_contentTok, & normal_cdataSectionTok, & normal_ignoreSectionTok},
     {& normal_attributeValueTok, & normal_entityValueTok}, & normal_sameName, & normal_nameMatchesAscii,
     & normal_nameLength, & normal_skipS, & normal_getAtts, & normal_charRefNumber,
     & normal_predefinedEntityName, & normal_updatePosition, & normal_isPublicId,
     & latin1_toUtf8, & latin1_toUtf16, 1, (char)0, (char)0}, {(unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)21,
                                                               (unsigned char)10,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)9, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)21,
                                                               (unsigned char)16,
                                                               (unsigned char)12,
                                                               (unsigned char)19,
                                                               (unsigned char)28,
                                                               (unsigned char)30,
                                                               (unsigned char)3, (unsigned char)13,
                                                               (unsigned char)31,
                                                               (unsigned char)32,
                                                               (unsigned char)33,
                                                               (unsigned char)34,
                                                               (unsigned char)35,
                                                               (unsigned char)27,
                                                               (unsigned char)26,
                                                               (unsigned char)17,
                                                               (unsigned char)25,
                                                               (unsigned char)25,
                                                               (unsigned char)25,
                                                               (unsigned char)25,
                                                               (unsigned char)25,
                                                               (unsigned char)25,
                                                               (unsigned char)25,
                                                               (unsigned char)25,
                                                               (unsigned char)25,
                                                               (unsigned char)25,
                                                               (unsigned char)23,
                                                               (unsigned char)18,
                                                               (unsigned char)2, (unsigned char)14,
                                                               (unsigned char)11,
                                                               (unsigned char)15,
                                                               (unsigned char)28,
                                                               (unsigned char)24,
                                                               (unsigned char)24,
                                                               (unsigned char)24,
                                                               (unsigned char)24,
                                                               (unsigned char)24,
                                                               (unsigned char)24,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)20,
                                                               (unsigned char)28,
                                                               (unsigned char)4, (unsigned char)28,
                                                               (unsigned char)22,
                                                               (unsigned char)28,
                                                               (unsigned char)24,
                                                               (unsigned char)24,
                                                               (unsigned char)24,
                                                               (unsigned char)24,
                                                               (unsigned char)24,
                                                               (unsigned char)24,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)28,
                                                               (unsigned char)36,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)22,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)22,
                                                               (unsigned char)28,
                                                               (unsigned char)26,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)22,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)28,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)28,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22},
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0};
#line 475 "xmltok.c"
static struct normal_encoding  const  latin1_encoding  = 
#line 475
     {{{& normal_prologTok, & normal_contentTok, & normal_cdataSectionTok, & normal_ignoreSectionTok},
     {& normal_attributeValueTok, & normal_entityValueTok}, & normal_sameName, & normal_nameMatchesAscii,
     & normal_nameLength, & normal_skipS, & normal_getAtts, & normal_charRefNumber,
     & normal_predefinedEntityName, & normal_updatePosition, & normal_isPublicId,
     & latin1_toUtf8, & latin1_toUtf16, 1, (char)0, (char)0}, {(unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)21,
                                                               (unsigned char)10,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)9, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)21,
                                                               (unsigned char)16,
                                                               (unsigned char)12,
                                                               (unsigned char)19,
                                                               (unsigned char)28,
                                                               (unsigned char)30,
                                                               (unsigned char)3, (unsigned char)13,
                                                               (unsigned char)31,
                                                               (unsigned char)32,
                                                               (unsigned char)33,
                                                               (unsigned char)34,
                                                               (unsigned char)35,
                                                               (unsigned char)27,
                                                               (unsigned char)26,
                                                               (unsigned char)17,
                                                               (unsigned char)25,
                                                               (unsigned char)25,
                                                               (unsigned char)25,
                                                               (unsigned char)25,
                                                               (unsigned char)25,
                                                               (unsigned char)25,
                                                               (unsigned char)25,
                                                               (unsigned char)25,
                                                               (unsigned char)25,
                                                               (unsigned char)25,
                                                               (unsigned char)22,
                                                               (unsigned char)18,
                                                               (unsigned char)2, (unsigned char)14,
                                                               (unsigned char)11,
                                                               (unsigned char)15,
                                                               (unsigned char)28,
                                                               (unsigned char)24,
                                                               (unsigned char)24,
                                                               (unsigned char)24,
                                                               (unsigned char)24,
                                                               (unsigned char)24,
                                                               (unsigned char)24,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)20,
                                                               (unsigned char)28,
                                                               (unsigned char)4, (unsigned char)28,
                                                               (unsigned char)22,
                                                               (unsigned char)28,
                                                               (unsigned char)24,
                                                               (unsigned char)24,
                                                               (unsigned char)24,
                                                               (unsigned char)24,
                                                               (unsigned char)24,
                                                               (unsigned char)24,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)28,
                                                               (unsigned char)36,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)22,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)22,
                                                               (unsigned char)28,
                                                               (unsigned char)26,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)22,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)28,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)28,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22},
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0};
#line 486 "xmltok.c"
static void ascii_toUtf8(ENCODING const   *enc , char const   **fromP , char const   *fromLim ,
                         char **toP , char const   *toLim ) 
{ 
  char *tmp ;
  char const   *tmp___0 ;

  {
#line 491
  while (1) {
#line 491
    if ((unsigned long )*fromP != (unsigned long )fromLim) {
#line 491
      if (! ((unsigned long )*toP != (unsigned long )toLim)) {
#line 491
        break;
      }
    } else {
#line 491
      break;
    }
#line 492
    tmp = *toP;
#line 492
    (*toP) ++;
#line 492
    tmp___0 = *fromP;
#line 492
    (*fromP) ++;
#line 492
    *tmp = (char )*tmp___0;
  }
#line 493
  return;
}
}
#line 497 "xmltok.c"
static struct normal_encoding  const  ascii_encoding_ns  = 
#line 497
     {{{& normal_prologTok, & normal_contentTok, & normal_cdataSectionTok, & normal_ignoreSectionTok},
     {& normal_attributeValueTok, & normal_entityValueTok}, & normal_sameName, & normal_nameMatchesAscii,
     & normal_nameLength, & normal_skipS, & normal_getAtts, & normal_charRefNumber,
     & normal_predefinedEntityName, & normal_updatePosition, & normal_isPublicId,
     & ascii_toUtf8, & latin1_toUtf16, 1, (char)1, (char)0}, {(unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)21,
                                                              (unsigned char)10, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)9,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)21, (unsigned char)16,
                                                              (unsigned char)12, (unsigned char)19,
                                                              (unsigned char)28, (unsigned char)30,
                                                              (unsigned char)3, (unsigned char)13,
                                                              (unsigned char)31, (unsigned char)32,
                                                              (unsigned char)33, (unsigned char)34,
                                                              (unsigned char)35, (unsigned char)27,
                                                              (unsigned char)26, (unsigned char)17,
                                                              (unsigned char)25, (unsigned char)25,
                                                              (unsigned char)25, (unsigned char)25,
                                                              (unsigned char)25, (unsigned char)25,
                                                              (unsigned char)25, (unsigned char)25,
                                                              (unsigned char)25, (unsigned char)25,
                                                              (unsigned char)23, (unsigned char)18,
                                                              (unsigned char)2, (unsigned char)14,
                                                              (unsigned char)11, (unsigned char)15,
                                                              (unsigned char)28, (unsigned char)24,
                                                              (unsigned char)24, (unsigned char)24,
                                                              (unsigned char)24, (unsigned char)24,
                                                              (unsigned char)24, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)20,
                                                              (unsigned char)28, (unsigned char)4,
                                                              (unsigned char)28, (unsigned char)22,
                                                              (unsigned char)28, (unsigned char)24,
                                                              (unsigned char)24, (unsigned char)24,
                                                              (unsigned char)24, (unsigned char)24,
                                                              (unsigned char)24, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)28,
                                                              (unsigned char)36, (unsigned char)28,
                                                              (unsigned char)28, (unsigned char)28},
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0};
#line 508 "xmltok.c"
static struct normal_encoding  const  ascii_encoding  = 
#line 508
     {{{& normal_prologTok, & normal_contentTok, & normal_cdataSectionTok, & normal_ignoreSectionTok},
     {& normal_attributeValueTok, & normal_entityValueTok}, & normal_sameName, & normal_nameMatchesAscii,
     & normal_nameLength, & normal_skipS, & normal_getAtts, & normal_charRefNumber,
     & normal_predefinedEntityName, & normal_updatePosition, & normal_isPublicId,
     & ascii_toUtf8, & latin1_toUtf16, 1, (char)1, (char)0}, {(unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)21,
                                                              (unsigned char)10, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)9,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)21, (unsigned char)16,
                                                              (unsigned char)12, (unsigned char)19,
                                                              (unsigned char)28, (unsigned char)30,
                                                              (unsigned char)3, (unsigned char)13,
                                                              (unsigned char)31, (unsigned char)32,
                                                              (unsigned char)33, (unsigned char)34,
                                                              (unsigned char)35, (unsigned char)27,
                                                              (unsigned char)26, (unsigned char)17,
                                                              (unsigned char)25, (unsigned char)25,
                                                              (unsigned char)25, (unsigned char)25,
                                                              (unsigned char)25, (unsigned char)25,
                                                              (unsigned char)25, (unsigned char)25,
                                                              (unsigned char)25, (unsigned char)25,
                                                              (unsigned char)22, (unsigned char)18,
                                                              (unsigned char)2, (unsigned char)14,
                                                              (unsigned char)11, (unsigned char)15,
                                                              (unsigned char)28, (unsigned char)24,
                                                              (unsigned char)24, (unsigned char)24,
                                                              (unsigned char)24, (unsigned char)24,
                                                              (unsigned char)24, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)20,
                                                              (unsigned char)28, (unsigned char)4,
                                                              (unsigned char)28, (unsigned char)22,
                                                              (unsigned char)28, (unsigned char)24,
                                                              (unsigned char)24, (unsigned char)24,
                                                              (unsigned char)24, (unsigned char)24,
                                                              (unsigned char)24, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)28,
                                                              (unsigned char)36, (unsigned char)28,
                                                              (unsigned char)28, (unsigned char)28},
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0};
#line 519 "xmltok.c"
static int unicode_byte_type(char hi , char lo ) 
{ 


  {
#line 522
  switch ((int )((unsigned char )hi)) {
  case 219: 
  case 218: 
  case 217: 
  case 216: 
#line 524
  return (7);
  case 223: 
  case 222: 
  case 221: 
  case 220: 
#line 526
  return (8);
  case 255: 
#line 528
  switch ((int )((unsigned char )lo)) {
  case 254: 
  case 255: 
#line 531
  return (0);
  }
#line 533
  break;
  }
#line 535
  return (29);
}
}
#line 620 "xmltok.c"
static void little2_toUtf8(ENCODING const   *enc , char const   **fromP , char const   *fromLim ,
                           char **toP , char const   *toLim ) 
{ 
  char const   *from ;
  int plane ;
  unsigned char lo2 ;
  unsigned char lo ;
  unsigned char hi ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 620
  from = *fromP;
#line 620
  while ((unsigned long )from != (unsigned long )fromLim) {
#line 620
    lo = (unsigned char )*(from + 0);
#line 620
    hi = (unsigned char )*(from + 1);
#line 620
    switch ((int )hi) {
    case 0: 
#line 620
    if ((int )lo < 128) {
#line 620
      if ((unsigned long )*toP == (unsigned long )toLim) {
#line 620
        *fromP = from;
#line 620
        return;
      }
#line 620
      tmp = *toP;
#line 620
      (*toP) ++;
#line 620
      *tmp = (char )lo;
#line 620
      break;
    }
    case 7: 
    case 6: 
    case 5: 
    case 4: 
    case 3: 
    case 2: 
    case 1: 
#line 620
    if (toLim - (char const   *)*toP < 2L) {
#line 620
      *fromP = from;
#line 620
      return;
    }
#line 620
    tmp___0 = *toP;
#line 620
    (*toP) ++;
#line 620
    *tmp___0 = (char )((((int )lo >> 6) | ((int )hi << 2)) | 192);
#line 620
    tmp___1 = *toP;
#line 620
    (*toP) ++;
#line 620
    *tmp___1 = (char )(((int )lo & 63) | 128);
#line 620
    break;
    default: 
#line 620
    if (toLim - (char const   *)*toP < 3L) {
#line 620
      *fromP = from;
#line 620
      return;
    }
#line 620
    tmp___2 = *toP;
#line 620
    (*toP) ++;
#line 620
    *tmp___2 = (char )(((int )hi >> 4) | 224);
#line 620
    tmp___3 = *toP;
#line 620
    (*toP) ++;
#line 620
    *tmp___3 = (char )(((((int )hi & 15) << 2) | ((int )lo >> 6)) | 128);
#line 620
    tmp___4 = *toP;
#line 620
    (*toP) ++;
#line 620
    *tmp___4 = (char )(((int )lo & 63) | 128);
#line 620
    break;
    case 219: 
    case 218: 
    case 217: 
    case 216: 
#line 620
    if (toLim - (char const   *)*toP < 4L) {
#line 620
      *fromP = from;
#line 620
      return;
    }
#line 620
    plane = ((((int )hi & 3) << 2) | (((int )lo >> 6) & 3)) + 1;
#line 620
    tmp___5 = *toP;
#line 620
    (*toP) ++;
#line 620
    *tmp___5 = (char )((plane >> 2) | 240);
#line 620
    tmp___6 = *toP;
#line 620
    (*toP) ++;
#line 620
    *tmp___6 = (char )(((((int )lo >> 2) & 15) | ((plane & 3) << 4)) | 128);
#line 620
    from += 2;
#line 620
    lo2 = (unsigned char )*(from + 0);
#line 620
    tmp___7 = *toP;
#line 620
    (*toP) ++;
#line 620
    *tmp___7 = (char )((((((int )lo & 3) << 4) | (((int )((unsigned char )*(from + 1)) & 3) << 2)) | ((int )lo2 >> 6)) | 128);
#line 620
    tmp___8 = *toP;
#line 620
    (*toP) ++;
#line 620
    *tmp___8 = (char )(((int )lo2 & 63) | 128);
#line 620
    break;
    }
#line 620
    from += 2;
  }
#line 620
  *fromP = from;
#line 620
  return;
}
}
#line 621 "xmltok.c"
static void little2_toUtf16(ENCODING const   *enc , char const   **fromP , char const   *fromLim ,
                            unsigned short **toP , unsigned short const   *toLim ) 
{ 
  unsigned short *tmp ;

  {
#line 621
  if (fromLim - *fromP > (toLim - (unsigned short const   *)*toP) << 1) {
#line 621
    if (((int )((unsigned char )*((fromLim - 2) + 1)) & 248) == 216) {
#line 621
      fromLim -= 2;
    }
  }
#line 621
  while (1) {
#line 621
    if ((unsigned long )*fromP != (unsigned long )fromLim) {
#line 621
      if (! ((unsigned long )*toP != (unsigned long )toLim)) {
#line 621
        break;
      }
    } else {
#line 621
      break;
    }
#line 621
    tmp = *toP;
#line 621
    (*toP) ++;
#line 621
    *tmp = (unsigned short )(((int )((unsigned char )*(*fromP + 1)) << 8) | (int )((unsigned char )*(*fromP + 0)));
#line 621
    *fromP += 2;
  }
#line 621
  return;
}
}
#line 632 "xmltok.c"
static void big2_toUtf8(ENCODING const   *enc , char const   **fromP , char const   *fromLim ,
                        char **toP , char const   *toLim ) 
{ 
  char const   *from ;
  int plane ;
  unsigned char lo2 ;
  unsigned char lo ;
  unsigned char hi ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 632
  from = *fromP;
#line 632
  while ((unsigned long )from != (unsigned long )fromLim) {
#line 632
    lo = (unsigned char )*(from + 1);
#line 632
    hi = (unsigned char )*(from + 0);
#line 632
    switch ((int )hi) {
    case 0: 
#line 632
    if ((int )lo < 128) {
#line 632
      if ((unsigned long )*toP == (unsigned long )toLim) {
#line 632
        *fromP = from;
#line 632
        return;
      }
#line 632
      tmp = *toP;
#line 632
      (*toP) ++;
#line 632
      *tmp = (char )lo;
#line 632
      break;
    }
    case 7: 
    case 6: 
    case 5: 
    case 4: 
    case 3: 
    case 2: 
    case 1: 
#line 632
    if (toLim - (char const   *)*toP < 2L) {
#line 632
      *fromP = from;
#line 632
      return;
    }
#line 632
    tmp___0 = *toP;
#line 632
    (*toP) ++;
#line 632
    *tmp___0 = (char )((((int )lo >> 6) | ((int )hi << 2)) | 192);
#line 632
    tmp___1 = *toP;
#line 632
    (*toP) ++;
#line 632
    *tmp___1 = (char )(((int )lo & 63) | 128);
#line 632
    break;
    default: 
#line 632
    if (toLim - (char const   *)*toP < 3L) {
#line 632
      *fromP = from;
#line 632
      return;
    }
#line 632
    tmp___2 = *toP;
#line 632
    (*toP) ++;
#line 632
    *tmp___2 = (char )(((int )hi >> 4) | 224);
#line 632
    tmp___3 = *toP;
#line 632
    (*toP) ++;
#line 632
    *tmp___3 = (char )(((((int )hi & 15) << 2) | ((int )lo >> 6)) | 128);
#line 632
    tmp___4 = *toP;
#line 632
    (*toP) ++;
#line 632
    *tmp___4 = (char )(((int )lo & 63) | 128);
#line 632
    break;
    case 219: 
    case 218: 
    case 217: 
    case 216: 
#line 632
    if (toLim - (char const   *)*toP < 4L) {
#line 632
      *fromP = from;
#line 632
      return;
    }
#line 632
    plane = ((((int )hi & 3) << 2) | (((int )lo >> 6) & 3)) + 1;
#line 632
    tmp___5 = *toP;
#line 632
    (*toP) ++;
#line 632
    *tmp___5 = (char )((plane >> 2) | 240);
#line 632
    tmp___6 = *toP;
#line 632
    (*toP) ++;
#line 632
    *tmp___6 = (char )(((((int )lo >> 2) & 15) | ((plane & 3) << 4)) | 128);
#line 632
    from += 2;
#line 632
    lo2 = (unsigned char )*(from + 1);
#line 632
    tmp___7 = *toP;
#line 632
    (*toP) ++;
#line 632
    *tmp___7 = (char )((((((int )lo & 3) << 4) | (((int )((unsigned char )*(from + 0)) & 3) << 2)) | ((int )lo2 >> 6)) | 128);
#line 632
    tmp___8 = *toP;
#line 632
    (*toP) ++;
#line 632
    *tmp___8 = (char )(((int )lo2 & 63) | 128);
#line 632
    break;
    }
#line 632
    from += 2;
  }
#line 632
  *fromP = from;
#line 632
  return;
}
}
#line 633 "xmltok.c"
static void big2_toUtf16(ENCODING const   *enc , char const   **fromP , char const   *fromLim ,
                         unsigned short **toP , unsigned short const   *toLim ) 
{ 
  unsigned short *tmp ;

  {
#line 633
  if (fromLim - *fromP > (toLim - (unsigned short const   *)*toP) << 1) {
#line 633
    if (((int )((unsigned char )*((fromLim - 2) + 0)) & 248) == 216) {
#line 633
      fromLim -= 2;
    }
  }
#line 633
  while (1) {
#line 633
    if ((unsigned long )*fromP != (unsigned long )fromLim) {
#line 633
      if (! ((unsigned long )*toP != (unsigned long )toLim)) {
#line 633
        break;
      }
    } else {
#line 633
      break;
    }
#line 633
    tmp = *toP;
#line 633
    (*toP) ++;
#line 633
    *tmp = (unsigned short )(((int )((unsigned char )*(*fromP + 0)) << 8) | (int )((unsigned char )*(*fromP + 1)));
#line 633
    *fromP += 2;
  }
#line 633
  return;
}
}
#line 92 "xmltok_impl.c"
static int little2_scanComment(ENCODING const   *enc , char const   *ptr , char const   *end ,
                               char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 96
  if ((unsigned long )ptr != (unsigned long )end) {
#line 97
    if ((int const   )*(ptr + 1) == 0) {
#line 97
      if (! ((int const   )*(ptr + 0) == 45)) {
#line 98
        *nextTokPtr = ptr;
#line 99
        return (0);
      }
    } else {
#line 98
      *nextTokPtr = ptr;
#line 99
      return (0);
    }
#line 101
    ptr += 2;
#line 102
    while ((unsigned long )ptr != (unsigned long )end) {
#line 103
      if ((int const   )*(ptr + 1) == 0) {
#line 103
        tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
      } else {
#line 103
        tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 103
        tmp___0 = tmp;
      }
#line 103
      switch (tmp___0) {
      case 5: 
#line 104
      if (end - ptr < 2L) {
#line 104
        return (-2);
      }
#line 104
      ptr += 2;
#line 104
      break;
      case 6: 
#line 104
      if (end - ptr < 3L) {
#line 104
        return (-2);
      }
#line 104
      ptr += 3;
#line 104
      break;
      case 7: 
#line 104
      if (end - ptr < 4L) {
#line 104
        return (-2);
      }
#line 104
      ptr += 4;
#line 104
      break;
      case 8: 
      case 1: 
      case 0: 
#line 104
      *nextTokPtr = ptr;
#line 104
      return (0);
      case 27: 
#line 106
      ptr += 2;
#line 106
      if ((unsigned long )ptr == (unsigned long )end) {
#line 107
        return (-1);
      }
#line 108
      if ((int const   )*(ptr + 1) == 0) {
#line 108
        if ((int const   )*(ptr + 0) == 45) {
#line 109
          ptr += 2;
#line 109
          if ((unsigned long )ptr == (unsigned long )end) {
#line 110
            return (-1);
          }
#line 111
          if ((int const   )*(ptr + 1) == 0) {
#line 111
            if (! ((int const   )*(ptr + 0) == 62)) {
#line 112
              *nextTokPtr = ptr;
#line 113
              return (0);
            }
          } else {
#line 112
            *nextTokPtr = ptr;
#line 113
            return (0);
          }
#line 115
          *nextTokPtr = ptr + 2;
#line 116
          return (13);
        }
      }
#line 118
      break;
      default: 
#line 120
      ptr += 2;
#line 121
      break;
      }
    }
  }
#line 125
  return (-1);
}
}
#line 130 "xmltok_impl.c"
static int little2_scanDecl(ENCODING const   *enc , char const   *ptr , char const   *end ,
                            char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 134
  if ((unsigned long )ptr == (unsigned long )end) {
#line 135
    return (-1);
  }
#line 136
  if ((int const   )*(ptr + 1) == 0) {
#line 136
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
#line 136
    tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 136
    tmp___0 = tmp;
  }
#line 136
  switch (tmp___0) {
  case 27: 
#line 138
  tmp___1 = little2_scanComment(enc, ptr + 2, end, nextTokPtr);
#line 138
  return (tmp___1);
  case 20: 
#line 140
  *nextTokPtr = ptr + 2;
#line 141
  return (33);
  case 24: 
  case 22: 
#line 144
  ptr += 2;
#line 145
  break;
  default: 
#line 147
  *nextTokPtr = ptr;
#line 148
  return (0);
  }
#line 150
  while ((unsigned long )ptr != (unsigned long )end) {
#line 151
    if ((int const   )*(ptr + 1) == 0) {
#line 151
      tmp___3 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
#line 151
      tmp___2 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 151
      tmp___3 = tmp___2;
    }
#line 151
    switch (tmp___3) {
    case 30: 
#line 153
    if ((unsigned long )(ptr + 2) == (unsigned long )end) {
#line 154
      return (-1);
    }
#line 156
    if ((int const   )*((ptr + 2) + 1) == 0) {
#line 156
      tmp___5 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 2)];
    } else {
#line 156
      tmp___4 = unicode_byte_type((char )*((ptr + 2) + 1), (char )*((ptr + 2) + 0));
#line 156
      tmp___5 = tmp___4;
    }
#line 156
    switch (tmp___5) {
    case 30: 
    case 10: 
    case 9: 
    case 21: 
#line 158
    *nextTokPtr = ptr;
#line 159
    return (0);
    }
    case 10: 
    case 9: 
    case 21: 
#line 163
    *nextTokPtr = ptr;
#line 164
    return (16);
    case 24: 
    case 22: 
#line 167
    ptr += 2;
#line 168
    break;
    default: 
#line 170
    *nextTokPtr = ptr;
#line 171
    return (0);
    }
  }
#line 174
  return (-1);
}
}
#line 177 "xmltok_impl.c"
static int little2_checkPiTarget(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                 int *tokPtr ) 
{ 
  int upper ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 181
  upper = 0;
#line 182
  *tokPtr = 11;
#line 183
  if (end - ptr != 6L) {
#line 184
    return (1);
  }
#line 185
  if ((int const   )*(ptr + 1) == 0) {
#line 185
    tmp = (int const   )*(ptr + 0);
  } else {
#line 185
    tmp = (int const   )-1;
  }
#line 185
  switch (tmp) {
  case 120: 
#line 187
  break;
  case 88: 
#line 189
  upper = 1;
#line 190
  break;
  default: 
#line 192
  return (1);
  }
#line 194
  ptr += 2;
#line 195
  if ((int const   )*(ptr + 1) == 0) {
#line 195
    tmp___0 = (int const   )*(ptr + 0);
  } else {
#line 195
    tmp___0 = (int const   )-1;
  }
#line 195
  switch (tmp___0) {
  case 109: 
#line 197
  break;
  case 77: 
#line 199
  upper = 1;
#line 200
  break;
  default: 
#line 202
  return (1);
  }
#line 204
  ptr += 2;
#line 205
  if ((int const   )*(ptr + 1) == 0) {
#line 205
    tmp___1 = (int const   )*(ptr + 0);
  } else {
#line 205
    tmp___1 = (int const   )-1;
  }
#line 205
  switch (tmp___1) {
  case 108: 
#line 207
  break;
  case 76: 
#line 209
  upper = 1;
#line 210
  break;
  default: 
#line 212
  return (1);
  }
#line 214
  if (upper) {
#line 215
    return (0);
  }
#line 216
  *tokPtr = 12;
#line 217
  return (1);
}
}
#line 222 "xmltok_impl.c"
static int little2_scanPi(ENCODING const   *enc , char const   *ptr , char const   *end ,
                          char const   **nextTokPtr ) 
{ 
  int tok ;
  char const   *target ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 227
  target = ptr;
#line 228
  if ((unsigned long )ptr == (unsigned long )end) {
#line 229
    return (-1);
  }
#line 230
  if ((int const   )*(ptr + 1) == 0) {
#line 230
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
#line 230
    tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 230
    tmp___0 = tmp;
  }
#line 230
  switch (tmp___0) {
  case 29: 
#line 231
  if (! (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 231
    *nextTokPtr = ptr;
#line 231
    return (0);
  }
  case 24: 
  case 22: 
#line 231
  ptr += 2;
#line 231
  break;
  case 5: 
#line 231
  if (end - ptr < 2L) {
#line 231
    return (-2);
  }
#line 231
  *nextTokPtr = ptr;
#line 231
  return (0);
#line 231
  ptr += 2;
#line 231
  break;
  case 6: 
#line 231
  if (end - ptr < 3L) {
#line 231
    return (-2);
  }
#line 231
  *nextTokPtr = ptr;
#line 231
  return (0);
#line 231
  ptr += 3;
#line 231
  break;
  case 7: 
#line 231
  if (end - ptr < 4L) {
#line 231
    return (-2);
  }
#line 231
  *nextTokPtr = ptr;
#line 231
  return (0);
#line 231
  ptr += 4;
#line 231
  break;
  default: 
#line 233
  *nextTokPtr = ptr;
#line 234
  return (0);
  }
#line 236
  while ((unsigned long )ptr != (unsigned long )end) {
#line 237
    if ((int const   )*(ptr + 1) == 0) {
#line 237
      tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
#line 237
      tmp___1 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 237
      tmp___2 = tmp___1;
    }
#line 237
    switch (tmp___2) {
    case 29: 
#line 238
    if (! (namingBitmap[((int const   )namePages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 238
      *nextTokPtr = ptr;
#line 238
      return (0);
    }
    case 27: 
    case 26: 
    case 25: 
    case 24: 
    case 22: 
#line 238
    ptr += 2;
#line 238
    break;
    case 5: 
#line 238
    if (end - ptr < 2L) {
#line 238
      return (-2);
    }
#line 238
    *nextTokPtr = ptr;
#line 238
    return (0);
#line 238
    ptr += 2;
#line 238
    break;
    case 6: 
#line 238
    if (end - ptr < 3L) {
#line 238
      return (-2);
    }
#line 238
    *nextTokPtr = ptr;
#line 238
    return (0);
#line 238
    ptr += 3;
#line 238
    break;
    case 7: 
#line 238
    if (end - ptr < 4L) {
#line 238
      return (-2);
    }
#line 238
    *nextTokPtr = ptr;
#line 238
    return (0);
#line 238
    ptr += 4;
#line 238
    break;
    case 10: 
    case 9: 
    case 21: 
#line 240
    tmp___3 = little2_checkPiTarget(enc, target, ptr, & tok);
#line 240
    if (! tmp___3) {
#line 241
      *nextTokPtr = ptr;
#line 242
      return (0);
    }
#line 244
    ptr += 2;
#line 245
    while ((unsigned long )ptr != (unsigned long )end) {
#line 246
      if ((int const   )*(ptr + 1) == 0) {
#line 246
        tmp___5 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
      } else {
#line 246
        tmp___4 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 246
        tmp___5 = tmp___4;
      }
#line 246
      switch (tmp___5) {
      case 5: 
#line 247
      if (end - ptr < 2L) {
#line 247
        return (-2);
      }
#line 247
      ptr += 2;
#line 247
      break;
      case 6: 
#line 247
      if (end - ptr < 3L) {
#line 247
        return (-2);
      }
#line 247
      ptr += 3;
#line 247
      break;
      case 7: 
#line 247
      if (end - ptr < 4L) {
#line 247
        return (-2);
      }
#line 247
      ptr += 4;
#line 247
      break;
      case 8: 
      case 1: 
      case 0: 
#line 247
      *nextTokPtr = ptr;
#line 247
      return (0);
      case 15: 
#line 249
      ptr += 2;
#line 250
      if ((unsigned long )ptr == (unsigned long )end) {
#line 251
        return (-1);
      }
#line 252
      if ((int const   )*(ptr + 1) == 0) {
#line 252
        if ((int const   )*(ptr + 0) == 62) {
#line 253
          *nextTokPtr = ptr + 2;
#line 254
          return (tok);
        }
      }
#line 256
      break;
      default: 
#line 258
      ptr += 2;
#line 259
      break;
      }
    }
#line 262
    return (-1);
    case 15: 
#line 264
    tmp___6 = little2_checkPiTarget(enc, target, ptr, & tok);
#line 264
    if (! tmp___6) {
#line 265
      *nextTokPtr = ptr;
#line 266
      return (0);
    }
#line 268
    ptr += 2;
#line 269
    if ((unsigned long )ptr == (unsigned long )end) {
#line 270
      return (-1);
    }
#line 271
    if ((int const   )*(ptr + 1) == 0) {
#line 271
      if ((int const   )*(ptr + 0) == 62) {
#line 272
        *nextTokPtr = ptr + 2;
#line 273
        return (tok);
      }
    }
    default: 
#line 277
    *nextTokPtr = ptr;
#line 278
    return (0);
    }
  }
#line 281
  return (-1);
}
}
#line 288
static int little2_scanCdataSection(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                    char const   **nextTokPtr ) ;
#line 288 "xmltok_impl.c"
static char const   CDATA_LSQB___0[6]  = {      (char const   )67,      (char const   )68,      (char const   )65,      (char const   )84, 
        (char const   )65,      (char const   )91};
#line 284 "xmltok_impl.c"
static int little2_scanCdataSection(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                    char const   **nextTokPtr ) 
{ 
  int i ;

  {
#line 292
  if (end - ptr < 12L) {
#line 293
    return (-1);
  }
#line 294
  i = 0;
#line 294
  while (i < 6) {
#line 295
    if ((int const   )*(ptr + 1) == 0) {
#line 295
      if (! ((int const   )*(ptr + 0) == (int const   )CDATA_LSQB___0[i])) {
#line 296
        *nextTokPtr = ptr;
#line 297
        return (0);
      }
    } else {
#line 296
      *nextTokPtr = ptr;
#line 297
      return (0);
    }
#line 294
    i ++;
#line 294
    ptr += 2;
  }
#line 300
  *nextTokPtr = ptr;
#line 301
  return (8);
}
}
#line 304 "xmltok_impl.c"
static int little2_cdataSectionTok(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                   char const   **nextTokPtr ) 
{ 
  size_t n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 308
  if ((unsigned long )ptr == (unsigned long )end) {
#line 309
    return (-4);
  }
#line 311
  n = (size_t )(end - ptr);
#line 312
  if (n & 1UL) {
#line 313
    n &= 0xfffffffffffffffeUL;
#line 314
    if (n == 0UL) {
#line 315
      return (-1);
    }
#line 316
    end = ptr + n;
  }
#line 319
  if ((int const   )*(ptr + 1) == 0) {
#line 319
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
#line 319
    tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 319
    tmp___0 = tmp;
  }
#line 319
  switch (tmp___0) {
  case 4: 
#line 321
  ptr += 2;
#line 322
  if ((unsigned long )ptr == (unsigned long )end) {
#line 323
    return (-1);
  }
#line 324
  if ((int const   )*(ptr + 1) == 0) {
#line 324
    if (! ((int const   )*(ptr + 0) == 93)) {
#line 325
      break;
    }
  } else {
#line 325
    break;
  }
#line 326
  ptr += 2;
#line 327
  if ((unsigned long )ptr == (unsigned long )end) {
#line 328
    return (-1);
  }
#line 329
  if ((int const   )*(ptr + 1) == 0) {
#line 329
    if (! ((int const   )*(ptr + 0) == 62)) {
#line 330
      ptr -= 2;
#line 331
      break;
    }
  } else {
#line 330
    ptr -= 2;
#line 331
    break;
  }
#line 333
  *nextTokPtr = ptr + 2;
#line 334
  return (40);
  case 9: 
#line 336
  ptr += 2;
#line 337
  if ((unsigned long )ptr == (unsigned long )end) {
#line 338
    return (-1);
  }
#line 339
  if ((int const   )*(ptr + 1) == 0) {
#line 339
    tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
#line 339
    tmp___1 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 339
    tmp___2 = tmp___1;
  }
#line 339
  if (tmp___2 == 10) {
#line 340
    ptr += 2;
  }
#line 341
  *nextTokPtr = ptr;
#line 342
  return (7);
  case 10: 
#line 344
  *nextTokPtr = ptr + 2;
#line 345
  return (7);
  case 5: 
#line 346
  if (end - ptr < 2L) {
#line 346
    return (-2);
  }
#line 346
  ptr += 2;
#line 346
  break;
  case 6: 
#line 346
  if (end - ptr < 3L) {
#line 346
    return (-2);
  }
#line 346
  ptr += 3;
#line 346
  break;
  case 7: 
#line 346
  if (end - ptr < 4L) {
#line 346
    return (-2);
  }
#line 346
  ptr += 4;
#line 346
  break;
  case 8: 
  case 1: 
  case 0: 
#line 346
  *nextTokPtr = ptr;
#line 346
  return (0);
  default: 
#line 348
  ptr += 2;
#line 349
  break;
  }
#line 351
  while ((unsigned long )ptr != (unsigned long )end) {
#line 352
    if ((int const   )*(ptr + 1) == 0) {
#line 352
      tmp___4 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
#line 352
      tmp___3 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 352
      tmp___4 = tmp___3;
    }
#line 352
    switch (tmp___4) {
    case 5: 
#line 361
    if (end - ptr < 2L) {
#line 361
      *nextTokPtr = ptr;
#line 361
      return (6);
    }
#line 361
    ptr += 2;
#line 361
    break;
    case 6: 
#line 361
    if (end - ptr < 3L) {
#line 361
      *nextTokPtr = ptr;
#line 361
      return (6);
    }
#line 361
    ptr += 3;
#line 361
    break;
    case 7: 
#line 361
    if (end - ptr < 4L) {
#line 361
      *nextTokPtr = ptr;
#line 361
      return (6);
    }
#line 361
    ptr += 4;
#line 361
    break;
    case 4: 
    case 10: 
    case 9: 
    case 8: 
    case 1: 
    case 0: 
#line 369
    *nextTokPtr = ptr;
#line 370
    return (6);
    default: 
#line 372
    ptr += 2;
#line 373
    break;
    }
  }
#line 376
  *nextTokPtr = ptr;
#line 377
  return (6);
}
}
#line 382 "xmltok_impl.c"
static int little2_scanEndTag(ENCODING const   *enc , char const   *ptr , char const   *end ,
                              char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 386
  if ((unsigned long )ptr == (unsigned long )end) {
#line 387
    return (-1);
  }
#line 388
  if ((int const   )*(ptr + 1) == 0) {
#line 388
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
#line 388
    tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 388
    tmp___0 = tmp;
  }
#line 388
  switch (tmp___0) {
  case 29: 
#line 389
  if (! (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 389
    *nextTokPtr = ptr;
#line 389
    return (0);
  }
  case 24: 
  case 22: 
#line 389
  ptr += 2;
#line 389
  break;
  case 5: 
#line 389
  if (end - ptr < 2L) {
#line 389
    return (-2);
  }
#line 389
  *nextTokPtr = ptr;
#line 389
  return (0);
#line 389
  ptr += 2;
#line 389
  break;
  case 6: 
#line 389
  if (end - ptr < 3L) {
#line 389
    return (-2);
  }
#line 389
  *nextTokPtr = ptr;
#line 389
  return (0);
#line 389
  ptr += 3;
#line 389
  break;
  case 7: 
#line 389
  if (end - ptr < 4L) {
#line 389
    return (-2);
  }
#line 389
  *nextTokPtr = ptr;
#line 389
  return (0);
#line 389
  ptr += 4;
#line 389
  break;
  default: 
#line 391
  *nextTokPtr = ptr;
#line 392
  return (0);
  }
#line 394
  while ((unsigned long )ptr != (unsigned long )end) {
#line 395
    if ((int const   )*(ptr + 1) == 0) {
#line 395
      tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
#line 395
      tmp___1 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 395
      tmp___2 = tmp___1;
    }
#line 395
    switch (tmp___2) {
    case 29: 
#line 396
    if (! (namingBitmap[((int const   )namePages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 396
      *nextTokPtr = ptr;
#line 396
      return (0);
    }
    case 27: 
    case 26: 
    case 25: 
    case 24: 
    case 22: 
#line 396
    ptr += 2;
#line 396
    break;
    case 5: 
#line 396
    if (end - ptr < 2L) {
#line 396
      return (-2);
    }
#line 396
    *nextTokPtr = ptr;
#line 396
    return (0);
#line 396
    ptr += 2;
#line 396
    break;
    case 6: 
#line 396
    if (end - ptr < 3L) {
#line 396
      return (-2);
    }
#line 396
    *nextTokPtr = ptr;
#line 396
    return (0);
#line 396
    ptr += 3;
#line 396
    break;
    case 7: 
#line 396
    if (end - ptr < 4L) {
#line 396
      return (-2);
    }
#line 396
    *nextTokPtr = ptr;
#line 396
    return (0);
#line 396
    ptr += 4;
#line 396
    break;
    case 10: 
    case 9: 
    case 21: 
#line 398
    ptr += 2;
#line 398
    while ((unsigned long )ptr != (unsigned long )end) {
#line 399
      if ((int const   )*(ptr + 1) == 0) {
#line 399
        tmp___4 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
      } else {
#line 399
        tmp___3 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 399
        tmp___4 = tmp___3;
      }
#line 399
      switch (tmp___4) {
      case 10: 
      case 9: 
      case 21: 
#line 401
      break;
      case 11: 
#line 403
      *nextTokPtr = ptr + 2;
#line 404
      return (5);
      default: 
#line 406
      *nextTokPtr = ptr;
#line 407
      return (0);
      }
#line 398
      ptr += 2;
    }
#line 410
    return (-1);
    case 23: 
#line 415
    ptr += 2;
#line 416
    break;
    case 11: 
#line 419
    *nextTokPtr = ptr + 2;
#line 420
    return (5);
    default: 
#line 422
    *nextTokPtr = ptr;
#line 423
    return (0);
    }
  }
#line 426
  return (-1);
}
}
#line 431 "xmltok_impl.c"
static int little2_scanHexCharRef(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                  char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 435
  if ((unsigned long )ptr != (unsigned long )end) {
#line 436
    if ((int const   )*(ptr + 1) == 0) {
#line 436
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
#line 436
      tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 436
      tmp___0 = tmp;
    }
#line 436
    switch (tmp___0) {
    case 24: 
    case 25: 
#line 439
    break;
    default: 
#line 441
    *nextTokPtr = ptr;
#line 442
    return (0);
    }
#line 444
    ptr += 2;
#line 444
    while ((unsigned long )ptr != (unsigned long )end) {
#line 445
      if ((int const   )*(ptr + 1) == 0) {
#line 445
        tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
      } else {
#line 445
        tmp___1 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 445
        tmp___2 = tmp___1;
      }
#line 445
      switch (tmp___2) {
      case 24: 
      case 25: 
#line 448
      break;
      case 18: 
#line 450
      *nextTokPtr = ptr + 2;
#line 451
      return (10);
      default: 
#line 453
      *nextTokPtr = ptr;
#line 454
      return (0);
      }
#line 444
      ptr += 2;
    }
  }
#line 458
  return (-1);
}
}
#line 463 "xmltok_impl.c"
static int little2_scanCharRef(ENCODING const   *enc , char const   *ptr , char const   *end ,
                               char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 467
  if ((unsigned long )ptr != (unsigned long )end) {
#line 468
    if ((int const   )*(ptr + 1) == 0) {
#line 468
      if ((int const   )*(ptr + 0) == 120) {
#line 469
        tmp = little2_scanHexCharRef(enc, ptr + 2, end, nextTokPtr);
#line 469
        return (tmp);
      }
    }
#line 470
    if ((int const   )*(ptr + 1) == 0) {
#line 470
      tmp___1 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
#line 470
      tmp___0 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 470
      tmp___1 = tmp___0;
    }
#line 470
    switch (tmp___1) {
    case 25: 
#line 472
    break;
    default: 
#line 474
    *nextTokPtr = ptr;
#line 475
    return (0);
    }
#line 477
    ptr += 2;
#line 477
    while ((unsigned long )ptr != (unsigned long )end) {
#line 478
      if ((int const   )*(ptr + 1) == 0) {
#line 478
        tmp___3 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
      } else {
#line 478
        tmp___2 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 478
        tmp___3 = tmp___2;
      }
#line 478
      switch (tmp___3) {
      case 25: 
#line 480
      break;
      case 18: 
#line 482
      *nextTokPtr = ptr + 2;
#line 483
      return (10);
      default: 
#line 485
      *nextTokPtr = ptr;
#line 486
      return (0);
      }
#line 477
      ptr += 2;
    }
  }
#line 490
  return (-1);
}
}
#line 495 "xmltok_impl.c"
static int little2_scanRef(ENCODING const   *enc , char const   *ptr , char const   *end ,
                           char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 499
  if ((unsigned long )ptr == (unsigned long )end) {
#line 500
    return (-1);
  }
#line 501
  if ((int const   )*(ptr + 1) == 0) {
#line 501
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
#line 501
    tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 501
    tmp___0 = tmp;
  }
#line 501
  switch (tmp___0) {
  case 29: 
#line 502
  if (! (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 502
    *nextTokPtr = ptr;
#line 502
    return (0);
  }
  case 24: 
  case 22: 
#line 502
  ptr += 2;
#line 502
  break;
  case 5: 
#line 502
  if (end - ptr < 2L) {
#line 502
    return (-2);
  }
#line 502
  *nextTokPtr = ptr;
#line 502
  return (0);
#line 502
  ptr += 2;
#line 502
  break;
  case 6: 
#line 502
  if (end - ptr < 3L) {
#line 502
    return (-2);
  }
#line 502
  *nextTokPtr = ptr;
#line 502
  return (0);
#line 502
  ptr += 3;
#line 502
  break;
  case 7: 
#line 502
  if (end - ptr < 4L) {
#line 502
    return (-2);
  }
#line 502
  *nextTokPtr = ptr;
#line 502
  return (0);
#line 502
  ptr += 4;
#line 502
  break;
  case 19: 
#line 504
  tmp___1 = little2_scanCharRef(enc, ptr + 2, end, nextTokPtr);
#line 504
  return (tmp___1);
  default: 
#line 506
  *nextTokPtr = ptr;
#line 507
  return (0);
  }
#line 509
  while ((unsigned long )ptr != (unsigned long )end) {
#line 510
    if ((int const   )*(ptr + 1) == 0) {
#line 510
      tmp___3 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
#line 510
      tmp___2 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 510
      tmp___3 = tmp___2;
    }
#line 510
    switch (tmp___3) {
    case 29: 
#line 511
    if (! (namingBitmap[((int const   )namePages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 511
      *nextTokPtr = ptr;
#line 511
      return (0);
    }
    case 27: 
    case 26: 
    case 25: 
    case 24: 
    case 22: 
#line 511
    ptr += 2;
#line 511
    break;
    case 5: 
#line 511
    if (end - ptr < 2L) {
#line 511
      return (-2);
    }
#line 511
    *nextTokPtr = ptr;
#line 511
    return (0);
#line 511
    ptr += 2;
#line 511
    break;
    case 6: 
#line 511
    if (end - ptr < 3L) {
#line 511
      return (-2);
    }
#line 511
    *nextTokPtr = ptr;
#line 511
    return (0);
#line 511
    ptr += 3;
#line 511
    break;
    case 7: 
#line 511
    if (end - ptr < 4L) {
#line 511
      return (-2);
    }
#line 511
    *nextTokPtr = ptr;
#line 511
    return (0);
#line 511
    ptr += 4;
#line 511
    break;
    case 18: 
#line 513
    *nextTokPtr = ptr + 2;
#line 514
    return (9);
    default: 
#line 516
    *nextTokPtr = ptr;
#line 517
    return (0);
    }
  }
#line 520
  return (-1);
}
}
#line 525 "xmltok_impl.c"
static int little2_scanAtts(ENCODING const   *enc , char const   *ptr , char const   *end ,
                            char const   **nextTokPtr ) 
{ 
  int hadColon ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int t ;
  int tmp___3 ;
  int open ;
  int tmp___4 ;
  int t___0 ;
  int tmp___5 ;
  int tok ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 530
  hadColon = 0;
#line 532
  while ((unsigned long )ptr != (unsigned long )end) {
#line 533
    if ((int const   )*(ptr + 1) == 0) {
#line 533
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
#line 533
      tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 533
      tmp___0 = tmp;
    }
#line 533
    switch (tmp___0) {
    case 29: 
#line 534
    if (! (namingBitmap[((int const   )namePages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 534
      *nextTokPtr = ptr;
#line 534
      return (0);
    }
    case 27: 
    case 26: 
    case 25: 
    case 24: 
    case 22: 
#line 534
    ptr += 2;
#line 534
    break;
    case 5: 
#line 534
    if (end - ptr < 2L) {
#line 534
      return (-2);
    }
#line 534
    *nextTokPtr = ptr;
#line 534
    return (0);
#line 534
    ptr += 2;
#line 534
    break;
    case 6: 
#line 534
    if (end - ptr < 3L) {
#line 534
      return (-2);
    }
#line 534
    *nextTokPtr = ptr;
#line 534
    return (0);
#line 534
    ptr += 3;
#line 534
    break;
    case 7: 
#line 534
    if (end - ptr < 4L) {
#line 534
      return (-2);
    }
#line 534
    *nextTokPtr = ptr;
#line 534
    return (0);
#line 534
    ptr += 4;
#line 534
    break;
    case 23: 
#line 537
    if (hadColon) {
#line 538
      *nextTokPtr = ptr;
#line 539
      return (0);
    }
#line 541
    hadColon = 1;
#line 542
    ptr += 2;
#line 543
    if ((unsigned long )ptr == (unsigned long )end) {
#line 544
      return (-1);
    }
#line 545
    if ((int const   )*(ptr + 1) == 0) {
#line 545
      tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
#line 545
      tmp___1 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 545
      tmp___2 = tmp___1;
    }
#line 545
    switch (tmp___2) {
    case 29: 
#line 546
    if (! (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 546
      *nextTokPtr = ptr;
#line 546
      return (0);
    }
    case 24: 
    case 22: 
#line 546
    ptr += 2;
#line 546
    break;
    case 5: 
#line 546
    if (end - ptr < 2L) {
#line 546
      return (-2);
    }
#line 546
    *nextTokPtr = ptr;
#line 546
    return (0);
#line 546
    ptr += 2;
#line 546
    break;
    case 6: 
#line 546
    if (end - ptr < 3L) {
#line 546
      return (-2);
    }
#line 546
    *nextTokPtr = ptr;
#line 546
    return (0);
#line 546
    ptr += 3;
#line 546
    break;
    case 7: 
#line 546
    if (end - ptr < 4L) {
#line 546
      return (-2);
    }
#line 546
    *nextTokPtr = ptr;
#line 546
    return (0);
#line 546
    ptr += 4;
#line 546
    break;
    default: 
#line 548
    *nextTokPtr = ptr;
#line 549
    return (0);
    }
#line 551
    break;
    case 10: 
    case 9: 
    case 21: 
#line 554
    while (1) {
#line 557
      ptr += 2;
#line 558
      if ((unsigned long )ptr == (unsigned long )end) {
#line 559
        return (-1);
      }
#line 560
      if ((int const   )*(ptr + 1) == 0) {
#line 560
        t = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
      } else {
#line 560
        tmp___3 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 560
        t = tmp___3;
      }
#line 561
      if (t == 14) {
#line 562
        break;
      }
#line 563
      switch (t) {
      case 9: 
      case 10: 
      case 21: 
#line 567
      break;
      default: 
#line 569
      *nextTokPtr = ptr;
#line 570
      return (0);
      }
    }
    case 14: 
#line 578
    hadColon = 0;
#line 580
    while (1) {
#line 581
      ptr += 2;
#line 582
      if ((unsigned long )ptr == (unsigned long )end) {
#line 583
        return (-1);
      }
#line 584
      if ((int const   )*(ptr + 1) == 0) {
#line 584
        open = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
      } else {
#line 584
        tmp___4 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 584
        open = tmp___4;
      }
#line 585
      if (open == 12) {
#line 586
        break;
      } else
#line 585
      if (open == 13) {
#line 586
        break;
      }
#line 587
      switch (open) {
      case 9: 
      case 10: 
      case 21: 
#line 591
      break;
      default: 
#line 593
      *nextTokPtr = ptr;
#line 594
      return (0);
      }
    }
#line 597
    ptr += 2;
#line 599
    while (1) {
#line 601
      if ((unsigned long )ptr == (unsigned long )end) {
#line 602
        return (-1);
      }
#line 603
      if ((int const   )*(ptr + 1) == 0) {
#line 603
        t___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
      } else {
#line 603
        tmp___5 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 603
        t___0 = tmp___5;
      }
#line 604
      if (t___0 == open) {
#line 605
        break;
      }
#line 606
      switch (t___0) {
      case 5: 
#line 607
      if (end - ptr < 2L) {
#line 607
        return (-2);
      }
#line 607
      ptr += 2;
#line 607
      break;
      case 6: 
#line 607
      if (end - ptr < 3L) {
#line 607
        return (-2);
      }
#line 607
      ptr += 3;
#line 607
      break;
      case 7: 
#line 607
      if (end - ptr < 4L) {
#line 607
        return (-2);
      }
#line 607
      ptr += 4;
#line 607
      break;
      case 8: 
      case 1: 
      case 0: 
#line 607
      *nextTokPtr = ptr;
#line 607
      return (0);
      case 3: 
#line 610
      tmp___6 = little2_scanRef(enc, ptr + 2, end, & ptr);
#line 610
      tok = tmp___6;
#line 611
      if (tok <= 0) {
#line 612
        if (tok == 0) {
#line 613
          *nextTokPtr = ptr;
        }
#line 614
        return (tok);
      }
#line 616
      break;
      case 2: 
#line 619
      *nextTokPtr = ptr;
#line 620
      return (0);
      default: 
#line 622
      ptr += 2;
#line 623
      break;
      }
    }
#line 626
    ptr += 2;
#line 627
    if ((unsigned long )ptr == (unsigned long )end) {
#line 628
      return (-1);
    }
#line 629
    if ((int const   )*(ptr + 1) == 0) {
#line 629
      tmp___8 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
#line 629
      tmp___7 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 629
      tmp___8 = tmp___7;
    }
#line 629
    switch (tmp___8) {
    case 10: 
    case 9: 
    case 21: 
#line 633
    break;
    case 17: 
#line 635
    goto sol;
    case 11: 
#line 637
    goto gt;
    default: 
#line 639
    *nextTokPtr = ptr;
#line 640
    return (0);
    }
#line 643
    while (1) {
#line 644
      ptr += 2;
#line 645
      if ((unsigned long )ptr == (unsigned long )end) {
#line 646
        return (-1);
      }
#line 647
      if ((int const   )*(ptr + 1) == 0) {
#line 647
        tmp___10 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
      } else {
#line 647
        tmp___9 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 647
        tmp___10 = tmp___9;
      }
#line 647
      switch (tmp___10) {
      case 29: 
#line 648
      if (! (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 648
        *nextTokPtr = ptr;
#line 648
        return (0);
      }
      case 24: 
      case 22: 
#line 648
      ptr += 2;
#line 648
      break;
      case 5: 
#line 648
      if (end - ptr < 2L) {
#line 648
        return (-2);
      }
#line 648
      *nextTokPtr = ptr;
#line 648
      return (0);
#line 648
      ptr += 2;
#line 648
      break;
      case 6: 
#line 648
      if (end - ptr < 3L) {
#line 648
        return (-2);
      }
#line 648
      *nextTokPtr = ptr;
#line 648
      return (0);
#line 648
      ptr += 3;
#line 648
      break;
      case 7: 
#line 648
      if (end - ptr < 4L) {
#line 648
        return (-2);
      }
#line 648
      *nextTokPtr = ptr;
#line 648
      return (0);
#line 648
      ptr += 4;
#line 648
      break;
      case 10: 
      case 9: 
      case 21: 
#line 650
      goto __Cont;
      gt: 
      case 11: 
#line 653
      *nextTokPtr = ptr + 2;
#line 654
      return (1);
      sol: 
      case 17: 
#line 657
      ptr += 2;
#line 658
      if ((unsigned long )ptr == (unsigned long )end) {
#line 659
        return (-1);
      }
#line 660
      if ((int const   )*(ptr + 1) == 0) {
#line 660
        if (! ((int const   )*(ptr + 0) == 62)) {
#line 661
          *nextTokPtr = ptr;
#line 662
          return (0);
        }
      } else {
#line 661
        *nextTokPtr = ptr;
#line 662
        return (0);
      }
#line 664
      *nextTokPtr = ptr + 2;
#line 665
      return (3);
      default: 
#line 667
      *nextTokPtr = ptr;
#line 668
      return (0);
      }
#line 670
      break;
      __Cont: /* CIL Label */ ;
    }
#line 672
    break;
    default: 
#line 675
    *nextTokPtr = ptr;
#line 676
    return (0);
    }
  }
#line 679
  return (-1);
}
}
#line 684 "xmltok_impl.c"
static int little2_scanLt(ENCODING const   *enc , char const   *ptr , char const   *end ,
                          char const   **nextTokPtr ) 
{ 
  int hadColon ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 691
  if ((unsigned long )ptr == (unsigned long )end) {
#line 692
    return (-1);
  }
#line 693
  if ((int const   )*(ptr + 1) == 0) {
#line 693
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
#line 693
    tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 693
    tmp___0 = tmp;
  }
#line 693
  switch (tmp___0) {
  case 29: 
#line 694
  if (! (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 694
    *nextTokPtr = ptr;
#line 694
    return (0);
  }
  case 24: 
  case 22: 
#line 694
  ptr += 2;
#line 694
  break;
  case 5: 
#line 694
  if (end - ptr < 2L) {
#line 694
    return (-2);
  }
#line 694
  *nextTokPtr = ptr;
#line 694
  return (0);
#line 694
  ptr += 2;
#line 694
  break;
  case 6: 
#line 694
  if (end - ptr < 3L) {
#line 694
    return (-2);
  }
#line 694
  *nextTokPtr = ptr;
#line 694
  return (0);
#line 694
  ptr += 3;
#line 694
  break;
  case 7: 
#line 694
  if (end - ptr < 4L) {
#line 694
    return (-2);
  }
#line 694
  *nextTokPtr = ptr;
#line 694
  return (0);
#line 694
  ptr += 4;
#line 694
  break;
  case 16: 
#line 696
  ptr += 2;
#line 696
  if ((unsigned long )ptr == (unsigned long )end) {
#line 697
    return (-1);
  }
#line 698
  if ((int const   )*(ptr + 1) == 0) {
#line 698
    tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
#line 698
    tmp___1 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 698
    tmp___2 = tmp___1;
  }
#line 698
  switch (tmp___2) {
  case 27: 
#line 700
  tmp___3 = little2_scanComment(enc, ptr + 2, end, nextTokPtr);
#line 700
  return (tmp___3);
  case 20: 
#line 702
  tmp___4 = little2_scanCdataSection(enc, ptr + 2, end, nextTokPtr);
#line 702
  return (tmp___4);
  }
#line 705
  *nextTokPtr = ptr;
#line 706
  return (0);
  case 15: 
#line 708
  tmp___5 = little2_scanPi(enc, ptr + 2, end, nextTokPtr);
#line 708
  return (tmp___5);
  case 17: 
#line 710
  tmp___6 = little2_scanEndTag(enc, ptr + 2, end, nextTokPtr);
#line 710
  return (tmp___6);
  default: 
#line 712
  *nextTokPtr = ptr;
#line 713
  return (0);
  }
#line 716
  hadColon = 0;
#line 719
  while ((unsigned long )ptr != (unsigned long )end) {
#line 720
    if ((int const   )*(ptr + 1) == 0) {
#line 720
      tmp___8 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
#line 720
      tmp___7 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 720
      tmp___8 = tmp___7;
    }
#line 720
    switch (tmp___8) {
    case 29: 
#line 721
    if (! (namingBitmap[((int const   )namePages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 721
      *nextTokPtr = ptr;
#line 721
      return (0);
    }
    case 27: 
    case 26: 
    case 25: 
    case 24: 
    case 22: 
#line 721
    ptr += 2;
#line 721
    break;
    case 5: 
#line 721
    if (end - ptr < 2L) {
#line 721
      return (-2);
    }
#line 721
    *nextTokPtr = ptr;
#line 721
    return (0);
#line 721
    ptr += 2;
#line 721
    break;
    case 6: 
#line 721
    if (end - ptr < 3L) {
#line 721
      return (-2);
    }
#line 721
    *nextTokPtr = ptr;
#line 721
    return (0);
#line 721
    ptr += 3;
#line 721
    break;
    case 7: 
#line 721
    if (end - ptr < 4L) {
#line 721
      return (-2);
    }
#line 721
    *nextTokPtr = ptr;
#line 721
    return (0);
#line 721
    ptr += 4;
#line 721
    break;
    case 23: 
#line 724
    if (hadColon) {
#line 725
      *nextTokPtr = ptr;
#line 726
      return (0);
    }
#line 728
    hadColon = 1;
#line 729
    ptr += 2;
#line 730
    if ((unsigned long )ptr == (unsigned long )end) {
#line 731
      return (-1);
    }
#line 732
    if ((int const   )*(ptr + 1) == 0) {
#line 732
      tmp___10 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
#line 732
      tmp___9 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 732
      tmp___10 = tmp___9;
    }
#line 732
    switch (tmp___10) {
    case 29: 
#line 733
    if (! (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 733
      *nextTokPtr = ptr;
#line 733
      return (0);
    }
    case 24: 
    case 22: 
#line 733
    ptr += 2;
#line 733
    break;
    case 5: 
#line 733
    if (end - ptr < 2L) {
#line 733
      return (-2);
    }
#line 733
    *nextTokPtr = ptr;
#line 733
    return (0);
#line 733
    ptr += 2;
#line 733
    break;
    case 6: 
#line 733
    if (end - ptr < 3L) {
#line 733
      return (-2);
    }
#line 733
    *nextTokPtr = ptr;
#line 733
    return (0);
#line 733
    ptr += 3;
#line 733
    break;
    case 7: 
#line 733
    if (end - ptr < 4L) {
#line 733
      return (-2);
    }
#line 733
    *nextTokPtr = ptr;
#line 733
    return (0);
#line 733
    ptr += 4;
#line 733
    break;
    default: 
#line 735
    *nextTokPtr = ptr;
#line 736
    return (0);
    }
#line 738
    break;
    case 10: 
    case 9: 
    case 21: 
#line 742
    ptr += 2;
#line 743
    while ((unsigned long )ptr != (unsigned long )end) {
#line 744
      if ((int const   )*(ptr + 1) == 0) {
#line 744
        tmp___12 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
      } else {
#line 744
        tmp___11 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 744
        tmp___12 = tmp___11;
      }
#line 744
      switch (tmp___12) {
      case 29: 
#line 745
      if (! (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 745
        *nextTokPtr = ptr;
#line 745
        return (0);
      }
      case 24: 
      case 22: 
#line 745
      ptr += 2;
#line 745
      break;
      case 5: 
#line 745
      if (end - ptr < 2L) {
#line 745
        return (-2);
      }
#line 745
      *nextTokPtr = ptr;
#line 745
      return (0);
#line 745
      ptr += 2;
#line 745
      break;
      case 6: 
#line 745
      if (end - ptr < 3L) {
#line 745
        return (-2);
      }
#line 745
      *nextTokPtr = ptr;
#line 745
      return (0);
#line 745
      ptr += 3;
#line 745
      break;
      case 7: 
#line 745
      if (end - ptr < 4L) {
#line 745
        return (-2);
      }
#line 745
      *nextTokPtr = ptr;
#line 745
      return (0);
#line 745
      ptr += 4;
#line 745
      break;
      case 11: 
#line 747
      goto gt;
      case 17: 
#line 749
      goto sol;
      case 10: 
      case 9: 
      case 21: 
#line 751
      ptr += 2;
#line 752
      continue;
      default: 
#line 754
      *nextTokPtr = ptr;
#line 755
      return (0);
      }
#line 757
      tmp___13 = little2_scanAtts(enc, ptr, end, nextTokPtr);
#line 757
      return (tmp___13);
    }
#line 759
    return (-1);
    gt: 
    case 11: 
#line 763
    *nextTokPtr = ptr + 2;
#line 764
    return (2);
    sol: 
    case 17: 
#line 767
    ptr += 2;
#line 768
    if ((unsigned long )ptr == (unsigned long )end) {
#line 769
      return (-1);
    }
#line 770
    if ((int const   )*(ptr + 1) == 0) {
#line 770
      if (! ((int const   )*(ptr + 0) == 62)) {
#line 771
        *nextTokPtr = ptr;
#line 772
        return (0);
      }
    } else {
#line 771
      *nextTokPtr = ptr;
#line 772
      return (0);
    }
#line 774
    *nextTokPtr = ptr + 2;
#line 775
    return (4);
    default: 
#line 777
    *nextTokPtr = ptr;
#line 778
    return (0);
    }
  }
#line 781
  return (-1);
}
}
#line 784 "xmltok_impl.c"
static int little2_contentTok(ENCODING const   *enc , char const   *ptr , char const   *end ,
                              char const   **nextTokPtr ) 
{ 
  size_t n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 788
  if ((unsigned long )ptr == (unsigned long )end) {
#line 789
    return (-4);
  }
#line 791
  n = (size_t )(end - ptr);
#line 792
  if (n & 1UL) {
#line 793
    n &= 0xfffffffffffffffeUL;
#line 794
    if (n == 0UL) {
#line 795
      return (-1);
    }
#line 796
    end = ptr + n;
  }
#line 799
  if ((int const   )*(ptr + 1) == 0) {
#line 799
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
#line 799
    tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 799
    tmp___0 = tmp;
  }
#line 799
  switch (tmp___0) {
  case 2: 
#line 801
  tmp___1 = little2_scanLt(enc, ptr + 2, end, nextTokPtr);
#line 801
  return (tmp___1);
  case 3: 
#line 803
  tmp___2 = little2_scanRef(enc, ptr + 2, end, nextTokPtr);
#line 803
  return (tmp___2);
  case 9: 
#line 805
  ptr += 2;
#line 806
  if ((unsigned long )ptr == (unsigned long )end) {
#line 807
    return (-3);
  }
#line 808
  if ((int const   )*(ptr + 1) == 0) {
#line 808
    tmp___4 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
#line 808
    tmp___3 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 808
    tmp___4 = tmp___3;
  }
#line 808
  if (tmp___4 == 10) {
#line 809
    ptr += 2;
  }
#line 810
  *nextTokPtr = ptr;
#line 811
  return (7);
  case 10: 
#line 813
  *nextTokPtr = ptr + 2;
#line 814
  return (7);
  case 4: 
#line 816
  ptr += 2;
#line 817
  if ((unsigned long )ptr == (unsigned long )end) {
#line 818
    return (-5);
  }
#line 819
  if ((int const   )*(ptr + 1) == 0) {
#line 819
    if (! ((int const   )*(ptr + 0) == 93)) {
#line 820
      break;
    }
  } else {
#line 820
    break;
  }
#line 821
  ptr += 2;
#line 822
  if ((unsigned long )ptr == (unsigned long )end) {
#line 823
    return (-5);
  }
#line 824
  if ((int const   )*(ptr + 1) == 0) {
#line 824
    if (! ((int const   )*(ptr + 0) == 62)) {
#line 825
      ptr -= 2;
#line 826
      break;
    }
  } else {
#line 825
    ptr -= 2;
#line 826
    break;
  }
#line 828
  *nextTokPtr = ptr;
#line 829
  return (0);
  case 5: 
#line 830
  if (end - ptr < 2L) {
#line 830
    return (-2);
  }
#line 830
  ptr += 2;
#line 830
  break;
  case 6: 
#line 830
  if (end - ptr < 3L) {
#line 830
    return (-2);
  }
#line 830
  ptr += 3;
#line 830
  break;
  case 7: 
#line 830
  if (end - ptr < 4L) {
#line 830
    return (-2);
  }
#line 830
  ptr += 4;
#line 830
  break;
  case 8: 
  case 1: 
  case 0: 
#line 830
  *nextTokPtr = ptr;
#line 830
  return (0);
  default: 
#line 832
  ptr += 2;
#line 833
  break;
  }
#line 835
  while ((unsigned long )ptr != (unsigned long )end) {
#line 836
    if ((int const   )*(ptr + 1) == 0) {
#line 836
      tmp___6 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
#line 836
      tmp___5 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 836
      tmp___6 = tmp___5;
    }
#line 836
    switch (tmp___6) {
    case 5: 
#line 845
    if (end - ptr < 2L) {
#line 845
      *nextTokPtr = ptr;
#line 845
      return (6);
    }
#line 845
    ptr += 2;
#line 845
    break;
    case 6: 
#line 845
    if (end - ptr < 3L) {
#line 845
      *nextTokPtr = ptr;
#line 845
      return (6);
    }
#line 845
    ptr += 3;
#line 845
    break;
    case 7: 
#line 845
    if (end - ptr < 4L) {
#line 845
      *nextTokPtr = ptr;
#line 845
      return (6);
    }
#line 845
    ptr += 4;
#line 845
    break;
    case 4: 
#line 848
    if ((unsigned long )(ptr + 2) != (unsigned long )end) {
#line 849
      if ((int const   )*((ptr + 2) + 1) == 0) {
#line 849
        if (! ((int const   )*((ptr + 2) + 0) == 93)) {
#line 850
          ptr += 2;
#line 851
          break;
        }
      } else {
#line 850
        ptr += 2;
#line 851
        break;
      }
#line 853
      if ((unsigned long )(ptr + 4) != (unsigned long )end) {
#line 854
        if ((int const   )*((ptr + 4) + 1) == 0) {
#line 854
          if (! ((int const   )*((ptr + 4) + 0) == 62)) {
#line 855
            ptr += 2;
#line 856
            break;
          }
        } else {
#line 855
          ptr += 2;
#line 856
          break;
        }
#line 858
        *nextTokPtr = ptr + 4;
#line 859
        return (0);
      }
    }
    case 10: 
    case 9: 
    case 8: 
    case 1: 
    case 0: 
    case 2: 
    case 3: 
#line 870
    *nextTokPtr = ptr;
#line 871
    return (6);
    default: 
#line 873
    ptr += 2;
#line 874
    break;
    }
  }
#line 877
  *nextTokPtr = ptr;
#line 878
  return (6);
}
}
#line 883 "xmltok_impl.c"
static int little2_scanPercent(ENCODING const   *enc , char const   *ptr , char const   *end ,
                               char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 887
  if ((unsigned long )ptr == (unsigned long )end) {
#line 888
    return (-1);
  }
#line 889
  if ((int const   )*(ptr + 1) == 0) {
#line 889
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
#line 889
    tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 889
    tmp___0 = tmp;
  }
#line 889
  switch (tmp___0) {
  case 29: 
#line 890
  if (! (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 890
    *nextTokPtr = ptr;
#line 890
    return (0);
  }
  case 24: 
  case 22: 
#line 890
  ptr += 2;
#line 890
  break;
  case 5: 
#line 890
  if (end - ptr < 2L) {
#line 890
    return (-2);
  }
#line 890
  *nextTokPtr = ptr;
#line 890
  return (0);
#line 890
  ptr += 2;
#line 890
  break;
  case 6: 
#line 890
  if (end - ptr < 3L) {
#line 890
    return (-2);
  }
#line 890
  *nextTokPtr = ptr;
#line 890
  return (0);
#line 890
  ptr += 3;
#line 890
  break;
  case 7: 
#line 890
  if (end - ptr < 4L) {
#line 890
    return (-2);
  }
#line 890
  *nextTokPtr = ptr;
#line 890
  return (0);
#line 890
  ptr += 4;
#line 890
  break;
  case 30: 
  case 9: 
  case 10: 
  case 21: 
#line 892
  *nextTokPtr = ptr;
#line 893
  return (22);
  default: 
#line 895
  *nextTokPtr = ptr;
#line 896
  return (0);
  }
#line 898
  while ((unsigned long )ptr != (unsigned long )end) {
#line 899
    if ((int const   )*(ptr + 1) == 0) {
#line 899
      tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
#line 899
      tmp___1 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 899
      tmp___2 = tmp___1;
    }
#line 899
    switch (tmp___2) {
    case 29: 
#line 900
    if (! (namingBitmap[((int const   )namePages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 900
      *nextTokPtr = ptr;
#line 900
      return (0);
    }
    case 27: 
    case 26: 
    case 25: 
    case 24: 
    case 22: 
#line 900
    ptr += 2;
#line 900
    break;
    case 5: 
#line 900
    if (end - ptr < 2L) {
#line 900
      return (-2);
    }
#line 900
    *nextTokPtr = ptr;
#line 900
    return (0);
#line 900
    ptr += 2;
#line 900
    break;
    case 6: 
#line 900
    if (end - ptr < 3L) {
#line 900
      return (-2);
    }
#line 900
    *nextTokPtr = ptr;
#line 900
    return (0);
#line 900
    ptr += 3;
#line 900
    break;
    case 7: 
#line 900
    if (end - ptr < 4L) {
#line 900
      return (-2);
    }
#line 900
    *nextTokPtr = ptr;
#line 900
    return (0);
#line 900
    ptr += 4;
#line 900
    break;
    case 18: 
#line 902
    *nextTokPtr = ptr + 2;
#line 903
    return (28);
    default: 
#line 905
    *nextTokPtr = ptr;
#line 906
    return (0);
    }
  }
#line 909
  return (-1);
}
}
#line 912 "xmltok_impl.c"
static int little2_scanPoundName(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                 char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 916
  if ((unsigned long )ptr == (unsigned long )end) {
#line 917
    return (-1);
  }
#line 918
  if ((int const   )*(ptr + 1) == 0) {
#line 918
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
#line 918
    tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 918
    tmp___0 = tmp;
  }
#line 918
  switch (tmp___0) {
  case 29: 
#line 919
  if (! (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 919
    *nextTokPtr = ptr;
#line 919
    return (0);
  }
  case 24: 
  case 22: 
#line 919
  ptr += 2;
#line 919
  break;
  case 5: 
#line 919
  if (end - ptr < 2L) {
#line 919
    return (-2);
  }
#line 919
  *nextTokPtr = ptr;
#line 919
  return (0);
#line 919
  ptr += 2;
#line 919
  break;
  case 6: 
#line 919
  if (end - ptr < 3L) {
#line 919
    return (-2);
  }
#line 919
  *nextTokPtr = ptr;
#line 919
  return (0);
#line 919
  ptr += 3;
#line 919
  break;
  case 7: 
#line 919
  if (end - ptr < 4L) {
#line 919
    return (-2);
  }
#line 919
  *nextTokPtr = ptr;
#line 919
  return (0);
#line 919
  ptr += 4;
#line 919
  break;
  default: 
#line 921
  *nextTokPtr = ptr;
#line 922
  return (0);
  }
#line 924
  while ((unsigned long )ptr != (unsigned long )end) {
#line 925
    if ((int const   )*(ptr + 1) == 0) {
#line 925
      tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
#line 925
      tmp___1 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 925
      tmp___2 = tmp___1;
    }
#line 925
    switch (tmp___2) {
    case 29: 
#line 926
    if (! (namingBitmap[((int const   )namePages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 926
      *nextTokPtr = ptr;
#line 926
      return (0);
    }
    case 27: 
    case 26: 
    case 25: 
    case 24: 
    case 22: 
#line 926
    ptr += 2;
#line 926
    break;
    case 5: 
#line 926
    if (end - ptr < 2L) {
#line 926
      return (-2);
    }
#line 926
    *nextTokPtr = ptr;
#line 926
    return (0);
#line 926
    ptr += 2;
#line 926
    break;
    case 6: 
#line 926
    if (end - ptr < 3L) {
#line 926
      return (-2);
    }
#line 926
    *nextTokPtr = ptr;
#line 926
    return (0);
#line 926
    ptr += 3;
#line 926
    break;
    case 7: 
#line 926
    if (end - ptr < 4L) {
#line 926
      return (-2);
    }
#line 926
    *nextTokPtr = ptr;
#line 926
    return (0);
#line 926
    ptr += 4;
#line 926
    break;
    case 36: 
    case 30: 
    case 11: 
    case 32: 
    case 21: 
    case 10: 
    case 9: 
#line 929
    *nextTokPtr = ptr;
#line 930
    return (20);
    default: 
#line 932
    *nextTokPtr = ptr;
#line 933
    return (0);
    }
  }
#line 936
  return (-20);
}
}
#line 939 "xmltok_impl.c"
static int little2_scanLit(int open , ENCODING const   *enc , char const   *ptr ,
                           char const   *end , char const   **nextTokPtr ) 
{ 
  int t ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 944
  while ((unsigned long )ptr != (unsigned long )end) {
#line 945
    if ((int const   )*(ptr + 1) == 0) {
#line 945
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
#line 945
      tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 945
      tmp___0 = tmp;
    }
#line 945
    t = tmp___0;
#line 946
    switch (t) {
    case 5: 
#line 947
    if (end - ptr < 2L) {
#line 947
      return (-2);
    }
#line 947
    ptr += 2;
#line 947
    break;
    case 6: 
#line 947
    if (end - ptr < 3L) {
#line 947
      return (-2);
    }
#line 947
    ptr += 3;
#line 947
    break;
    case 7: 
#line 947
    if (end - ptr < 4L) {
#line 947
      return (-2);
    }
#line 947
    ptr += 4;
#line 947
    break;
    case 8: 
    case 1: 
    case 0: 
#line 947
    *nextTokPtr = ptr;
#line 947
    return (0);
    case 13: 
    case 12: 
#line 950
    ptr += 2;
#line 951
    if (t != open) {
#line 952
      break;
    }
#line 953
    if ((unsigned long )ptr == (unsigned long )end) {
#line 954
      return (-27);
    }
#line 955
    *nextTokPtr = ptr;
#line 956
    if ((int const   )*(ptr + 1) == 0) {
#line 956
      tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
#line 956
      tmp___1 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 956
      tmp___2 = tmp___1;
    }
#line 956
    switch (tmp___2) {
    case 20: 
    case 30: 
    case 11: 
    case 10: 
    case 9: 
    case 21: 
#line 959
    return (27);
    default: 
#line 961
    return (0);
    }
    default: 
#line 964
    ptr += 2;
#line 965
    break;
    }
  }
#line 968
  return (-1);
}
}
#line 971 "xmltok_impl.c"
static int little2_prologTok(ENCODING const   *enc , char const   *ptr , char const   *end ,
                             char const   **nextTokPtr ) 
{ 
  int tok ;
  size_t n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 976
  if ((unsigned long )ptr == (unsigned long )end) {
#line 977
    return (-4);
  }
#line 979
  n = (size_t )(end - ptr);
#line 980
  if (n & 1UL) {
#line 981
    n &= 0xfffffffffffffffeUL;
#line 982
    if (n == 0UL) {
#line 983
      return (-1);
    }
#line 984
    end = ptr + n;
  }
#line 987
  if ((int const   )*(ptr + 1) == 0) {
#line 987
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
#line 987
    tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 987
    tmp___0 = tmp;
  }
#line 987
  switch (tmp___0) {
  case 12: 
#line 989
  tmp___1 = little2_scanLit(12, enc, ptr + 2, end, nextTokPtr);
#line 989
  return (tmp___1);
  case 13: 
#line 991
  tmp___2 = little2_scanLit(13, enc, ptr + 2, end, nextTokPtr);
#line 991
  return (tmp___2);
  case 2: 
#line 994
  ptr += 2;
#line 995
  if ((unsigned long )ptr == (unsigned long )end) {
#line 996
    return (-1);
  }
#line 997
  if ((int const   )*(ptr + 1) == 0) {
#line 997
    tmp___4 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
#line 997
    tmp___3 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 997
    tmp___4 = tmp___3;
  }
#line 997
  switch (tmp___4) {
  case 16: 
#line 999
  tmp___5 = little2_scanDecl(enc, ptr + 2, end, nextTokPtr);
#line 999
  return (tmp___5);
  case 15: 
#line 1001
  tmp___6 = little2_scanPi(enc, ptr + 2, end, nextTokPtr);
#line 1001
  return (tmp___6);
  case 7: 
  case 6: 
  case 5: 
  case 29: 
  case 24: 
  case 22: 
#line 1008
  *nextTokPtr = ptr - 2;
#line 1009
  return (29);
  }
#line 1011
  *nextTokPtr = ptr;
#line 1012
  return (0);
  case 9: 
#line 1015
  if ((unsigned long )(ptr + 2) == (unsigned long )end) {
#line 1016
    *nextTokPtr = end;
#line 1018
    return (-15);
  }
  case 10: 
  case 21: 
#line 1022
  while (1) {
#line 1023
    ptr += 2;
#line 1024
    if ((unsigned long )ptr == (unsigned long )end) {
#line 1025
      break;
    }
#line 1026
    if ((int const   )*(ptr + 1) == 0) {
#line 1026
      tmp___8 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
#line 1026
      tmp___7 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 1026
      tmp___8 = tmp___7;
    }
#line 1026
    switch (tmp___8) {
    case 10: 
    case 21: 
#line 1028
    break;
    case 9: 
#line 1031
    if ((unsigned long )(ptr + 2) != (unsigned long )end) {
#line 1032
      break;
    }
    default: 
#line 1035
    *nextTokPtr = ptr;
#line 1036
    return (15);
    }
  }
#line 1039
  *nextTokPtr = ptr;
#line 1040
  return (15);
  case 30: 
#line 1042
  tmp___9 = little2_scanPercent(enc, ptr + 2, end, nextTokPtr);
#line 1042
  return (tmp___9);
  case 35: 
#line 1044
  *nextTokPtr = ptr + 2;
#line 1045
  return (38);
  case 20: 
#line 1047
  *nextTokPtr = ptr + 2;
#line 1048
  return (25);
  case 4: 
#line 1050
  ptr += 2;
#line 1051
  if ((unsigned long )ptr == (unsigned long )end) {
#line 1052
    return (-26);
  }
#line 1053
  if ((int const   )*(ptr + 1) == 0) {
#line 1053
    if ((int const   )*(ptr + 0) == 93) {
#line 1054
      if ((unsigned long )(ptr + 2) == (unsigned long )end) {
#line 1055
        return (-1);
      }
#line 1056
      if ((int const   )*((ptr + 2) + 1) == 0) {
#line 1056
        if ((int const   )*((ptr + 2) + 0) == 62) {
#line 1057
          *nextTokPtr = ptr + 4;
#line 1058
          return (34);
        }
      }
    }
  }
#line 1061
  *nextTokPtr = ptr;
#line 1062
  return (26);
  case 31: 
#line 1064
  *nextTokPtr = ptr + 2;
#line 1065
  return (23);
  case 32: 
#line 1067
  ptr += 2;
#line 1068
  if ((unsigned long )ptr == (unsigned long )end) {
#line 1069
    return (-24);
  }
#line 1070
  if ((int const   )*(ptr + 1) == 0) {
#line 1070
    tmp___11 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
#line 1070
    tmp___10 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 1070
    tmp___11 = tmp___10;
  }
#line 1070
  switch (tmp___11) {
  case 33: 
#line 1072
  *nextTokPtr = ptr + 2;
#line 1073
  return (36);
  case 15: 
#line 1075
  *nextTokPtr = ptr + 2;
#line 1076
  return (35);
  case 34: 
#line 1078
  *nextTokPtr = ptr + 2;
#line 1079
  return (37);
  case 32: 
  case 36: 
  case 35: 
  case 11: 
  case 21: 
  case 10: 
  case 9: 
#line 1083
  *nextTokPtr = ptr;
#line 1084
  return (24);
  }
#line 1086
  *nextTokPtr = ptr;
#line 1087
  return (0);
  case 36: 
#line 1089
  *nextTokPtr = ptr + 2;
#line 1090
  return (21);
  case 11: 
#line 1092
  *nextTokPtr = ptr + 2;
#line 1093
  return (17);
  case 19: 
#line 1095
  tmp___12 = little2_scanPoundName(enc, ptr + 2, end, nextTokPtr);
#line 1095
  return (tmp___12);
  case 5: 
#line 1112
  if (end - ptr < 2L) {
#line 1112
    return (-2);
  }
#line 1112
  *nextTokPtr = ptr;
#line 1112
  return (0);
  case 6: 
#line 1112
  if (end - ptr < 3L) {
#line 1112
    return (-2);
  }
#line 1112
  *nextTokPtr = ptr;
#line 1112
  return (0);
  case 7: 
#line 1112
  if (end - ptr < 4L) {
#line 1112
    return (-2);
  }
#line 1112
  *nextTokPtr = ptr;
#line 1112
  return (0);
  case 24: 
  case 22: 
#line 1116
  tok = 18;
#line 1117
  ptr += 2;
#line 1118
  break;
  case 23: 
  case 27: 
  case 26: 
  case 25: 
#line 1125
  tok = 19;
#line 1126
  ptr += 2;
#line 1127
  break;
  case 29: 
#line 1129
  if (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31))) {
#line 1130
    ptr += 2;
#line 1131
    tok = 18;
#line 1132
    break;
  }
#line 1134
  if (namingBitmap[((int const   )namePages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31))) {
#line 1135
    ptr += 2;
#line 1136
    tok = 19;
#line 1137
    break;
  }
  default: 
#line 1141
  *nextTokPtr = ptr;
#line 1142
  return (0);
  }
#line 1144
  while ((unsigned long )ptr != (unsigned long )end) {
#line 1145
    if ((int const   )*(ptr + 1) == 0) {
#line 1145
      tmp___14 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
#line 1145
      tmp___13 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 1145
      tmp___14 = tmp___13;
    }
#line 1145
    switch (tmp___14) {
    case 29: 
#line 1146
    if (! (namingBitmap[((int const   )namePages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 1146
      *nextTokPtr = ptr;
#line 1146
      return (0);
    }
    case 27: 
    case 26: 
    case 25: 
    case 24: 
    case 22: 
#line 1146
    ptr += 2;
#line 1146
    break;
    case 5: 
#line 1146
    if (end - ptr < 2L) {
#line 1146
      return (-2);
    }
#line 1146
    *nextTokPtr = ptr;
#line 1146
    return (0);
#line 1146
    ptr += 2;
#line 1146
    break;
    case 6: 
#line 1146
    if (end - ptr < 3L) {
#line 1146
      return (-2);
    }
#line 1146
    *nextTokPtr = ptr;
#line 1146
    return (0);
#line 1146
    ptr += 3;
#line 1146
    break;
    case 7: 
#line 1146
    if (end - ptr < 4L) {
#line 1146
      return (-2);
    }
#line 1146
    *nextTokPtr = ptr;
#line 1146
    return (0);
#line 1146
    ptr += 4;
#line 1146
    break;
    case 10: 
    case 9: 
    case 21: 
    case 30: 
    case 20: 
    case 36: 
    case 35: 
    case 32: 
    case 11: 
#line 1150
    *nextTokPtr = ptr;
#line 1151
    return (tok);
    case 23: 
#line 1154
    ptr += 2;
#line 1155
    switch (tok) {
    case 18: 
#line 1157
    if ((unsigned long )ptr == (unsigned long )end) {
#line 1158
      return (-1);
    }
#line 1159
    tok = 41;
#line 1160
    if ((int const   )*(ptr + 1) == 0) {
#line 1160
      tmp___16 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
#line 1160
      tmp___15 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 1160
      tmp___16 = tmp___15;
    }
#line 1160
    switch (tmp___16) {
    case 29: 
#line 1161
    if (! (namingBitmap[((int const   )namePages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 1161
      *nextTokPtr = ptr;
#line 1161
      return (0);
    }
    case 27: 
    case 26: 
    case 25: 
    case 24: 
    case 22: 
#line 1161
    ptr += 2;
#line 1161
    break;
    case 5: 
#line 1161
    if (end - ptr < 2L) {
#line 1161
      return (-2);
    }
#line 1161
    *nextTokPtr = ptr;
#line 1161
    return (0);
#line 1161
    ptr += 2;
#line 1161
    break;
    case 6: 
#line 1161
    if (end - ptr < 3L) {
#line 1161
      return (-2);
    }
#line 1161
    *nextTokPtr = ptr;
#line 1161
    return (0);
#line 1161
    ptr += 3;
#line 1161
    break;
    case 7: 
#line 1161
    if (end - ptr < 4L) {
#line 1161
      return (-2);
    }
#line 1161
    *nextTokPtr = ptr;
#line 1161
    return (0);
#line 1161
    ptr += 4;
#line 1161
    break;
    default: 
#line 1163
    tok = 19;
#line 1164
    break;
    }
#line 1166
    break;
    case 41: 
#line 1168
    tok = 19;
#line 1169
    break;
    }
#line 1171
    break;
    case 34: 
#line 1174
    if (tok == 19) {
#line 1175
      *nextTokPtr = ptr;
#line 1176
      return (0);
    }
#line 1178
    *nextTokPtr = ptr + 2;
#line 1179
    return (32);
    case 33: 
#line 1181
    if (tok == 19) {
#line 1182
      *nextTokPtr = ptr;
#line 1183
      return (0);
    }
#line 1185
    *nextTokPtr = ptr + 2;
#line 1186
    return (31);
    case 15: 
#line 1188
    if (tok == 19) {
#line 1189
      *nextTokPtr = ptr;
#line 1190
      return (0);
    }
#line 1192
    *nextTokPtr = ptr + 2;
#line 1193
    return (30);
    default: 
#line 1195
    *nextTokPtr = ptr;
#line 1196
    return (0);
    }
  }
#line 1199
  return (- tok);
}
}
#line 1202 "xmltok_impl.c"
static int little2_attributeValueTok(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                     char const   **nextTokPtr ) 
{ 
  char const   *start ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1207
  if ((unsigned long )ptr == (unsigned long )end) {
#line 1208
    return (-4);
  }
#line 1209
  start = ptr;
#line 1210
  while ((unsigned long )ptr != (unsigned long )end) {
#line 1211
    if ((int const   )*(ptr + 1) == 0) {
#line 1211
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
#line 1211
      tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 1211
      tmp___0 = tmp;
    }
#line 1211
    switch (tmp___0) {
    case 5: 
#line 1214
    ptr += 2;
#line 1214
    break;
    case 6: 
#line 1214
    ptr += 3;
#line 1214
    break;
    case 7: 
#line 1214
    ptr += 4;
#line 1214
    break;
    case 3: 
#line 1217
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1218
      tmp___1 = little2_scanRef(enc, ptr + 2, end, nextTokPtr);
#line 1218
      return (tmp___1);
    }
#line 1219
    *nextTokPtr = ptr;
#line 1220
    return (6);
    case 2: 
#line 1223
    *nextTokPtr = ptr;
#line 1224
    return (0);
    case 10: 
#line 1226
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1227
      *nextTokPtr = ptr + 2;
#line 1228
      return (7);
    }
#line 1230
    *nextTokPtr = ptr;
#line 1231
    return (6);
    case 9: 
#line 1233
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1234
      ptr += 2;
#line 1235
      if ((unsigned long )ptr == (unsigned long )end) {
#line 1236
        return (-3);
      }
#line 1237
      if ((int const   )*(ptr + 1) == 0) {
#line 1237
        tmp___3 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
      } else {
#line 1237
        tmp___2 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 1237
        tmp___3 = tmp___2;
      }
#line 1237
      if (tmp___3 == 10) {
#line 1238
        ptr += 2;
      }
#line 1239
      *nextTokPtr = ptr;
#line 1240
      return (7);
    }
#line 1242
    *nextTokPtr = ptr;
#line 1243
    return (6);
    case 21: 
#line 1245
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1246
      *nextTokPtr = ptr + 2;
#line 1247
      return (39);
    }
#line 1249
    *nextTokPtr = ptr;
#line 1250
    return (6);
    default: 
#line 1252
    ptr += 2;
#line 1253
    break;
    }
  }
#line 1256
  *nextTokPtr = ptr;
#line 1257
  return (6);
}
}
#line 1260 "xmltok_impl.c"
static int little2_entityValueTok(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                  char const   **nextTokPtr ) 
{ 
  char const   *start ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tok ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1265
  if ((unsigned long )ptr == (unsigned long )end) {
#line 1266
    return (-4);
  }
#line 1267
  start = ptr;
#line 1268
  while ((unsigned long )ptr != (unsigned long )end) {
#line 1269
    if ((int const   )*(ptr + 1) == 0) {
#line 1269
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
#line 1269
      tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 1269
      tmp___0 = tmp;
    }
#line 1269
    switch (tmp___0) {
    case 5: 
#line 1272
    ptr += 2;
#line 1272
    break;
    case 6: 
#line 1272
    ptr += 3;
#line 1272
    break;
    case 7: 
#line 1272
    ptr += 4;
#line 1272
    break;
    case 3: 
#line 1275
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1276
      tmp___1 = little2_scanRef(enc, ptr + 2, end, nextTokPtr);
#line 1276
      return (tmp___1);
    }
#line 1277
    *nextTokPtr = ptr;
#line 1278
    return (6);
    case 30: 
#line 1280
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1281
      tmp___2 = little2_scanPercent(enc, ptr + 2, end, nextTokPtr);
#line 1281
      tok = tmp___2;
#line 1283
      if (tok == 22) {
#line 1283
        tmp___3 = 0;
      } else {
#line 1283
        tmp___3 = tok;
      }
#line 1283
      return (tmp___3);
    }
#line 1285
    *nextTokPtr = ptr;
#line 1286
    return (6);
    case 10: 
#line 1288
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1289
      *nextTokPtr = ptr + 2;
#line 1290
      return (7);
    }
#line 1292
    *nextTokPtr = ptr;
#line 1293
    return (6);
    case 9: 
#line 1295
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1296
      ptr += 2;
#line 1297
      if ((unsigned long )ptr == (unsigned long )end) {
#line 1298
        return (-3);
      }
#line 1299
      if ((int const   )*(ptr + 1) == 0) {
#line 1299
        tmp___5 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
      } else {
#line 1299
        tmp___4 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 1299
        tmp___5 = tmp___4;
      }
#line 1299
      if (tmp___5 == 10) {
#line 1300
        ptr += 2;
      }
#line 1301
      *nextTokPtr = ptr;
#line 1302
      return (7);
    }
#line 1304
    *nextTokPtr = ptr;
#line 1305
    return (6);
    default: 
#line 1307
    ptr += 2;
#line 1308
    break;
    }
  }
#line 1311
  *nextTokPtr = ptr;
#line 1312
  return (6);
}
}
#line 1317 "xmltok_impl.c"
static int little2_ignoreSectionTok(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                    char const   **nextTokPtr ) 
{ 
  int level ;
  size_t n ;
  int tmp ;
  int tmp___0 ;

  {
#line 1321
  level = 0;
#line 1323
  n = (size_t )(end - ptr);
#line 1324
  if (n & 1UL) {
#line 1325
    n &= 0xfffffffffffffffeUL;
#line 1326
    end = ptr + n;
  }
#line 1329
  while ((unsigned long )ptr != (unsigned long )end) {
#line 1330
    if ((int const   )*(ptr + 1) == 0) {
#line 1330
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
#line 1330
      tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 1330
      tmp___0 = tmp;
    }
#line 1330
    switch (tmp___0) {
    case 5: 
#line 1331
    if (end - ptr < 2L) {
#line 1331
      return (-2);
    }
#line 1331
    ptr += 2;
#line 1331
    break;
    case 6: 
#line 1331
    if (end - ptr < 3L) {
#line 1331
      return (-2);
    }
#line 1331
    ptr += 3;
#line 1331
    break;
    case 7: 
#line 1331
    if (end - ptr < 4L) {
#line 1331
      return (-2);
    }
#line 1331
    ptr += 4;
#line 1331
    break;
    case 8: 
    case 1: 
    case 0: 
#line 1331
    *nextTokPtr = ptr;
#line 1331
    return (0);
    case 2: 
#line 1333
    ptr += 2;
#line 1333
    if ((unsigned long )ptr == (unsigned long )end) {
#line 1334
      return (-1);
    }
#line 1335
    if ((int const   )*(ptr + 1) == 0) {
#line 1335
      if ((int const   )*(ptr + 0) == 33) {
#line 1336
        ptr += 2;
#line 1336
        if ((unsigned long )ptr == (unsigned long )end) {
#line 1337
          return (-1);
        }
#line 1338
        if ((int const   )*(ptr + 1) == 0) {
#line 1338
          if ((int const   )*(ptr + 0) == 91) {
#line 1339
            level ++;
#line 1340
            ptr += 2;
          }
        }
      }
    }
#line 1343
    break;
    case 4: 
#line 1345
    ptr += 2;
#line 1345
    if ((unsigned long )ptr == (unsigned long )end) {
#line 1346
      return (-1);
    }
#line 1347
    if ((int const   )*(ptr + 1) == 0) {
#line 1347
      if ((int const   )*(ptr + 0) == 93) {
#line 1348
        ptr += 2;
#line 1348
        if ((unsigned long )ptr == (unsigned long )end) {
#line 1349
          return (-1);
        }
#line 1350
        if ((int const   )*(ptr + 1) == 0) {
#line 1350
          if ((int const   )*(ptr + 0) == 62) {
#line 1351
            ptr += 2;
#line 1352
            if (level == 0) {
#line 1353
              *nextTokPtr = ptr;
#line 1354
              return (42);
            }
#line 1356
            level --;
          }
        }
      }
    }
#line 1359
    break;
    default: 
#line 1361
    ptr += 2;
#line 1362
    break;
    }
  }
#line 1365
  return (-1);
}
}
#line 1370 "xmltok_impl.c"
static int little2_isPublicId(ENCODING const   *enc , char const   *ptr , char const   *end ,
                              char const   **badPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1374
  ptr += 2;
#line 1375
  end -= 2;
#line 1376
  while ((unsigned long )ptr != (unsigned long )end) {
#line 1377
    if ((int const   )*(ptr + 1) == 0) {
#line 1377
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
#line 1377
      tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 1377
      tmp___0 = tmp;
    }
#line 1377
    switch (tmp___0) {
    case 23: 
    case 19: 
    case 30: 
    case 33: 
    case 16: 
    case 18: 
    case 10: 
    case 9: 
    case 15: 
    case 14: 
    case 17: 
    case 35: 
    case 34: 
    case 32: 
    case 31: 
    case 13: 
    case 27: 
    case 24: 
    case 25: 
#line 1399
    break;
    case 21: 
#line 1401
    if ((int const   )*(ptr + 1) == 0) {
#line 1401
      if ((int const   )*(ptr + 0) == 9) {
#line 1402
        *badPtr = ptr;
#line 1403
        return (0);
      }
    }
#line 1405
    break;
    case 22: 
    case 26: 
#line 1408
    if ((int const   )*(ptr + 1) == 0) {
#line 1408
      tmp___1 = (int const   )*(ptr + 0);
    } else {
#line 1408
      tmp___1 = (int const   )-1;
    }
#line 1408
    if (! (tmp___1 & -128)) {
#line 1409
      break;
    }
    default: 
#line 1411
    if ((int const   )*(ptr + 1) == 0) {
#line 1411
      tmp___2 = (int const   )*(ptr + 0);
    } else {
#line 1411
      tmp___2 = (int const   )-1;
    }
#line 1411
    switch (tmp___2) {
    case 64: 
    case 36: 
#line 1414
    break;
    default: 
#line 1416
    *badPtr = ptr;
#line 1417
    return (0);
    }
#line 1419
    break;
    }
#line 1376
    ptr += 2;
  }
#line 1422
  return (1);
}
}
#line 1430 "xmltok_impl.c"
static int little2_getAtts(ENCODING const   *enc , char const   *ptr , int attsMax ,
                           ATTRIBUTE *atts ) 
{ 
  enum __anonenum_state_1045544529 state ;
  int nAtts ;
  int open ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1434
  state = (enum __anonenum_state_1045544529 )1;
#line 1435
  nAtts = 0;
#line 1436
  open = 0;
#line 1439
  ptr += 2;
#line 1439
  while (1) {
#line 1440
    if ((int const   )*(ptr + 1) == 0) {
#line 1440
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
#line 1440
      tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 1440
      tmp___0 = tmp;
    }
#line 1440
    switch (tmp___0) {
    case 5: 
#line 1451
    if ((unsigned int )state == 0U) {
#line 1451
      if (nAtts < attsMax) {
#line 1451
        (atts + nAtts)->name = ptr;
#line 1451
        (atts + nAtts)->normalized = (char)1;
      }
#line 1451
      state = (enum __anonenum_state_1045544529 )1;
    }
#line 1451
    ptr += 0;
#line 1451
    break;
    case 6: 
#line 1451
    if ((unsigned int )state == 0U) {
#line 1451
      if (nAtts < attsMax) {
#line 1451
        (atts + nAtts)->name = ptr;
#line 1451
        (atts + nAtts)->normalized = (char)1;
      }
#line 1451
      state = (enum __anonenum_state_1045544529 )1;
    }
#line 1451
    ptr ++;
#line 1451
    break;
    case 7: 
#line 1451
    if ((unsigned int )state == 0U) {
#line 1451
      if (nAtts < attsMax) {
#line 1451
        (atts + nAtts)->name = ptr;
#line 1451
        (atts + nAtts)->normalized = (char)1;
      }
#line 1451
      state = (enum __anonenum_state_1045544529 )1;
    }
#line 1451
    ptr += 2;
#line 1451
    break;
    case 24: 
    case 22: 
    case 29: 
#line 1456
    if ((unsigned int )state == 0U) {
#line 1456
      if (nAtts < attsMax) {
#line 1456
        (atts + nAtts)->name = ptr;
#line 1456
        (atts + nAtts)->normalized = (char)1;
      }
#line 1456
      state = (enum __anonenum_state_1045544529 )1;
    }
#line 1457
    break;
    case 12: 
#line 1460
    if ((unsigned int )state != 2U) {
#line 1461
      if (nAtts < attsMax) {
#line 1462
        (atts + nAtts)->valuePtr = ptr + 2;
      }
#line 1463
      state = (enum __anonenum_state_1045544529 )2;
#line 1464
      open = 12;
    } else
#line 1466
    if (open == 12) {
#line 1467
      state = (enum __anonenum_state_1045544529 )0;
#line 1468
      if (nAtts < attsMax) {
#line 1469
        (atts + nAtts)->valueEnd = ptr;
      }
#line 1470
      nAtts ++;
    }
#line 1472
    break;
    case 13: 
#line 1474
    if ((unsigned int )state != 2U) {
#line 1475
      if (nAtts < attsMax) {
#line 1476
        (atts + nAtts)->valuePtr = ptr + 2;
      }
#line 1477
      state = (enum __anonenum_state_1045544529 )2;
#line 1478
      open = 13;
    } else
#line 1480
    if (open == 13) {
#line 1481
      state = (enum __anonenum_state_1045544529 )0;
#line 1482
      if (nAtts < attsMax) {
#line 1483
        (atts + nAtts)->valueEnd = ptr;
      }
#line 1484
      nAtts ++;
    }
#line 1486
    break;
    case 3: 
#line 1488
    if (nAtts < attsMax) {
#line 1489
      (atts + nAtts)->normalized = (char)0;
    }
#line 1490
    break;
    case 21: 
#line 1492
    if ((unsigned int )state == 1U) {
#line 1493
      state = (enum __anonenum_state_1045544529 )0;
    } else
#line 1494
    if ((unsigned int )state == 2U) {
#line 1494
      if (nAtts < attsMax) {
#line 1494
        if ((atts + nAtts)->normalized) {
#line 1494
          if ((unsigned long )ptr == (unsigned long )(atts + nAtts)->valuePtr) {
#line 1501
            (atts + nAtts)->normalized = (char)0;
          } else {
#line 1494
            if ((int const   )*(ptr + 1) == 0) {
#line 1494
              tmp___1 = (int const   )*(ptr + 0);
            } else {
#line 1494
              tmp___1 = (int const   )-1;
            }
#line 1494
            if (tmp___1 != 32) {
#line 1501
              (atts + nAtts)->normalized = (char)0;
            } else {
#line 1494
              if ((int const   )*((ptr + 2) + 1) == 0) {
#line 1494
                tmp___2 = (int const   )*((ptr + 2) + 0);
              } else {
#line 1494
                tmp___2 = (int const   )-1;
              }
#line 1494
              if (tmp___2 == 32) {
#line 1501
                (atts + nAtts)->normalized = (char)0;
              } else {
#line 1494
                if ((int const   )*((ptr + 2) + 1) == 0) {
#line 1494
                  tmp___4 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 2)];
                } else {
#line 1494
                  tmp___3 = unicode_byte_type((char )*((ptr + 2) + 1), (char )*((ptr + 2) + 0));
#line 1494
                  tmp___4 = tmp___3;
                }
#line 1494
                if (tmp___4 == open) {
#line 1501
                  (atts + nAtts)->normalized = (char)0;
                }
              }
            }
          }
        }
      }
    }
#line 1502
    break;
    case 10: 
    case 9: 
#line 1506
    if ((unsigned int )state == 1U) {
#line 1507
      state = (enum __anonenum_state_1045544529 )0;
    } else
#line 1508
    if ((unsigned int )state == 2U) {
#line 1508
      if (nAtts < attsMax) {
#line 1509
        (atts + nAtts)->normalized = (char)0;
      }
    }
#line 1510
    break;
    case 17: 
    case 11: 
#line 1513
    if ((unsigned int )state != 2U) {
#line 1514
      return (nAtts);
    }
#line 1515
    break;
    default: 
#line 1517
    break;
    }
#line 1439
    ptr += 2;
  }
}
}
#line 1523 "xmltok_impl.c"
static int little2_charRefNumber(ENCODING const   *enc , char const   *ptr ) 
{ 
  int result ;
  int c ;
  int tmp ;
  int c___0 ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1526
  result = 0;
#line 1528
  ptr += 4;
#line 1529
  if ((int const   )*(ptr + 1) == 0) {
#line 1529
    if ((int const   )*(ptr + 0) == 120) {
#line 1530
      ptr += 2;
#line 1530
      while (1) {
#line 1530
        if ((int const   )*(ptr + 1) == 0) {
#line 1530
          if ((int const   )*(ptr + 0) == 59) {
#line 1530
            break;
          }
        }
#line 1533
        if ((int const   )*(ptr + 1) == 0) {
#line 1533
          tmp = (int const   )*(ptr + 0);
        } else {
#line 1533
          tmp = (int const   )-1;
        }
#line 1533
        c = (int )tmp;
#line 1534
        switch (c) {
        case 57: 
        case 56: 
        case 55: 
        case 54: 
        case 53: 
        case 52: 
        case 51: 
        case 50: 
        case 49: 
        case 48: 
#line 1537
        result <<= 4;
#line 1538
        result |= c - 48;
#line 1539
        break;
        case 70: 
        case 69: 
        case 68: 
        case 67: 
        case 66: 
        case 65: 
#line 1542
        result <<= 4;
#line 1543
        result += 10 + (c - 65);
#line 1544
        break;
        case 102: 
        case 101: 
        case 100: 
        case 99: 
        case 98: 
        case 97: 
#line 1547
        result <<= 4;
#line 1548
        result += 10 + (c - 97);
#line 1549
        break;
        }
#line 1551
        if (result >= 1114112) {
#line 1552
          return (-1);
        }
#line 1530
        ptr += 2;
      }
    } else {
#line 1529
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1556
    while (1) {
#line 1556
      if ((int const   )*(ptr + 1) == 0) {
#line 1556
        if ((int const   )*(ptr + 0) == 59) {
#line 1556
          break;
        }
      }
#line 1557
      if ((int const   )*(ptr + 1) == 0) {
#line 1557
        tmp___0 = (int const   )*(ptr + 0);
      } else {
#line 1557
        tmp___0 = (int const   )-1;
      }
#line 1557
      c___0 = (int )tmp___0;
#line 1558
      result *= 10;
#line 1559
      result += c___0 - 48;
#line 1560
      if (result >= 1114112) {
#line 1561
        return (-1);
      }
#line 1556
      ptr += 2;
    }
  }
#line 1564
  tmp___1 = checkCharRefNumber(result);
#line 1564
  return (tmp___1);
}
}
#line 1567 "xmltok_impl.c"
static int little2_predefinedEntityName(ENCODING const   *enc , char const   *ptr ,
                                        char const   *end ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1571
  switch ((end - ptr) / 2L) {
  case 2L: 
#line 1573
  if ((int const   )*((ptr + 2) + 1) == 0) {
#line 1573
    if ((int const   )*((ptr + 2) + 0) == 116) {
#line 1574
      if ((int const   )*(ptr + 1) == 0) {
#line 1574
        tmp = (int const   )*(ptr + 0);
      } else {
#line 1574
        tmp = (int const   )-1;
      }
#line 1574
      switch (tmp) {
      case 108: 
#line 1576
      return (60);
      case 103: 
#line 1578
      return (62);
      }
    }
  }
#line 1581
  break;
  case 3L: 
#line 1583
  if ((int const   )*(ptr + 1) == 0) {
#line 1583
    if ((int const   )*(ptr + 0) == 97) {
#line 1584
      ptr += 2;
#line 1585
      if ((int const   )*(ptr + 1) == 0) {
#line 1585
        if ((int const   )*(ptr + 0) == 109) {
#line 1586
          ptr += 2;
#line 1587
          if ((int const   )*(ptr + 1) == 0) {
#line 1587
            if ((int const   )*(ptr + 0) == 112) {
#line 1588
              return (38);
            }
          }
        }
      }
    }
  }
#line 1591
  break;
  case 4L: 
#line 1593
  if ((int const   )*(ptr + 1) == 0) {
#line 1593
    tmp___0 = (int const   )*(ptr + 0);
  } else {
#line 1593
    tmp___0 = (int const   )-1;
  }
#line 1593
  switch (tmp___0) {
  case 113: 
#line 1595
  ptr += 2;
#line 1596
  if ((int const   )*(ptr + 1) == 0) {
#line 1596
    if ((int const   )*(ptr + 0) == 117) {
#line 1597
      ptr += 2;
#line 1598
      if ((int const   )*(ptr + 1) == 0) {
#line 1598
        if ((int const   )*(ptr + 0) == 111) {
#line 1599
          ptr += 2;
#line 1600
          if ((int const   )*(ptr + 1) == 0) {
#line 1600
            if ((int const   )*(ptr + 0) == 116) {
#line 1601
              return (34);
            }
          }
        }
      }
    }
  }
#line 1604
  break;
  case 97: 
#line 1606
  ptr += 2;
#line 1607
  if ((int const   )*(ptr + 1) == 0) {
#line 1607
    if ((int const   )*(ptr + 0) == 112) {
#line 1608
      ptr += 2;
#line 1609
      if ((int const   )*(ptr + 1) == 0) {
#line 1609
        if ((int const   )*(ptr + 0) == 111) {
#line 1610
          ptr += 2;
#line 1611
          if ((int const   )*(ptr + 1) == 0) {
#line 1611
            if ((int const   )*(ptr + 0) == 115) {
#line 1612
              return (39);
            }
          }
        }
      }
    }
  }
#line 1615
  break;
  }
  }
#line 1618
  return (0);
}
}
#line 1621 "xmltok_impl.c"
static int little2_sameName(ENCODING const   *enc , char const   *ptr1 , char const   *ptr2 ) 
{ 
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 1624
  while (1) {
#line 1625
    if ((int const   )*(ptr1 + 1) == 0) {
#line 1625
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr1];
    } else {
#line 1625
      tmp = unicode_byte_type((char )*(ptr1 + 1), (char )*(ptr1 + 0));
#line 1625
      tmp___0 = tmp;
    }
#line 1625
    switch (tmp___0) {
    case 7: 
#line 1630
    tmp___1 = ptr1;
#line 1630
    ptr1 ++;
#line 1630
    tmp___2 = ptr2;
#line 1630
    ptr2 ++;
#line 1630
    if ((int const   )*tmp___1 != (int const   )*tmp___2) {
#line 1630
      return (0);
    }
    case 6: 
#line 1630
    tmp___3 = ptr1;
#line 1630
    ptr1 ++;
#line 1630
    tmp___4 = ptr2;
#line 1630
    ptr2 ++;
#line 1630
    if ((int const   )*tmp___3 != (int const   )*tmp___4) {
#line 1630
      return (0);
    }
    case 5: 
#line 1630
    tmp___5 = ptr1;
#line 1630
    ptr1 ++;
#line 1630
    tmp___6 = ptr2;
#line 1630
    ptr2 ++;
#line 1630
    if ((int const   )*tmp___5 != (int const   )*tmp___6) {
#line 1630
      return (0);
    }
#line 1633
    tmp___7 = ptr1;
#line 1633
    ptr1 ++;
#line 1633
    tmp___8 = ptr2;
#line 1633
    ptr2 ++;
#line 1633
    if ((int const   )*tmp___7 != (int const   )*tmp___8) {
#line 1634
      return (0);
    }
#line 1635
    break;
    case 27: 
    case 26: 
    case 25: 
    case 24: 
    case 23: 
    case 22: 
    case 29: 
#line 1645
    tmp___9 = ptr2;
#line 1645
    ptr2 ++;
#line 1645
    tmp___10 = ptr1;
#line 1645
    ptr1 ++;
#line 1645
    if ((int const   )*tmp___9 != (int const   )*tmp___10) {
#line 1646
      return (0);
    }
#line 1648
    tmp___11 = ptr2;
#line 1648
    ptr2 ++;
#line 1648
    tmp___12 = ptr1;
#line 1648
    ptr1 ++;
#line 1648
    if ((int const   )*tmp___11 != (int const   )*tmp___12) {
#line 1649
      return (0);
    }
#line 1659
    break;
    default: ;
#line 1663
    if ((int const   )*(ptr2 + 1) == 0) {
#line 1663
      tmp___18 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr2];
    } else {
#line 1663
      tmp___17 = unicode_byte_type((char )*(ptr2 + 1), (char )*(ptr2 + 0));
#line 1663
      tmp___18 = tmp___17;
    }
#line 1663
    switch (tmp___18) {
    case 27: 
    case 26: 
    case 25: 
    case 24: 
    case 23: 
    case 22: 
    case 29: 
    case 7: 
    case 6: 
    case 5: 
#line 1676
    return (0);
    default: 
#line 1678
    return (1);
    }
    }
  }
}
}
#line 1685 "xmltok_impl.c"
static int little2_nameMatchesAscii(ENCODING const   *enc , char const   *ptr1 , char const   *end1 ,
                                    char const   *ptr2 ) 
{ 


  {
#line 1689
  while (*ptr2) {
#line 1690
    if ((unsigned long )ptr1 == (unsigned long )end1) {
#line 1691
      return (0);
    }
#line 1692
    if ((int const   )*(ptr1 + 1) == 0) {
#line 1692
      if (! ((int const   )*(ptr1 + 0) == (int const   )*ptr2)) {
#line 1693
        return (0);
      }
    } else {
#line 1693
      return (0);
    }
#line 1689
    ptr1 += 2;
#line 1689
    ptr2 ++;
  }
#line 1695
  return ((unsigned long )ptr1 == (unsigned long )end1);
}
}
#line 1698 "xmltok_impl.c"
static int little2_nameLength(ENCODING const   *enc , char const   *ptr ) 
{ 
  char const   *start ;
  int tmp ;
  int tmp___0 ;

  {
#line 1701
  start = ptr;
#line 1702
  while (1) {
#line 1703
    if ((int const   )*(ptr + 1) == 0) {
#line 1703
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
#line 1703
      tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 1703
      tmp___0 = tmp;
    }
#line 1703
    switch (tmp___0) {
    case 5: 
#line 1706
    ptr += 2;
#line 1706
    break;
    case 6: 
#line 1706
    ptr += 3;
#line 1706
    break;
    case 7: 
#line 1706
    ptr += 4;
#line 1706
    break;
    case 27: 
    case 26: 
    case 25: 
    case 24: 
    case 23: 
    case 22: 
    case 29: 
#line 1717
    ptr += 2;
#line 1718
    break;
    default: 
#line 1720
    return ((int )(ptr - start));
    }
  }
}
}
#line 1725 "xmltok_impl.c"
static char const   *little2_skipS(ENCODING const   *enc , char const   *ptr ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1728
  while (1) {
#line 1729
    if ((int const   )*(ptr + 1) == 0) {
#line 1729
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
#line 1729
      tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 1729
      tmp___0 = tmp;
    }
#line 1729
    switch (tmp___0) {
    case 21: 
    case 9: 
    case 10: 
#line 1733
    ptr += 2;
#line 1734
    break;
    default: 
#line 1736
    return (ptr);
    }
  }
}
}
#line 1741 "xmltok_impl.c"
static void little2_updatePosition(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                   POSITION *pos ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1747
  while ((unsigned long )ptr < (unsigned long )end) {
#line 1748
    if ((int const   )*(ptr + 1) == 0) {
#line 1748
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
#line 1748
      tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 1748
      tmp___0 = tmp;
    }
#line 1748
    switch (tmp___0) {
    case 5: 
#line 1753
    ptr += 2;
#line 1753
    break;
    case 6: 
#line 1753
    ptr += 3;
#line 1753
    break;
    case 7: 
#line 1753
    ptr += 4;
#line 1753
    break;
    case 10: 
#line 1756
    pos->columnNumber = (XML_Size )-1;
#line 1757
    (pos->lineNumber) ++;
#line 1758
    ptr += 2;
#line 1759
    break;
    case 9: 
#line 1761
    (pos->lineNumber) ++;
#line 1762
    ptr += 2;
#line 1763
    if ((unsigned long )ptr != (unsigned long )end) {
#line 1763
      if ((int const   )*(ptr + 1) == 0) {
#line 1763
        tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
      } else {
#line 1763
        tmp___1 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 1763
        tmp___2 = tmp___1;
      }
#line 1763
      if (tmp___2 == 10) {
#line 1764
        ptr += 2;
      }
    }
#line 1765
    pos->columnNumber = (XML_Size )-1;
#line 1766
    break;
    default: 
#line 1768
    ptr += 2;
#line 1769
    break;
    }
#line 1771
    (pos->columnNumber) ++;
  }
#line 1773
  return;
}
}
#line 717 "xmltok.c"
static struct normal_encoding  const  little2_encoding_ns  = 
#line 717 "xmltok.c"
     {{{& little2_prologTok, & little2_contentTok, & little2_cdataSectionTok, & little2_ignoreSectionTok},
     {& little2_attributeValueTok, & little2_entityValueTok}, & little2_sameName,
     & little2_nameMatchesAscii, & little2_nameLength, & little2_skipS, & little2_getAtts,
     & little2_charRefNumber, & little2_predefinedEntityName, & little2_updatePosition,
     & little2_isPublicId, & little2_toUtf8, & little2_toUtf16, 2, (char)0, (char)1},
    {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)21,
     (unsigned char)10, (unsigned char)0, (unsigned char)0, (unsigned char)9, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)21, (unsigned char)16, (unsigned char)12,
     (unsigned char)19, (unsigned char)28, (unsigned char)30, (unsigned char)3, (unsigned char)13,
     (unsigned char)31, (unsigned char)32, (unsigned char)33, (unsigned char)34, (unsigned char)35,
     (unsigned char)27, (unsigned char)26, (unsigned char)17, (unsigned char)25, (unsigned char)25,
     (unsigned char)25, (unsigned char)25, (unsigned char)25, (unsigned char)25, (unsigned char)25,
     (unsigned char)25, (unsigned char)25, (unsigned char)25, (unsigned char)23, (unsigned char)18,
     (unsigned char)2, (unsigned char)14, (unsigned char)11, (unsigned char)15, (unsigned char)28,
     (unsigned char)24, (unsigned char)24, (unsigned char)24, (unsigned char)24, (unsigned char)24,
     (unsigned char)24, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)20, (unsigned char)28, (unsigned char)4, (unsigned char)28,
     (unsigned char)22, (unsigned char)28, (unsigned char)24, (unsigned char)24, (unsigned char)24,
     (unsigned char)24, (unsigned char)24, (unsigned char)24, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)28, (unsigned char)36,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)22, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)22, (unsigned char)28, (unsigned char)26, (unsigned char)28,
     (unsigned char)28, (unsigned char)22, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)28, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)28, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22}, (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                                                    char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0};
#line 734 "xmltok.c"
static struct normal_encoding  const  little2_encoding  = 
#line 734
     {{{& little2_prologTok, & little2_contentTok, & little2_cdataSectionTok, & little2_ignoreSectionTok},
     {& little2_attributeValueTok, & little2_entityValueTok}, & little2_sameName,
     & little2_nameMatchesAscii, & little2_nameLength, & little2_skipS, & little2_getAtts,
     & little2_charRefNumber, & little2_predefinedEntityName, & little2_updatePosition,
     & little2_isPublicId, & little2_toUtf8, & little2_toUtf16, 2, (char)0, (char)1},
    {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)21,
     (unsigned char)10, (unsigned char)0, (unsigned char)0, (unsigned char)9, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)21, (unsigned char)16, (unsigned char)12,
     (unsigned char)19, (unsigned char)28, (unsigned char)30, (unsigned char)3, (unsigned char)13,
     (unsigned char)31, (unsigned char)32, (unsigned char)33, (unsigned char)34, (unsigned char)35,
     (unsigned char)27, (unsigned char)26, (unsigned char)17, (unsigned char)25, (unsigned char)25,
     (unsigned char)25, (unsigned char)25, (unsigned char)25, (unsigned char)25, (unsigned char)25,
     (unsigned char)25, (unsigned char)25, (unsigned char)25, (unsigned char)22, (unsigned char)18,
     (unsigned char)2, (unsigned char)14, (unsigned char)11, (unsigned char)15, (unsigned char)28,
     (unsigned char)24, (unsigned char)24, (unsigned char)24, (unsigned char)24, (unsigned char)24,
     (unsigned char)24, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)20, (unsigned char)28, (unsigned char)4, (unsigned char)28,
     (unsigned char)22, (unsigned char)28, (unsigned char)24, (unsigned char)24, (unsigned char)24,
     (unsigned char)24, (unsigned char)24, (unsigned char)24, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)28, (unsigned char)36,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)22, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)22, (unsigned char)28, (unsigned char)26, (unsigned char)28,
     (unsigned char)28, (unsigned char)22, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)28, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)28, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22}, (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                                                    char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0};
#line 755 "xmltok.c"
static struct normal_encoding  const  internal_little2_encoding_ns  = 
#line 755
     {{{& little2_prologTok, & little2_contentTok, & little2_cdataSectionTok, & little2_ignoreSectionTok},
     {& little2_attributeValueTok, & little2_entityValueTok}, & little2_sameName,
     & little2_nameMatchesAscii, & little2_nameLength, & little2_skipS, & little2_getAtts,
     & little2_charRefNumber, & little2_predefinedEntityName, & little2_updatePosition,
     & little2_isPublicId, & little2_toUtf8, & little2_toUtf16, 2, (char)0, (char)1},
    {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)21,
     (unsigned char)10, (unsigned char)0, (unsigned char)0, (unsigned char)21, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)21, (unsigned char)16, (unsigned char)12,
     (unsigned char)19, (unsigned char)28, (unsigned char)30, (unsigned char)3, (unsigned char)13,
     (unsigned char)31, (unsigned char)32, (unsigned char)33, (unsigned char)34, (unsigned char)35,
     (unsigned char)27, (unsigned char)26, (unsigned char)17, (unsigned char)25, (unsigned char)25,
     (unsigned char)25, (unsigned char)25, (unsigned char)25, (unsigned char)25, (unsigned char)25,
     (unsigned char)25, (unsigned char)25, (unsigned char)25, (unsigned char)23, (unsigned char)18,
     (unsigned char)2, (unsigned char)14, (unsigned char)11, (unsigned char)15, (unsigned char)28,
     (unsigned char)24, (unsigned char)24, (unsigned char)24, (unsigned char)24, (unsigned char)24,
     (unsigned char)24, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)20, (unsigned char)28, (unsigned char)4, (unsigned char)28,
     (unsigned char)22, (unsigned char)28, (unsigned char)24, (unsigned char)24, (unsigned char)24,
     (unsigned char)24, (unsigned char)24, (unsigned char)24, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)28, (unsigned char)36,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)22, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)22, (unsigned char)28, (unsigned char)26, (unsigned char)28,
     (unsigned char)28, (unsigned char)22, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)28, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)28, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22}, (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                                                    char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0};
#line 766 "xmltok.c"
static struct normal_encoding  const  internal_little2_encoding  = 
#line 766
     {{{& little2_prologTok, & little2_contentTok, & little2_cdataSectionTok, & little2_ignoreSectionTok},
     {& little2_attributeValueTok, & little2_entityValueTok}, & little2_sameName,
     & little2_nameMatchesAscii, & little2_nameLength, & little2_skipS, & little2_getAtts,
     & little2_charRefNumber, & little2_predefinedEntityName, & little2_updatePosition,
     & little2_isPublicId, & little2_toUtf8, & little2_toUtf16, 2, (char)0, (char)1},
    {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)21,
     (unsigned char)10, (unsigned char)0, (unsigned char)0, (unsigned char)21, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)21, (unsigned char)16, (unsigned char)12,
     (unsigned char)19, (unsigned char)28, (unsigned char)30, (unsigned char)3, (unsigned char)13,
     (unsigned char)31, (unsigned char)32, (unsigned char)33, (unsigned char)34, (unsigned char)35,
     (unsigned char)27, (unsigned char)26, (unsigned char)17, (unsigned char)25, (unsigned char)25,
     (unsigned char)25, (unsigned char)25, (unsigned char)25, (unsigned char)25, (unsigned char)25,
     (unsigned char)25, (unsigned char)25, (unsigned char)25, (unsigned char)22, (unsigned char)18,
     (unsigned char)2, (unsigned char)14, (unsigned char)11, (unsigned char)15, (unsigned char)28,
     (unsigned char)24, (unsigned char)24, (unsigned char)24, (unsigned char)24, (unsigned char)24,
     (unsigned char)24, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)20, (unsigned char)28, (unsigned char)4, (unsigned char)28,
     (unsigned char)22, (unsigned char)28, (unsigned char)24, (unsigned char)24, (unsigned char)24,
     (unsigned char)24, (unsigned char)24, (unsigned char)24, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)28, (unsigned char)36,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)22, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)22, (unsigned char)28, (unsigned char)26, (unsigned char)28,
     (unsigned char)28, (unsigned char)22, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)28, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)28, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22}, (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                                                    char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0};
#line 92 "xmltok_impl.c"
static int big2_scanComment(ENCODING const   *enc , char const   *ptr , char const   *end ,
                            char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 96
  if ((unsigned long )ptr != (unsigned long )end) {
#line 97
    if ((int const   )*(ptr + 0) == 0) {
#line 97
      if (! ((int const   )*(ptr + 1) == 45)) {
#line 98
        *nextTokPtr = ptr;
#line 99
        return (0);
      }
    } else {
#line 98
      *nextTokPtr = ptr;
#line 99
      return (0);
    }
#line 101
    ptr += 2;
#line 102
    while ((unsigned long )ptr != (unsigned long )end) {
#line 103
      if ((int const   )*(ptr + 0) == 0) {
#line 103
        tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
      } else {
#line 103
        tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 103
        tmp___0 = tmp;
      }
#line 103
      switch (tmp___0) {
      case 5: 
#line 104
      if (end - ptr < 2L) {
#line 104
        return (-2);
      }
#line 104
      ptr += 2;
#line 104
      break;
      case 6: 
#line 104
      if (end - ptr < 3L) {
#line 104
        return (-2);
      }
#line 104
      ptr += 3;
#line 104
      break;
      case 7: 
#line 104
      if (end - ptr < 4L) {
#line 104
        return (-2);
      }
#line 104
      ptr += 4;
#line 104
      break;
      case 8: 
      case 1: 
      case 0: 
#line 104
      *nextTokPtr = ptr;
#line 104
      return (0);
      case 27: 
#line 106
      ptr += 2;
#line 106
      if ((unsigned long )ptr == (unsigned long )end) {
#line 107
        return (-1);
      }
#line 108
      if ((int const   )*(ptr + 0) == 0) {
#line 108
        if ((int const   )*(ptr + 1) == 45) {
#line 109
          ptr += 2;
#line 109
          if ((unsigned long )ptr == (unsigned long )end) {
#line 110
            return (-1);
          }
#line 111
          if ((int const   )*(ptr + 0) == 0) {
#line 111
            if (! ((int const   )*(ptr + 1) == 62)) {
#line 112
              *nextTokPtr = ptr;
#line 113
              return (0);
            }
          } else {
#line 112
            *nextTokPtr = ptr;
#line 113
            return (0);
          }
#line 115
          *nextTokPtr = ptr + 2;
#line 116
          return (13);
        }
      }
#line 118
      break;
      default: 
#line 120
      ptr += 2;
#line 121
      break;
      }
    }
  }
#line 125
  return (-1);
}
}
#line 130 "xmltok_impl.c"
static int big2_scanDecl(ENCODING const   *enc , char const   *ptr , char const   *end ,
                         char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 134
  if ((unsigned long )ptr == (unsigned long )end) {
#line 135
    return (-1);
  }
#line 136
  if ((int const   )*(ptr + 0) == 0) {
#line 136
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
#line 136
    tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 136
    tmp___0 = tmp;
  }
#line 136
  switch (tmp___0) {
  case 27: 
#line 138
  tmp___1 = big2_scanComment(enc, ptr + 2, end, nextTokPtr);
#line 138
  return (tmp___1);
  case 20: 
#line 140
  *nextTokPtr = ptr + 2;
#line 141
  return (33);
  case 24: 
  case 22: 
#line 144
  ptr += 2;
#line 145
  break;
  default: 
#line 147
  *nextTokPtr = ptr;
#line 148
  return (0);
  }
#line 150
  while ((unsigned long )ptr != (unsigned long )end) {
#line 151
    if ((int const   )*(ptr + 0) == 0) {
#line 151
      tmp___3 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
#line 151
      tmp___2 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 151
      tmp___3 = tmp___2;
    }
#line 151
    switch (tmp___3) {
    case 30: 
#line 153
    if ((unsigned long )(ptr + 2) == (unsigned long )end) {
#line 154
      return (-1);
    }
#line 156
    if ((int const   )*((ptr + 2) + 0) == 0) {
#line 156
      tmp___5 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*((ptr + 2) + 1)];
    } else {
#line 156
      tmp___4 = unicode_byte_type((char )*((ptr + 2) + 0), (char )*((ptr + 2) + 1));
#line 156
      tmp___5 = tmp___4;
    }
#line 156
    switch (tmp___5) {
    case 30: 
    case 10: 
    case 9: 
    case 21: 
#line 158
    *nextTokPtr = ptr;
#line 159
    return (0);
    }
    case 10: 
    case 9: 
    case 21: 
#line 163
    *nextTokPtr = ptr;
#line 164
    return (16);
    case 24: 
    case 22: 
#line 167
    ptr += 2;
#line 168
    break;
    default: 
#line 170
    *nextTokPtr = ptr;
#line 171
    return (0);
    }
  }
#line 174
  return (-1);
}
}
#line 177 "xmltok_impl.c"
static int big2_checkPiTarget(ENCODING const   *enc , char const   *ptr , char const   *end ,
                              int *tokPtr ) 
{ 
  int upper ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 181
  upper = 0;
#line 182
  *tokPtr = 11;
#line 183
  if (end - ptr != 6L) {
#line 184
    return (1);
  }
#line 185
  if ((int const   )*(ptr + 0) == 0) {
#line 185
    tmp = (int const   )*(ptr + 1);
  } else {
#line 185
    tmp = (int const   )-1;
  }
#line 185
  switch (tmp) {
  case 120: 
#line 187
  break;
  case 88: 
#line 189
  upper = 1;
#line 190
  break;
  default: 
#line 192
  return (1);
  }
#line 194
  ptr += 2;
#line 195
  if ((int const   )*(ptr + 0) == 0) {
#line 195
    tmp___0 = (int const   )*(ptr + 1);
  } else {
#line 195
    tmp___0 = (int const   )-1;
  }
#line 195
  switch (tmp___0) {
  case 109: 
#line 197
  break;
  case 77: 
#line 199
  upper = 1;
#line 200
  break;
  default: 
#line 202
  return (1);
  }
#line 204
  ptr += 2;
#line 205
  if ((int const   )*(ptr + 0) == 0) {
#line 205
    tmp___1 = (int const   )*(ptr + 1);
  } else {
#line 205
    tmp___1 = (int const   )-1;
  }
#line 205
  switch (tmp___1) {
  case 108: 
#line 207
  break;
  case 76: 
#line 209
  upper = 1;
#line 210
  break;
  default: 
#line 212
  return (1);
  }
#line 214
  if (upper) {
#line 215
    return (0);
  }
#line 216
  *tokPtr = 12;
#line 217
  return (1);
}
}
#line 222 "xmltok_impl.c"
static int big2_scanPi(ENCODING const   *enc , char const   *ptr , char const   *end ,
                       char const   **nextTokPtr ) 
{ 
  int tok ;
  char const   *target ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 227
  target = ptr;
#line 228
  if ((unsigned long )ptr == (unsigned long )end) {
#line 229
    return (-1);
  }
#line 230
  if ((int const   )*(ptr + 0) == 0) {
#line 230
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
#line 230
    tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 230
    tmp___0 = tmp;
  }
#line 230
  switch (tmp___0) {
  case 29: 
#line 231
  if (! (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 231
    *nextTokPtr = ptr;
#line 231
    return (0);
  }
  case 24: 
  case 22: 
#line 231
  ptr += 2;
#line 231
  break;
  case 5: 
#line 231
  if (end - ptr < 2L) {
#line 231
    return (-2);
  }
#line 231
  *nextTokPtr = ptr;
#line 231
  return (0);
#line 231
  ptr += 2;
#line 231
  break;
  case 6: 
#line 231
  if (end - ptr < 3L) {
#line 231
    return (-2);
  }
#line 231
  *nextTokPtr = ptr;
#line 231
  return (0);
#line 231
  ptr += 3;
#line 231
  break;
  case 7: 
#line 231
  if (end - ptr < 4L) {
#line 231
    return (-2);
  }
#line 231
  *nextTokPtr = ptr;
#line 231
  return (0);
#line 231
  ptr += 4;
#line 231
  break;
  default: 
#line 233
  *nextTokPtr = ptr;
#line 234
  return (0);
  }
#line 236
  while ((unsigned long )ptr != (unsigned long )end) {
#line 237
    if ((int const   )*(ptr + 0) == 0) {
#line 237
      tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
#line 237
      tmp___1 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 237
      tmp___2 = tmp___1;
    }
#line 237
    switch (tmp___2) {
    case 29: 
#line 238
    if (! (namingBitmap[((int const   )namePages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 238
      *nextTokPtr = ptr;
#line 238
      return (0);
    }
    case 27: 
    case 26: 
    case 25: 
    case 24: 
    case 22: 
#line 238
    ptr += 2;
#line 238
    break;
    case 5: 
#line 238
    if (end - ptr < 2L) {
#line 238
      return (-2);
    }
#line 238
    *nextTokPtr = ptr;
#line 238
    return (0);
#line 238
    ptr += 2;
#line 238
    break;
    case 6: 
#line 238
    if (end - ptr < 3L) {
#line 238
      return (-2);
    }
#line 238
    *nextTokPtr = ptr;
#line 238
    return (0);
#line 238
    ptr += 3;
#line 238
    break;
    case 7: 
#line 238
    if (end - ptr < 4L) {
#line 238
      return (-2);
    }
#line 238
    *nextTokPtr = ptr;
#line 238
    return (0);
#line 238
    ptr += 4;
#line 238
    break;
    case 10: 
    case 9: 
    case 21: 
#line 240
    tmp___3 = big2_checkPiTarget(enc, target, ptr, & tok);
#line 240
    if (! tmp___3) {
#line 241
      *nextTokPtr = ptr;
#line 242
      return (0);
    }
#line 244
    ptr += 2;
#line 245
    while ((unsigned long )ptr != (unsigned long )end) {
#line 246
      if ((int const   )*(ptr + 0) == 0) {
#line 246
        tmp___5 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
      } else {
#line 246
        tmp___4 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 246
        tmp___5 = tmp___4;
      }
#line 246
      switch (tmp___5) {
      case 5: 
#line 247
      if (end - ptr < 2L) {
#line 247
        return (-2);
      }
#line 247
      ptr += 2;
#line 247
      break;
      case 6: 
#line 247
      if (end - ptr < 3L) {
#line 247
        return (-2);
      }
#line 247
      ptr += 3;
#line 247
      break;
      case 7: 
#line 247
      if (end - ptr < 4L) {
#line 247
        return (-2);
      }
#line 247
      ptr += 4;
#line 247
      break;
      case 8: 
      case 1: 
      case 0: 
#line 247
      *nextTokPtr = ptr;
#line 247
      return (0);
      case 15: 
#line 249
      ptr += 2;
#line 250
      if ((unsigned long )ptr == (unsigned long )end) {
#line 251
        return (-1);
      }
#line 252
      if ((int const   )*(ptr + 0) == 0) {
#line 252
        if ((int const   )*(ptr + 1) == 62) {
#line 253
          *nextTokPtr = ptr + 2;
#line 254
          return (tok);
        }
      }
#line 256
      break;
      default: 
#line 258
      ptr += 2;
#line 259
      break;
      }
    }
#line 262
    return (-1);
    case 15: 
#line 264
    tmp___6 = big2_checkPiTarget(enc, target, ptr, & tok);
#line 264
    if (! tmp___6) {
#line 265
      *nextTokPtr = ptr;
#line 266
      return (0);
    }
#line 268
    ptr += 2;
#line 269
    if ((unsigned long )ptr == (unsigned long )end) {
#line 270
      return (-1);
    }
#line 271
    if ((int const   )*(ptr + 0) == 0) {
#line 271
      if ((int const   )*(ptr + 1) == 62) {
#line 272
        *nextTokPtr = ptr + 2;
#line 273
        return (tok);
      }
    }
    default: 
#line 277
    *nextTokPtr = ptr;
#line 278
    return (0);
    }
  }
#line 281
  return (-1);
}
}
#line 288
static int big2_scanCdataSection(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                 char const   **nextTokPtr ) ;
#line 288 "xmltok_impl.c"
static char const   CDATA_LSQB___1[6]  = {      (char const   )67,      (char const   )68,      (char const   )65,      (char const   )84, 
        (char const   )65,      (char const   )91};
#line 284 "xmltok_impl.c"
static int big2_scanCdataSection(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                 char const   **nextTokPtr ) 
{ 
  int i ;

  {
#line 292
  if (end - ptr < 12L) {
#line 293
    return (-1);
  }
#line 294
  i = 0;
#line 294
  while (i < 6) {
#line 295
    if ((int const   )*(ptr + 0) == 0) {
#line 295
      if (! ((int const   )*(ptr + 1) == (int const   )CDATA_LSQB___1[i])) {
#line 296
        *nextTokPtr = ptr;
#line 297
        return (0);
      }
    } else {
#line 296
      *nextTokPtr = ptr;
#line 297
      return (0);
    }
#line 294
    i ++;
#line 294
    ptr += 2;
  }
#line 300
  *nextTokPtr = ptr;
#line 301
  return (8);
}
}
#line 304 "xmltok_impl.c"
static int big2_cdataSectionTok(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                char const   **nextTokPtr ) 
{ 
  size_t n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 308
  if ((unsigned long )ptr == (unsigned long )end) {
#line 309
    return (-4);
  }
#line 311
  n = (size_t )(end - ptr);
#line 312
  if (n & 1UL) {
#line 313
    n &= 0xfffffffffffffffeUL;
#line 314
    if (n == 0UL) {
#line 315
      return (-1);
    }
#line 316
    end = ptr + n;
  }
#line 319
  if ((int const   )*(ptr + 0) == 0) {
#line 319
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
#line 319
    tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 319
    tmp___0 = tmp;
  }
#line 319
  switch (tmp___0) {
  case 4: 
#line 321
  ptr += 2;
#line 322
  if ((unsigned long )ptr == (unsigned long )end) {
#line 323
    return (-1);
  }
#line 324
  if ((int const   )*(ptr + 0) == 0) {
#line 324
    if (! ((int const   )*(ptr + 1) == 93)) {
#line 325
      break;
    }
  } else {
#line 325
    break;
  }
#line 326
  ptr += 2;
#line 327
  if ((unsigned long )ptr == (unsigned long )end) {
#line 328
    return (-1);
  }
#line 329
  if ((int const   )*(ptr + 0) == 0) {
#line 329
    if (! ((int const   )*(ptr + 1) == 62)) {
#line 330
      ptr -= 2;
#line 331
      break;
    }
  } else {
#line 330
    ptr -= 2;
#line 331
    break;
  }
#line 333
  *nextTokPtr = ptr + 2;
#line 334
  return (40);
  case 9: 
#line 336
  ptr += 2;
#line 337
  if ((unsigned long )ptr == (unsigned long )end) {
#line 338
    return (-1);
  }
#line 339
  if ((int const   )*(ptr + 0) == 0) {
#line 339
    tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
#line 339
    tmp___1 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 339
    tmp___2 = tmp___1;
  }
#line 339
  if (tmp___2 == 10) {
#line 340
    ptr += 2;
  }
#line 341
  *nextTokPtr = ptr;
#line 342
  return (7);
  case 10: 
#line 344
  *nextTokPtr = ptr + 2;
#line 345
  return (7);
  case 5: 
#line 346
  if (end - ptr < 2L) {
#line 346
    return (-2);
  }
#line 346
  ptr += 2;
#line 346
  break;
  case 6: 
#line 346
  if (end - ptr < 3L) {
#line 346
    return (-2);
  }
#line 346
  ptr += 3;
#line 346
  break;
  case 7: 
#line 346
  if (end - ptr < 4L) {
#line 346
    return (-2);
  }
#line 346
  ptr += 4;
#line 346
  break;
  case 8: 
  case 1: 
  case 0: 
#line 346
  *nextTokPtr = ptr;
#line 346
  return (0);
  default: 
#line 348
  ptr += 2;
#line 349
  break;
  }
#line 351
  while ((unsigned long )ptr != (unsigned long )end) {
#line 352
    if ((int const   )*(ptr + 0) == 0) {
#line 352
      tmp___4 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
#line 352
      tmp___3 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 352
      tmp___4 = tmp___3;
    }
#line 352
    switch (tmp___4) {
    case 5: 
#line 361
    if (end - ptr < 2L) {
#line 361
      *nextTokPtr = ptr;
#line 361
      return (6);
    }
#line 361
    ptr += 2;
#line 361
    break;
    case 6: 
#line 361
    if (end - ptr < 3L) {
#line 361
      *nextTokPtr = ptr;
#line 361
      return (6);
    }
#line 361
    ptr += 3;
#line 361
    break;
    case 7: 
#line 361
    if (end - ptr < 4L) {
#line 361
      *nextTokPtr = ptr;
#line 361
      return (6);
    }
#line 361
    ptr += 4;
#line 361
    break;
    case 4: 
    case 10: 
    case 9: 
    case 8: 
    case 1: 
    case 0: 
#line 369
    *nextTokPtr = ptr;
#line 370
    return (6);
    default: 
#line 372
    ptr += 2;
#line 373
    break;
    }
  }
#line 376
  *nextTokPtr = ptr;
#line 377
  return (6);
}
}
#line 382 "xmltok_impl.c"
static int big2_scanEndTag(ENCODING const   *enc , char const   *ptr , char const   *end ,
                           char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 386
  if ((unsigned long )ptr == (unsigned long )end) {
#line 387
    return (-1);
  }
#line 388
  if ((int const   )*(ptr + 0) == 0) {
#line 388
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
#line 388
    tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 388
    tmp___0 = tmp;
  }
#line 388
  switch (tmp___0) {
  case 29: 
#line 389
  if (! (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 389
    *nextTokPtr = ptr;
#line 389
    return (0);
  }
  case 24: 
  case 22: 
#line 389
  ptr += 2;
#line 389
  break;
  case 5: 
#line 389
  if (end - ptr < 2L) {
#line 389
    return (-2);
  }
#line 389
  *nextTokPtr = ptr;
#line 389
  return (0);
#line 389
  ptr += 2;
#line 389
  break;
  case 6: 
#line 389
  if (end - ptr < 3L) {
#line 389
    return (-2);
  }
#line 389
  *nextTokPtr = ptr;
#line 389
  return (0);
#line 389
  ptr += 3;
#line 389
  break;
  case 7: 
#line 389
  if (end - ptr < 4L) {
#line 389
    return (-2);
  }
#line 389
  *nextTokPtr = ptr;
#line 389
  return (0);
#line 389
  ptr += 4;
#line 389
  break;
  default: 
#line 391
  *nextTokPtr = ptr;
#line 392
  return (0);
  }
#line 394
  while ((unsigned long )ptr != (unsigned long )end) {
#line 395
    if ((int const   )*(ptr + 0) == 0) {
#line 395
      tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
#line 395
      tmp___1 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 395
      tmp___2 = tmp___1;
    }
#line 395
    switch (tmp___2) {
    case 29: 
#line 396
    if (! (namingBitmap[((int const   )namePages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 396
      *nextTokPtr = ptr;
#line 396
      return (0);
    }
    case 27: 
    case 26: 
    case 25: 
    case 24: 
    case 22: 
#line 396
    ptr += 2;
#line 396
    break;
    case 5: 
#line 396
    if (end - ptr < 2L) {
#line 396
      return (-2);
    }
#line 396
    *nextTokPtr = ptr;
#line 396
    return (0);
#line 396
    ptr += 2;
#line 396
    break;
    case 6: 
#line 396
    if (end - ptr < 3L) {
#line 396
      return (-2);
    }
#line 396
    *nextTokPtr = ptr;
#line 396
    return (0);
#line 396
    ptr += 3;
#line 396
    break;
    case 7: 
#line 396
    if (end - ptr < 4L) {
#line 396
      return (-2);
    }
#line 396
    *nextTokPtr = ptr;
#line 396
    return (0);
#line 396
    ptr += 4;
#line 396
    break;
    case 10: 
    case 9: 
    case 21: 
#line 398
    ptr += 2;
#line 398
    while ((unsigned long )ptr != (unsigned long )end) {
#line 399
      if ((int const   )*(ptr + 0) == 0) {
#line 399
        tmp___4 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
      } else {
#line 399
        tmp___3 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 399
        tmp___4 = tmp___3;
      }
#line 399
      switch (tmp___4) {
      case 10: 
      case 9: 
      case 21: 
#line 401
      break;
      case 11: 
#line 403
      *nextTokPtr = ptr + 2;
#line 404
      return (5);
      default: 
#line 406
      *nextTokPtr = ptr;
#line 407
      return (0);
      }
#line 398
      ptr += 2;
    }
#line 410
    return (-1);
    case 23: 
#line 415
    ptr += 2;
#line 416
    break;
    case 11: 
#line 419
    *nextTokPtr = ptr + 2;
#line 420
    return (5);
    default: 
#line 422
    *nextTokPtr = ptr;
#line 423
    return (0);
    }
  }
#line 426
  return (-1);
}
}
#line 431 "xmltok_impl.c"
static int big2_scanHexCharRef(ENCODING const   *enc , char const   *ptr , char const   *end ,
                               char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 435
  if ((unsigned long )ptr != (unsigned long )end) {
#line 436
    if ((int const   )*(ptr + 0) == 0) {
#line 436
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
#line 436
      tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 436
      tmp___0 = tmp;
    }
#line 436
    switch (tmp___0) {
    case 24: 
    case 25: 
#line 439
    break;
    default: 
#line 441
    *nextTokPtr = ptr;
#line 442
    return (0);
    }
#line 444
    ptr += 2;
#line 444
    while ((unsigned long )ptr != (unsigned long )end) {
#line 445
      if ((int const   )*(ptr + 0) == 0) {
#line 445
        tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
      } else {
#line 445
        tmp___1 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 445
        tmp___2 = tmp___1;
      }
#line 445
      switch (tmp___2) {
      case 24: 
      case 25: 
#line 448
      break;
      case 18: 
#line 450
      *nextTokPtr = ptr + 2;
#line 451
      return (10);
      default: 
#line 453
      *nextTokPtr = ptr;
#line 454
      return (0);
      }
#line 444
      ptr += 2;
    }
  }
#line 458
  return (-1);
}
}
#line 463 "xmltok_impl.c"
static int big2_scanCharRef(ENCODING const   *enc , char const   *ptr , char const   *end ,
                            char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 467
  if ((unsigned long )ptr != (unsigned long )end) {
#line 468
    if ((int const   )*(ptr + 0) == 0) {
#line 468
      if ((int const   )*(ptr + 1) == 120) {
#line 469
        tmp = big2_scanHexCharRef(enc, ptr + 2, end, nextTokPtr);
#line 469
        return (tmp);
      }
    }
#line 470
    if ((int const   )*(ptr + 0) == 0) {
#line 470
      tmp___1 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
#line 470
      tmp___0 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 470
      tmp___1 = tmp___0;
    }
#line 470
    switch (tmp___1) {
    case 25: 
#line 472
    break;
    default: 
#line 474
    *nextTokPtr = ptr;
#line 475
    return (0);
    }
#line 477
    ptr += 2;
#line 477
    while ((unsigned long )ptr != (unsigned long )end) {
#line 478
      if ((int const   )*(ptr + 0) == 0) {
#line 478
        tmp___3 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
      } else {
#line 478
        tmp___2 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 478
        tmp___3 = tmp___2;
      }
#line 478
      switch (tmp___3) {
      case 25: 
#line 480
      break;
      case 18: 
#line 482
      *nextTokPtr = ptr + 2;
#line 483
      return (10);
      default: 
#line 485
      *nextTokPtr = ptr;
#line 486
      return (0);
      }
#line 477
      ptr += 2;
    }
  }
#line 490
  return (-1);
}
}
#line 495 "xmltok_impl.c"
static int big2_scanRef(ENCODING const   *enc , char const   *ptr , char const   *end ,
                        char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 499
  if ((unsigned long )ptr == (unsigned long )end) {
#line 500
    return (-1);
  }
#line 501
  if ((int const   )*(ptr + 0) == 0) {
#line 501
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
#line 501
    tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 501
    tmp___0 = tmp;
  }
#line 501
  switch (tmp___0) {
  case 29: 
#line 502
  if (! (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 502
    *nextTokPtr = ptr;
#line 502
    return (0);
  }
  case 24: 
  case 22: 
#line 502
  ptr += 2;
#line 502
  break;
  case 5: 
#line 502
  if (end - ptr < 2L) {
#line 502
    return (-2);
  }
#line 502
  *nextTokPtr = ptr;
#line 502
  return (0);
#line 502
  ptr += 2;
#line 502
  break;
  case 6: 
#line 502
  if (end - ptr < 3L) {
#line 502
    return (-2);
  }
#line 502
  *nextTokPtr = ptr;
#line 502
  return (0);
#line 502
  ptr += 3;
#line 502
  break;
  case 7: 
#line 502
  if (end - ptr < 4L) {
#line 502
    return (-2);
  }
#line 502
  *nextTokPtr = ptr;
#line 502
  return (0);
#line 502
  ptr += 4;
#line 502
  break;
  case 19: 
#line 504
  tmp___1 = big2_scanCharRef(enc, ptr + 2, end, nextTokPtr);
#line 504
  return (tmp___1);
  default: 
#line 506
  *nextTokPtr = ptr;
#line 507
  return (0);
  }
#line 509
  while ((unsigned long )ptr != (unsigned long )end) {
#line 510
    if ((int const   )*(ptr + 0) == 0) {
#line 510
      tmp___3 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
#line 510
      tmp___2 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 510
      tmp___3 = tmp___2;
    }
#line 510
    switch (tmp___3) {
    case 29: 
#line 511
    if (! (namingBitmap[((int const   )namePages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 511
      *nextTokPtr = ptr;
#line 511
      return (0);
    }
    case 27: 
    case 26: 
    case 25: 
    case 24: 
    case 22: 
#line 511
    ptr += 2;
#line 511
    break;
    case 5: 
#line 511
    if (end - ptr < 2L) {
#line 511
      return (-2);
    }
#line 511
    *nextTokPtr = ptr;
#line 511
    return (0);
#line 511
    ptr += 2;
#line 511
    break;
    case 6: 
#line 511
    if (end - ptr < 3L) {
#line 511
      return (-2);
    }
#line 511
    *nextTokPtr = ptr;
#line 511
    return (0);
#line 511
    ptr += 3;
#line 511
    break;
    case 7: 
#line 511
    if (end - ptr < 4L) {
#line 511
      return (-2);
    }
#line 511
    *nextTokPtr = ptr;
#line 511
    return (0);
#line 511
    ptr += 4;
#line 511
    break;
    case 18: 
#line 513
    *nextTokPtr = ptr + 2;
#line 514
    return (9);
    default: 
#line 516
    *nextTokPtr = ptr;
#line 517
    return (0);
    }
  }
#line 520
  return (-1);
}
}
#line 525 "xmltok_impl.c"
static int big2_scanAtts(ENCODING const   *enc , char const   *ptr , char const   *end ,
                         char const   **nextTokPtr ) 
{ 
  int hadColon ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int t ;
  int tmp___3 ;
  int open ;
  int tmp___4 ;
  int t___0 ;
  int tmp___5 ;
  int tok ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 530
  hadColon = 0;
#line 532
  while ((unsigned long )ptr != (unsigned long )end) {
#line 533
    if ((int const   )*(ptr + 0) == 0) {
#line 533
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
#line 533
      tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 533
      tmp___0 = tmp;
    }
#line 533
    switch (tmp___0) {
    case 29: 
#line 534
    if (! (namingBitmap[((int const   )namePages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 534
      *nextTokPtr = ptr;
#line 534
      return (0);
    }
    case 27: 
    case 26: 
    case 25: 
    case 24: 
    case 22: 
#line 534
    ptr += 2;
#line 534
    break;
    case 5: 
#line 534
    if (end - ptr < 2L) {
#line 534
      return (-2);
    }
#line 534
    *nextTokPtr = ptr;
#line 534
    return (0);
#line 534
    ptr += 2;
#line 534
    break;
    case 6: 
#line 534
    if (end - ptr < 3L) {
#line 534
      return (-2);
    }
#line 534
    *nextTokPtr = ptr;
#line 534
    return (0);
#line 534
    ptr += 3;
#line 534
    break;
    case 7: 
#line 534
    if (end - ptr < 4L) {
#line 534
      return (-2);
    }
#line 534
    *nextTokPtr = ptr;
#line 534
    return (0);
#line 534
    ptr += 4;
#line 534
    break;
    case 23: 
#line 537
    if (hadColon) {
#line 538
      *nextTokPtr = ptr;
#line 539
      return (0);
    }
#line 541
    hadColon = 1;
#line 542
    ptr += 2;
#line 543
    if ((unsigned long )ptr == (unsigned long )end) {
#line 544
      return (-1);
    }
#line 545
    if ((int const   )*(ptr + 0) == 0) {
#line 545
      tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
#line 545
      tmp___1 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 545
      tmp___2 = tmp___1;
    }
#line 545
    switch (tmp___2) {
    case 29: 
#line 546
    if (! (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 546
      *nextTokPtr = ptr;
#line 546
      return (0);
    }
    case 24: 
    case 22: 
#line 546
    ptr += 2;
#line 546
    break;
    case 5: 
#line 546
    if (end - ptr < 2L) {
#line 546
      return (-2);
    }
#line 546
    *nextTokPtr = ptr;
#line 546
    return (0);
#line 546
    ptr += 2;
#line 546
    break;
    case 6: 
#line 546
    if (end - ptr < 3L) {
#line 546
      return (-2);
    }
#line 546
    *nextTokPtr = ptr;
#line 546
    return (0);
#line 546
    ptr += 3;
#line 546
    break;
    case 7: 
#line 546
    if (end - ptr < 4L) {
#line 546
      return (-2);
    }
#line 546
    *nextTokPtr = ptr;
#line 546
    return (0);
#line 546
    ptr += 4;
#line 546
    break;
    default: 
#line 548
    *nextTokPtr = ptr;
#line 549
    return (0);
    }
#line 551
    break;
    case 10: 
    case 9: 
    case 21: 
#line 554
    while (1) {
#line 557
      ptr += 2;
#line 558
      if ((unsigned long )ptr == (unsigned long )end) {
#line 559
        return (-1);
      }
#line 560
      if ((int const   )*(ptr + 0) == 0) {
#line 560
        t = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
      } else {
#line 560
        tmp___3 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 560
        t = tmp___3;
      }
#line 561
      if (t == 14) {
#line 562
        break;
      }
#line 563
      switch (t) {
      case 9: 
      case 10: 
      case 21: 
#line 567
      break;
      default: 
#line 569
      *nextTokPtr = ptr;
#line 570
      return (0);
      }
    }
    case 14: 
#line 578
    hadColon = 0;
#line 580
    while (1) {
#line 581
      ptr += 2;
#line 582
      if ((unsigned long )ptr == (unsigned long )end) {
#line 583
        return (-1);
      }
#line 584
      if ((int const   )*(ptr + 0) == 0) {
#line 584
        open = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
      } else {
#line 584
        tmp___4 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 584
        open = tmp___4;
      }
#line 585
      if (open == 12) {
#line 586
        break;
      } else
#line 585
      if (open == 13) {
#line 586
        break;
      }
#line 587
      switch (open) {
      case 9: 
      case 10: 
      case 21: 
#line 591
      break;
      default: 
#line 593
      *nextTokPtr = ptr;
#line 594
      return (0);
      }
    }
#line 597
    ptr += 2;
#line 599
    while (1) {
#line 601
      if ((unsigned long )ptr == (unsigned long )end) {
#line 602
        return (-1);
      }
#line 603
      if ((int const   )*(ptr + 0) == 0) {
#line 603
        t___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
      } else {
#line 603
        tmp___5 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 603
        t___0 = tmp___5;
      }
#line 604
      if (t___0 == open) {
#line 605
        break;
      }
#line 606
      switch (t___0) {
      case 5: 
#line 607
      if (end - ptr < 2L) {
#line 607
        return (-2);
      }
#line 607
      ptr += 2;
#line 607
      break;
      case 6: 
#line 607
      if (end - ptr < 3L) {
#line 607
        return (-2);
      }
#line 607
      ptr += 3;
#line 607
      break;
      case 7: 
#line 607
      if (end - ptr < 4L) {
#line 607
        return (-2);
      }
#line 607
      ptr += 4;
#line 607
      break;
      case 8: 
      case 1: 
      case 0: 
#line 607
      *nextTokPtr = ptr;
#line 607
      return (0);
      case 3: 
#line 610
      tmp___6 = big2_scanRef(enc, ptr + 2, end, & ptr);
#line 610
      tok = tmp___6;
#line 611
      if (tok <= 0) {
#line 612
        if (tok == 0) {
#line 613
          *nextTokPtr = ptr;
        }
#line 614
        return (tok);
      }
#line 616
      break;
      case 2: 
#line 619
      *nextTokPtr = ptr;
#line 620
      return (0);
      default: 
#line 622
      ptr += 2;
#line 623
      break;
      }
    }
#line 626
    ptr += 2;
#line 627
    if ((unsigned long )ptr == (unsigned long )end) {
#line 628
      return (-1);
    }
#line 629
    if ((int const   )*(ptr + 0) == 0) {
#line 629
      tmp___8 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
#line 629
      tmp___7 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 629
      tmp___8 = tmp___7;
    }
#line 629
    switch (tmp___8) {
    case 10: 
    case 9: 
    case 21: 
#line 633
    break;
    case 17: 
#line 635
    goto sol;
    case 11: 
#line 637
    goto gt;
    default: 
#line 639
    *nextTokPtr = ptr;
#line 640
    return (0);
    }
#line 643
    while (1) {
#line 644
      ptr += 2;
#line 645
      if ((unsigned long )ptr == (unsigned long )end) {
#line 646
        return (-1);
      }
#line 647
      if ((int const   )*(ptr + 0) == 0) {
#line 647
        tmp___10 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
      } else {
#line 647
        tmp___9 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 647
        tmp___10 = tmp___9;
      }
#line 647
      switch (tmp___10) {
      case 29: 
#line 648
      if (! (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 648
        *nextTokPtr = ptr;
#line 648
        return (0);
      }
      case 24: 
      case 22: 
#line 648
      ptr += 2;
#line 648
      break;
      case 5: 
#line 648
      if (end - ptr < 2L) {
#line 648
        return (-2);
      }
#line 648
      *nextTokPtr = ptr;
#line 648
      return (0);
#line 648
      ptr += 2;
#line 648
      break;
      case 6: 
#line 648
      if (end - ptr < 3L) {
#line 648
        return (-2);
      }
#line 648
      *nextTokPtr = ptr;
#line 648
      return (0);
#line 648
      ptr += 3;
#line 648
      break;
      case 7: 
#line 648
      if (end - ptr < 4L) {
#line 648
        return (-2);
      }
#line 648
      *nextTokPtr = ptr;
#line 648
      return (0);
#line 648
      ptr += 4;
#line 648
      break;
      case 10: 
      case 9: 
      case 21: 
#line 650
      goto __Cont;
      gt: 
      case 11: 
#line 653
      *nextTokPtr = ptr + 2;
#line 654
      return (1);
      sol: 
      case 17: 
#line 657
      ptr += 2;
#line 658
      if ((unsigned long )ptr == (unsigned long )end) {
#line 659
        return (-1);
      }
#line 660
      if ((int const   )*(ptr + 0) == 0) {
#line 660
        if (! ((int const   )*(ptr + 1) == 62)) {
#line 661
          *nextTokPtr = ptr;
#line 662
          return (0);
        }
      } else {
#line 661
        *nextTokPtr = ptr;
#line 662
        return (0);
      }
#line 664
      *nextTokPtr = ptr + 2;
#line 665
      return (3);
      default: 
#line 667
      *nextTokPtr = ptr;
#line 668
      return (0);
      }
#line 670
      break;
      __Cont: /* CIL Label */ ;
    }
#line 672
    break;
    default: 
#line 675
    *nextTokPtr = ptr;
#line 676
    return (0);
    }
  }
#line 679
  return (-1);
}
}
#line 684 "xmltok_impl.c"
static int big2_scanLt(ENCODING const   *enc , char const   *ptr , char const   *end ,
                       char const   **nextTokPtr ) 
{ 
  int hadColon ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 691
  if ((unsigned long )ptr == (unsigned long )end) {
#line 692
    return (-1);
  }
#line 693
  if ((int const   )*(ptr + 0) == 0) {
#line 693
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
#line 693
    tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 693
    tmp___0 = tmp;
  }
#line 693
  switch (tmp___0) {
  case 29: 
#line 694
  if (! (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 694
    *nextTokPtr = ptr;
#line 694
    return (0);
  }
  case 24: 
  case 22: 
#line 694
  ptr += 2;
#line 694
  break;
  case 5: 
#line 694
  if (end - ptr < 2L) {
#line 694
    return (-2);
  }
#line 694
  *nextTokPtr = ptr;
#line 694
  return (0);
#line 694
  ptr += 2;
#line 694
  break;
  case 6: 
#line 694
  if (end - ptr < 3L) {
#line 694
    return (-2);
  }
#line 694
  *nextTokPtr = ptr;
#line 694
  return (0);
#line 694
  ptr += 3;
#line 694
  break;
  case 7: 
#line 694
  if (end - ptr < 4L) {
#line 694
    return (-2);
  }
#line 694
  *nextTokPtr = ptr;
#line 694
  return (0);
#line 694
  ptr += 4;
#line 694
  break;
  case 16: 
#line 696
  ptr += 2;
#line 696
  if ((unsigned long )ptr == (unsigned long )end) {
#line 697
    return (-1);
  }
#line 698
  if ((int const   )*(ptr + 0) == 0) {
#line 698
    tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
#line 698
    tmp___1 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 698
    tmp___2 = tmp___1;
  }
#line 698
  switch (tmp___2) {
  case 27: 
#line 700
  tmp___3 = big2_scanComment(enc, ptr + 2, end, nextTokPtr);
#line 700
  return (tmp___3);
  case 20: 
#line 702
  tmp___4 = big2_scanCdataSection(enc, ptr + 2, end, nextTokPtr);
#line 702
  return (tmp___4);
  }
#line 705
  *nextTokPtr = ptr;
#line 706
  return (0);
  case 15: 
#line 708
  tmp___5 = big2_scanPi(enc, ptr + 2, end, nextTokPtr);
#line 708
  return (tmp___5);
  case 17: 
#line 710
  tmp___6 = big2_scanEndTag(enc, ptr + 2, end, nextTokPtr);
#line 710
  return (tmp___6);
  default: 
#line 712
  *nextTokPtr = ptr;
#line 713
  return (0);
  }
#line 716
  hadColon = 0;
#line 719
  while ((unsigned long )ptr != (unsigned long )end) {
#line 720
    if ((int const   )*(ptr + 0) == 0) {
#line 720
      tmp___8 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
#line 720
      tmp___7 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 720
      tmp___8 = tmp___7;
    }
#line 720
    switch (tmp___8) {
    case 29: 
#line 721
    if (! (namingBitmap[((int const   )namePages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 721
      *nextTokPtr = ptr;
#line 721
      return (0);
    }
    case 27: 
    case 26: 
    case 25: 
    case 24: 
    case 22: 
#line 721
    ptr += 2;
#line 721
    break;
    case 5: 
#line 721
    if (end - ptr < 2L) {
#line 721
      return (-2);
    }
#line 721
    *nextTokPtr = ptr;
#line 721
    return (0);
#line 721
    ptr += 2;
#line 721
    break;
    case 6: 
#line 721
    if (end - ptr < 3L) {
#line 721
      return (-2);
    }
#line 721
    *nextTokPtr = ptr;
#line 721
    return (0);
#line 721
    ptr += 3;
#line 721
    break;
    case 7: 
#line 721
    if (end - ptr < 4L) {
#line 721
      return (-2);
    }
#line 721
    *nextTokPtr = ptr;
#line 721
    return (0);
#line 721
    ptr += 4;
#line 721
    break;
    case 23: 
#line 724
    if (hadColon) {
#line 725
      *nextTokPtr = ptr;
#line 726
      return (0);
    }
#line 728
    hadColon = 1;
#line 729
    ptr += 2;
#line 730
    if ((unsigned long )ptr == (unsigned long )end) {
#line 731
      return (-1);
    }
#line 732
    if ((int const   )*(ptr + 0) == 0) {
#line 732
      tmp___10 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
#line 732
      tmp___9 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 732
      tmp___10 = tmp___9;
    }
#line 732
    switch (tmp___10) {
    case 29: 
#line 733
    if (! (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 733
      *nextTokPtr = ptr;
#line 733
      return (0);
    }
    case 24: 
    case 22: 
#line 733
    ptr += 2;
#line 733
    break;
    case 5: 
#line 733
    if (end - ptr < 2L) {
#line 733
      return (-2);
    }
#line 733
    *nextTokPtr = ptr;
#line 733
    return (0);
#line 733
    ptr += 2;
#line 733
    break;
    case 6: 
#line 733
    if (end - ptr < 3L) {
#line 733
      return (-2);
    }
#line 733
    *nextTokPtr = ptr;
#line 733
    return (0);
#line 733
    ptr += 3;
#line 733
    break;
    case 7: 
#line 733
    if (end - ptr < 4L) {
#line 733
      return (-2);
    }
#line 733
    *nextTokPtr = ptr;
#line 733
    return (0);
#line 733
    ptr += 4;
#line 733
    break;
    default: 
#line 735
    *nextTokPtr = ptr;
#line 736
    return (0);
    }
#line 738
    break;
    case 10: 
    case 9: 
    case 21: 
#line 742
    ptr += 2;
#line 743
    while ((unsigned long )ptr != (unsigned long )end) {
#line 744
      if ((int const   )*(ptr + 0) == 0) {
#line 744
        tmp___12 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
      } else {
#line 744
        tmp___11 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 744
        tmp___12 = tmp___11;
      }
#line 744
      switch (tmp___12) {
      case 29: 
#line 745
      if (! (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 745
        *nextTokPtr = ptr;
#line 745
        return (0);
      }
      case 24: 
      case 22: 
#line 745
      ptr += 2;
#line 745
      break;
      case 5: 
#line 745
      if (end - ptr < 2L) {
#line 745
        return (-2);
      }
#line 745
      *nextTokPtr = ptr;
#line 745
      return (0);
#line 745
      ptr += 2;
#line 745
      break;
      case 6: 
#line 745
      if (end - ptr < 3L) {
#line 745
        return (-2);
      }
#line 745
      *nextTokPtr = ptr;
#line 745
      return (0);
#line 745
      ptr += 3;
#line 745
      break;
      case 7: 
#line 745
      if (end - ptr < 4L) {
#line 745
        return (-2);
      }
#line 745
      *nextTokPtr = ptr;
#line 745
      return (0);
#line 745
      ptr += 4;
#line 745
      break;
      case 11: 
#line 747
      goto gt;
      case 17: 
#line 749
      goto sol;
      case 10: 
      case 9: 
      case 21: 
#line 751
      ptr += 2;
#line 752
      continue;
      default: 
#line 754
      *nextTokPtr = ptr;
#line 755
      return (0);
      }
#line 757
      tmp___13 = big2_scanAtts(enc, ptr, end, nextTokPtr);
#line 757
      return (tmp___13);
    }
#line 759
    return (-1);
    gt: 
    case 11: 
#line 763
    *nextTokPtr = ptr + 2;
#line 764
    return (2);
    sol: 
    case 17: 
#line 767
    ptr += 2;
#line 768
    if ((unsigned long )ptr == (unsigned long )end) {
#line 769
      return (-1);
    }
#line 770
    if ((int const   )*(ptr + 0) == 0) {
#line 770
      if (! ((int const   )*(ptr + 1) == 62)) {
#line 771
        *nextTokPtr = ptr;
#line 772
        return (0);
      }
    } else {
#line 771
      *nextTokPtr = ptr;
#line 772
      return (0);
    }
#line 774
    *nextTokPtr = ptr + 2;
#line 775
    return (4);
    default: 
#line 777
    *nextTokPtr = ptr;
#line 778
    return (0);
    }
  }
#line 781
  return (-1);
}
}
#line 784 "xmltok_impl.c"
static int big2_contentTok(ENCODING const   *enc , char const   *ptr , char const   *end ,
                           char const   **nextTokPtr ) 
{ 
  size_t n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 788
  if ((unsigned long )ptr == (unsigned long )end) {
#line 789
    return (-4);
  }
#line 791
  n = (size_t )(end - ptr);
#line 792
  if (n & 1UL) {
#line 793
    n &= 0xfffffffffffffffeUL;
#line 794
    if (n == 0UL) {
#line 795
      return (-1);
    }
#line 796
    end = ptr + n;
  }
#line 799
  if ((int const   )*(ptr + 0) == 0) {
#line 799
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
#line 799
    tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 799
    tmp___0 = tmp;
  }
#line 799
  switch (tmp___0) {
  case 2: 
#line 801
  tmp___1 = big2_scanLt(enc, ptr + 2, end, nextTokPtr);
#line 801
  return (tmp___1);
  case 3: 
#line 803
  tmp___2 = big2_scanRef(enc, ptr + 2, end, nextTokPtr);
#line 803
  return (tmp___2);
  case 9: 
#line 805
  ptr += 2;
#line 806
  if ((unsigned long )ptr == (unsigned long )end) {
#line 807
    return (-3);
  }
#line 808
  if ((int const   )*(ptr + 0) == 0) {
#line 808
    tmp___4 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
#line 808
    tmp___3 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 808
    tmp___4 = tmp___3;
  }
#line 808
  if (tmp___4 == 10) {
#line 809
    ptr += 2;
  }
#line 810
  *nextTokPtr = ptr;
#line 811
  return (7);
  case 10: 
#line 813
  *nextTokPtr = ptr + 2;
#line 814
  return (7);
  case 4: 
#line 816
  ptr += 2;
#line 817
  if ((unsigned long )ptr == (unsigned long )end) {
#line 818
    return (-5);
  }
#line 819
  if ((int const   )*(ptr + 0) == 0) {
#line 819
    if (! ((int const   )*(ptr + 1) == 93)) {
#line 820
      break;
    }
  } else {
#line 820
    break;
  }
#line 821
  ptr += 2;
#line 822
  if ((unsigned long )ptr == (unsigned long )end) {
#line 823
    return (-5);
  }
#line 824
  if ((int const   )*(ptr + 0) == 0) {
#line 824
    if (! ((int const   )*(ptr + 1) == 62)) {
#line 825
      ptr -= 2;
#line 826
      break;
    }
  } else {
#line 825
    ptr -= 2;
#line 826
    break;
  }
#line 828
  *nextTokPtr = ptr;
#line 829
  return (0);
  case 5: 
#line 830
  if (end - ptr < 2L) {
#line 830
    return (-2);
  }
#line 830
  ptr += 2;
#line 830
  break;
  case 6: 
#line 830
  if (end - ptr < 3L) {
#line 830
    return (-2);
  }
#line 830
  ptr += 3;
#line 830
  break;
  case 7: 
#line 830
  if (end - ptr < 4L) {
#line 830
    return (-2);
  }
#line 830
  ptr += 4;
#line 830
  break;
  case 8: 
  case 1: 
  case 0: 
#line 830
  *nextTokPtr = ptr;
#line 830
  return (0);
  default: 
#line 832
  ptr += 2;
#line 833
  break;
  }
#line 835
  while ((unsigned long )ptr != (unsigned long )end) {
#line 836
    if ((int const   )*(ptr + 0) == 0) {
#line 836
      tmp___6 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
#line 836
      tmp___5 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 836
      tmp___6 = tmp___5;
    }
#line 836
    switch (tmp___6) {
    case 5: 
#line 845
    if (end - ptr < 2L) {
#line 845
      *nextTokPtr = ptr;
#line 845
      return (6);
    }
#line 845
    ptr += 2;
#line 845
    break;
    case 6: 
#line 845
    if (end - ptr < 3L) {
#line 845
      *nextTokPtr = ptr;
#line 845
      return (6);
    }
#line 845
    ptr += 3;
#line 845
    break;
    case 7: 
#line 845
    if (end - ptr < 4L) {
#line 845
      *nextTokPtr = ptr;
#line 845
      return (6);
    }
#line 845
    ptr += 4;
#line 845
    break;
    case 4: 
#line 848
    if ((unsigned long )(ptr + 2) != (unsigned long )end) {
#line 849
      if ((int const   )*((ptr + 2) + 0) == 0) {
#line 849
        if (! ((int const   )*((ptr + 2) + 1) == 93)) {
#line 850
          ptr += 2;
#line 851
          break;
        }
      } else {
#line 850
        ptr += 2;
#line 851
        break;
      }
#line 853
      if ((unsigned long )(ptr + 4) != (unsigned long )end) {
#line 854
        if ((int const   )*((ptr + 4) + 0) == 0) {
#line 854
          if (! ((int const   )*((ptr + 4) + 1) == 62)) {
#line 855
            ptr += 2;
#line 856
            break;
          }
        } else {
#line 855
          ptr += 2;
#line 856
          break;
        }
#line 858
        *nextTokPtr = ptr + 4;
#line 859
        return (0);
      }
    }
    case 10: 
    case 9: 
    case 8: 
    case 1: 
    case 0: 
    case 2: 
    case 3: 
#line 870
    *nextTokPtr = ptr;
#line 871
    return (6);
    default: 
#line 873
    ptr += 2;
#line 874
    break;
    }
  }
#line 877
  *nextTokPtr = ptr;
#line 878
  return (6);
}
}
#line 883 "xmltok_impl.c"
static int big2_scanPercent(ENCODING const   *enc , char const   *ptr , char const   *end ,
                            char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 887
  if ((unsigned long )ptr == (unsigned long )end) {
#line 888
    return (-1);
  }
#line 889
  if ((int const   )*(ptr + 0) == 0) {
#line 889
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
#line 889
    tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 889
    tmp___0 = tmp;
  }
#line 889
  switch (tmp___0) {
  case 29: 
#line 890
  if (! (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 890
    *nextTokPtr = ptr;
#line 890
    return (0);
  }
  case 24: 
  case 22: 
#line 890
  ptr += 2;
#line 890
  break;
  case 5: 
#line 890
  if (end - ptr < 2L) {
#line 890
    return (-2);
  }
#line 890
  *nextTokPtr = ptr;
#line 890
  return (0);
#line 890
  ptr += 2;
#line 890
  break;
  case 6: 
#line 890
  if (end - ptr < 3L) {
#line 890
    return (-2);
  }
#line 890
  *nextTokPtr = ptr;
#line 890
  return (0);
#line 890
  ptr += 3;
#line 890
  break;
  case 7: 
#line 890
  if (end - ptr < 4L) {
#line 890
    return (-2);
  }
#line 890
  *nextTokPtr = ptr;
#line 890
  return (0);
#line 890
  ptr += 4;
#line 890
  break;
  case 30: 
  case 9: 
  case 10: 
  case 21: 
#line 892
  *nextTokPtr = ptr;
#line 893
  return (22);
  default: 
#line 895
  *nextTokPtr = ptr;
#line 896
  return (0);
  }
#line 898
  while ((unsigned long )ptr != (unsigned long )end) {
#line 899
    if ((int const   )*(ptr + 0) == 0) {
#line 899
      tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
#line 899
      tmp___1 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 899
      tmp___2 = tmp___1;
    }
#line 899
    switch (tmp___2) {
    case 29: 
#line 900
    if (! (namingBitmap[((int const   )namePages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 900
      *nextTokPtr = ptr;
#line 900
      return (0);
    }
    case 27: 
    case 26: 
    case 25: 
    case 24: 
    case 22: 
#line 900
    ptr += 2;
#line 900
    break;
    case 5: 
#line 900
    if (end - ptr < 2L) {
#line 900
      return (-2);
    }
#line 900
    *nextTokPtr = ptr;
#line 900
    return (0);
#line 900
    ptr += 2;
#line 900
    break;
    case 6: 
#line 900
    if (end - ptr < 3L) {
#line 900
      return (-2);
    }
#line 900
    *nextTokPtr = ptr;
#line 900
    return (0);
#line 900
    ptr += 3;
#line 900
    break;
    case 7: 
#line 900
    if (end - ptr < 4L) {
#line 900
      return (-2);
    }
#line 900
    *nextTokPtr = ptr;
#line 900
    return (0);
#line 900
    ptr += 4;
#line 900
    break;
    case 18: 
#line 902
    *nextTokPtr = ptr + 2;
#line 903
    return (28);
    default: 
#line 905
    *nextTokPtr = ptr;
#line 906
    return (0);
    }
  }
#line 909
  return (-1);
}
}
#line 912 "xmltok_impl.c"
static int big2_scanPoundName(ENCODING const   *enc , char const   *ptr , char const   *end ,
                              char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 916
  if ((unsigned long )ptr == (unsigned long )end) {
#line 917
    return (-1);
  }
#line 918
  if ((int const   )*(ptr + 0) == 0) {
#line 918
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
#line 918
    tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 918
    tmp___0 = tmp;
  }
#line 918
  switch (tmp___0) {
  case 29: 
#line 919
  if (! (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 919
    *nextTokPtr = ptr;
#line 919
    return (0);
  }
  case 24: 
  case 22: 
#line 919
  ptr += 2;
#line 919
  break;
  case 5: 
#line 919
  if (end - ptr < 2L) {
#line 919
    return (-2);
  }
#line 919
  *nextTokPtr = ptr;
#line 919
  return (0);
#line 919
  ptr += 2;
#line 919
  break;
  case 6: 
#line 919
  if (end - ptr < 3L) {
#line 919
    return (-2);
  }
#line 919
  *nextTokPtr = ptr;
#line 919
  return (0);
#line 919
  ptr += 3;
#line 919
  break;
  case 7: 
#line 919
  if (end - ptr < 4L) {
#line 919
    return (-2);
  }
#line 919
  *nextTokPtr = ptr;
#line 919
  return (0);
#line 919
  ptr += 4;
#line 919
  break;
  default: 
#line 921
  *nextTokPtr = ptr;
#line 922
  return (0);
  }
#line 924
  while ((unsigned long )ptr != (unsigned long )end) {
#line 925
    if ((int const   )*(ptr + 0) == 0) {
#line 925
      tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
#line 925
      tmp___1 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 925
      tmp___2 = tmp___1;
    }
#line 925
    switch (tmp___2) {
    case 29: 
#line 926
    if (! (namingBitmap[((int const   )namePages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 926
      *nextTokPtr = ptr;
#line 926
      return (0);
    }
    case 27: 
    case 26: 
    case 25: 
    case 24: 
    case 22: 
#line 926
    ptr += 2;
#line 926
    break;
    case 5: 
#line 926
    if (end - ptr < 2L) {
#line 926
      return (-2);
    }
#line 926
    *nextTokPtr = ptr;
#line 926
    return (0);
#line 926
    ptr += 2;
#line 926
    break;
    case 6: 
#line 926
    if (end - ptr < 3L) {
#line 926
      return (-2);
    }
#line 926
    *nextTokPtr = ptr;
#line 926
    return (0);
#line 926
    ptr += 3;
#line 926
    break;
    case 7: 
#line 926
    if (end - ptr < 4L) {
#line 926
      return (-2);
    }
#line 926
    *nextTokPtr = ptr;
#line 926
    return (0);
#line 926
    ptr += 4;
#line 926
    break;
    case 36: 
    case 30: 
    case 11: 
    case 32: 
    case 21: 
    case 10: 
    case 9: 
#line 929
    *nextTokPtr = ptr;
#line 930
    return (20);
    default: 
#line 932
    *nextTokPtr = ptr;
#line 933
    return (0);
    }
  }
#line 936
  return (-20);
}
}
#line 939 "xmltok_impl.c"
static int big2_scanLit(int open , ENCODING const   *enc , char const   *ptr , char const   *end ,
                        char const   **nextTokPtr ) 
{ 
  int t ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 944
  while ((unsigned long )ptr != (unsigned long )end) {
#line 945
    if ((int const   )*(ptr + 0) == 0) {
#line 945
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
#line 945
      tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 945
      tmp___0 = tmp;
    }
#line 945
    t = tmp___0;
#line 946
    switch (t) {
    case 5: 
#line 947
    if (end - ptr < 2L) {
#line 947
      return (-2);
    }
#line 947
    ptr += 2;
#line 947
    break;
    case 6: 
#line 947
    if (end - ptr < 3L) {
#line 947
      return (-2);
    }
#line 947
    ptr += 3;
#line 947
    break;
    case 7: 
#line 947
    if (end - ptr < 4L) {
#line 947
      return (-2);
    }
#line 947
    ptr += 4;
#line 947
    break;
    case 8: 
    case 1: 
    case 0: 
#line 947
    *nextTokPtr = ptr;
#line 947
    return (0);
    case 13: 
    case 12: 
#line 950
    ptr += 2;
#line 951
    if (t != open) {
#line 952
      break;
    }
#line 953
    if ((unsigned long )ptr == (unsigned long )end) {
#line 954
      return (-27);
    }
#line 955
    *nextTokPtr = ptr;
#line 956
    if ((int const   )*(ptr + 0) == 0) {
#line 956
      tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
#line 956
      tmp___1 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 956
      tmp___2 = tmp___1;
    }
#line 956
    switch (tmp___2) {
    case 20: 
    case 30: 
    case 11: 
    case 10: 
    case 9: 
    case 21: 
#line 959
    return (27);
    default: 
#line 961
    return (0);
    }
    default: 
#line 964
    ptr += 2;
#line 965
    break;
    }
  }
#line 968
  return (-1);
}
}
#line 971 "xmltok_impl.c"
static int big2_prologTok(ENCODING const   *enc , char const   *ptr , char const   *end ,
                          char const   **nextTokPtr ) 
{ 
  int tok ;
  size_t n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 976
  if ((unsigned long )ptr == (unsigned long )end) {
#line 977
    return (-4);
  }
#line 979
  n = (size_t )(end - ptr);
#line 980
  if (n & 1UL) {
#line 981
    n &= 0xfffffffffffffffeUL;
#line 982
    if (n == 0UL) {
#line 983
      return (-1);
    }
#line 984
    end = ptr + n;
  }
#line 987
  if ((int const   )*(ptr + 0) == 0) {
#line 987
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
#line 987
    tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 987
    tmp___0 = tmp;
  }
#line 987
  switch (tmp___0) {
  case 12: 
#line 989
  tmp___1 = big2_scanLit(12, enc, ptr + 2, end, nextTokPtr);
#line 989
  return (tmp___1);
  case 13: 
#line 991
  tmp___2 = big2_scanLit(13, enc, ptr + 2, end, nextTokPtr);
#line 991
  return (tmp___2);
  case 2: 
#line 994
  ptr += 2;
#line 995
  if ((unsigned long )ptr == (unsigned long )end) {
#line 996
    return (-1);
  }
#line 997
  if ((int const   )*(ptr + 0) == 0) {
#line 997
    tmp___4 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
#line 997
    tmp___3 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 997
    tmp___4 = tmp___3;
  }
#line 997
  switch (tmp___4) {
  case 16: 
#line 999
  tmp___5 = big2_scanDecl(enc, ptr + 2, end, nextTokPtr);
#line 999
  return (tmp___5);
  case 15: 
#line 1001
  tmp___6 = big2_scanPi(enc, ptr + 2, end, nextTokPtr);
#line 1001
  return (tmp___6);
  case 7: 
  case 6: 
  case 5: 
  case 29: 
  case 24: 
  case 22: 
#line 1008
  *nextTokPtr = ptr - 2;
#line 1009
  return (29);
  }
#line 1011
  *nextTokPtr = ptr;
#line 1012
  return (0);
  case 9: 
#line 1015
  if ((unsigned long )(ptr + 2) == (unsigned long )end) {
#line 1016
    *nextTokPtr = end;
#line 1018
    return (-15);
  }
  case 10: 
  case 21: 
#line 1022
  while (1) {
#line 1023
    ptr += 2;
#line 1024
    if ((unsigned long )ptr == (unsigned long )end) {
#line 1025
      break;
    }
#line 1026
    if ((int const   )*(ptr + 0) == 0) {
#line 1026
      tmp___8 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
#line 1026
      tmp___7 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 1026
      tmp___8 = tmp___7;
    }
#line 1026
    switch (tmp___8) {
    case 10: 
    case 21: 
#line 1028
    break;
    case 9: 
#line 1031
    if ((unsigned long )(ptr + 2) != (unsigned long )end) {
#line 1032
      break;
    }
    default: 
#line 1035
    *nextTokPtr = ptr;
#line 1036
    return (15);
    }
  }
#line 1039
  *nextTokPtr = ptr;
#line 1040
  return (15);
  case 30: 
#line 1042
  tmp___9 = big2_scanPercent(enc, ptr + 2, end, nextTokPtr);
#line 1042
  return (tmp___9);
  case 35: 
#line 1044
  *nextTokPtr = ptr + 2;
#line 1045
  return (38);
  case 20: 
#line 1047
  *nextTokPtr = ptr + 2;
#line 1048
  return (25);
  case 4: 
#line 1050
  ptr += 2;
#line 1051
  if ((unsigned long )ptr == (unsigned long )end) {
#line 1052
    return (-26);
  }
#line 1053
  if ((int const   )*(ptr + 0) == 0) {
#line 1053
    if ((int const   )*(ptr + 1) == 93) {
#line 1054
      if ((unsigned long )(ptr + 2) == (unsigned long )end) {
#line 1055
        return (-1);
      }
#line 1056
      if ((int const   )*((ptr + 2) + 0) == 0) {
#line 1056
        if ((int const   )*((ptr + 2) + 1) == 62) {
#line 1057
          *nextTokPtr = ptr + 4;
#line 1058
          return (34);
        }
      }
    }
  }
#line 1061
  *nextTokPtr = ptr;
#line 1062
  return (26);
  case 31: 
#line 1064
  *nextTokPtr = ptr + 2;
#line 1065
  return (23);
  case 32: 
#line 1067
  ptr += 2;
#line 1068
  if ((unsigned long )ptr == (unsigned long )end) {
#line 1069
    return (-24);
  }
#line 1070
  if ((int const   )*(ptr + 0) == 0) {
#line 1070
    tmp___11 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
#line 1070
    tmp___10 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 1070
    tmp___11 = tmp___10;
  }
#line 1070
  switch (tmp___11) {
  case 33: 
#line 1072
  *nextTokPtr = ptr + 2;
#line 1073
  return (36);
  case 15: 
#line 1075
  *nextTokPtr = ptr + 2;
#line 1076
  return (35);
  case 34: 
#line 1078
  *nextTokPtr = ptr + 2;
#line 1079
  return (37);
  case 32: 
  case 36: 
  case 35: 
  case 11: 
  case 21: 
  case 10: 
  case 9: 
#line 1083
  *nextTokPtr = ptr;
#line 1084
  return (24);
  }
#line 1086
  *nextTokPtr = ptr;
#line 1087
  return (0);
  case 36: 
#line 1089
  *nextTokPtr = ptr + 2;
#line 1090
  return (21);
  case 11: 
#line 1092
  *nextTokPtr = ptr + 2;
#line 1093
  return (17);
  case 19: 
#line 1095
  tmp___12 = big2_scanPoundName(enc, ptr + 2, end, nextTokPtr);
#line 1095
  return (tmp___12);
  case 5: 
#line 1112
  if (end - ptr < 2L) {
#line 1112
    return (-2);
  }
#line 1112
  *nextTokPtr = ptr;
#line 1112
  return (0);
  case 6: 
#line 1112
  if (end - ptr < 3L) {
#line 1112
    return (-2);
  }
#line 1112
  *nextTokPtr = ptr;
#line 1112
  return (0);
  case 7: 
#line 1112
  if (end - ptr < 4L) {
#line 1112
    return (-2);
  }
#line 1112
  *nextTokPtr = ptr;
#line 1112
  return (0);
  case 24: 
  case 22: 
#line 1116
  tok = 18;
#line 1117
  ptr += 2;
#line 1118
  break;
  case 23: 
  case 27: 
  case 26: 
  case 25: 
#line 1125
  tok = 19;
#line 1126
  ptr += 2;
#line 1127
  break;
  case 29: 
#line 1129
  if (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31))) {
#line 1130
    ptr += 2;
#line 1131
    tok = 18;
#line 1132
    break;
  }
#line 1134
  if (namingBitmap[((int const   )namePages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31))) {
#line 1135
    ptr += 2;
#line 1136
    tok = 19;
#line 1137
    break;
  }
  default: 
#line 1141
  *nextTokPtr = ptr;
#line 1142
  return (0);
  }
#line 1144
  while ((unsigned long )ptr != (unsigned long )end) {
#line 1145
    if ((int const   )*(ptr + 0) == 0) {
#line 1145
      tmp___14 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
#line 1145
      tmp___13 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 1145
      tmp___14 = tmp___13;
    }
#line 1145
    switch (tmp___14) {
    case 29: 
#line 1146
    if (! (namingBitmap[((int const   )namePages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 1146
      *nextTokPtr = ptr;
#line 1146
      return (0);
    }
    case 27: 
    case 26: 
    case 25: 
    case 24: 
    case 22: 
#line 1146
    ptr += 2;
#line 1146
    break;
    case 5: 
#line 1146
    if (end - ptr < 2L) {
#line 1146
      return (-2);
    }
#line 1146
    *nextTokPtr = ptr;
#line 1146
    return (0);
#line 1146
    ptr += 2;
#line 1146
    break;
    case 6: 
#line 1146
    if (end - ptr < 3L) {
#line 1146
      return (-2);
    }
#line 1146
    *nextTokPtr = ptr;
#line 1146
    return (0);
#line 1146
    ptr += 3;
#line 1146
    break;
    case 7: 
#line 1146
    if (end - ptr < 4L) {
#line 1146
      return (-2);
    }
#line 1146
    *nextTokPtr = ptr;
#line 1146
    return (0);
#line 1146
    ptr += 4;
#line 1146
    break;
    case 10: 
    case 9: 
    case 21: 
    case 30: 
    case 20: 
    case 36: 
    case 35: 
    case 32: 
    case 11: 
#line 1150
    *nextTokPtr = ptr;
#line 1151
    return (tok);
    case 23: 
#line 1154
    ptr += 2;
#line 1155
    switch (tok) {
    case 18: 
#line 1157
    if ((unsigned long )ptr == (unsigned long )end) {
#line 1158
      return (-1);
    }
#line 1159
    tok = 41;
#line 1160
    if ((int const   )*(ptr + 0) == 0) {
#line 1160
      tmp___16 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
#line 1160
      tmp___15 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 1160
      tmp___16 = tmp___15;
    }
#line 1160
    switch (tmp___16) {
    case 29: 
#line 1161
    if (! (namingBitmap[((int const   )namePages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 1161
      *nextTokPtr = ptr;
#line 1161
      return (0);
    }
    case 27: 
    case 26: 
    case 25: 
    case 24: 
    case 22: 
#line 1161
    ptr += 2;
#line 1161
    break;
    case 5: 
#line 1161
    if (end - ptr < 2L) {
#line 1161
      return (-2);
    }
#line 1161
    *nextTokPtr = ptr;
#line 1161
    return (0);
#line 1161
    ptr += 2;
#line 1161
    break;
    case 6: 
#line 1161
    if (end - ptr < 3L) {
#line 1161
      return (-2);
    }
#line 1161
    *nextTokPtr = ptr;
#line 1161
    return (0);
#line 1161
    ptr += 3;
#line 1161
    break;
    case 7: 
#line 1161
    if (end - ptr < 4L) {
#line 1161
      return (-2);
    }
#line 1161
    *nextTokPtr = ptr;
#line 1161
    return (0);
#line 1161
    ptr += 4;
#line 1161
    break;
    default: 
#line 1163
    tok = 19;
#line 1164
    break;
    }
#line 1166
    break;
    case 41: 
#line 1168
    tok = 19;
#line 1169
    break;
    }
#line 1171
    break;
    case 34: 
#line 1174
    if (tok == 19) {
#line 1175
      *nextTokPtr = ptr;
#line 1176
      return (0);
    }
#line 1178
    *nextTokPtr = ptr + 2;
#line 1179
    return (32);
    case 33: 
#line 1181
    if (tok == 19) {
#line 1182
      *nextTokPtr = ptr;
#line 1183
      return (0);
    }
#line 1185
    *nextTokPtr = ptr + 2;
#line 1186
    return (31);
    case 15: 
#line 1188
    if (tok == 19) {
#line 1189
      *nextTokPtr = ptr;
#line 1190
      return (0);
    }
#line 1192
    *nextTokPtr = ptr + 2;
#line 1193
    return (30);
    default: 
#line 1195
    *nextTokPtr = ptr;
#line 1196
    return (0);
    }
  }
#line 1199
  return (- tok);
}
}
#line 1202 "xmltok_impl.c"
static int big2_attributeValueTok(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                  char const   **nextTokPtr ) 
{ 
  char const   *start ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1207
  if ((unsigned long )ptr == (unsigned long )end) {
#line 1208
    return (-4);
  }
#line 1209
  start = ptr;
#line 1210
  while ((unsigned long )ptr != (unsigned long )end) {
#line 1211
    if ((int const   )*(ptr + 0) == 0) {
#line 1211
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
#line 1211
      tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 1211
      tmp___0 = tmp;
    }
#line 1211
    switch (tmp___0) {
    case 5: 
#line 1214
    ptr += 2;
#line 1214
    break;
    case 6: 
#line 1214
    ptr += 3;
#line 1214
    break;
    case 7: 
#line 1214
    ptr += 4;
#line 1214
    break;
    case 3: 
#line 1217
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1218
      tmp___1 = big2_scanRef(enc, ptr + 2, end, nextTokPtr);
#line 1218
      return (tmp___1);
    }
#line 1219
    *nextTokPtr = ptr;
#line 1220
    return (6);
    case 2: 
#line 1223
    *nextTokPtr = ptr;
#line 1224
    return (0);
    case 10: 
#line 1226
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1227
      *nextTokPtr = ptr + 2;
#line 1228
      return (7);
    }
#line 1230
    *nextTokPtr = ptr;
#line 1231
    return (6);
    case 9: 
#line 1233
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1234
      ptr += 2;
#line 1235
      if ((unsigned long )ptr == (unsigned long )end) {
#line 1236
        return (-3);
      }
#line 1237
      if ((int const   )*(ptr + 0) == 0) {
#line 1237
        tmp___3 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
      } else {
#line 1237
        tmp___2 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 1237
        tmp___3 = tmp___2;
      }
#line 1237
      if (tmp___3 == 10) {
#line 1238
        ptr += 2;
      }
#line 1239
      *nextTokPtr = ptr;
#line 1240
      return (7);
    }
#line 1242
    *nextTokPtr = ptr;
#line 1243
    return (6);
    case 21: 
#line 1245
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1246
      *nextTokPtr = ptr + 2;
#line 1247
      return (39);
    }
#line 1249
    *nextTokPtr = ptr;
#line 1250
    return (6);
    default: 
#line 1252
    ptr += 2;
#line 1253
    break;
    }
  }
#line 1256
  *nextTokPtr = ptr;
#line 1257
  return (6);
}
}
#line 1260 "xmltok_impl.c"
static int big2_entityValueTok(ENCODING const   *enc , char const   *ptr , char const   *end ,
                               char const   **nextTokPtr ) 
{ 
  char const   *start ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tok ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1265
  if ((unsigned long )ptr == (unsigned long )end) {
#line 1266
    return (-4);
  }
#line 1267
  start = ptr;
#line 1268
  while ((unsigned long )ptr != (unsigned long )end) {
#line 1269
    if ((int const   )*(ptr + 0) == 0) {
#line 1269
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
#line 1269
      tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 1269
      tmp___0 = tmp;
    }
#line 1269
    switch (tmp___0) {
    case 5: 
#line 1272
    ptr += 2;
#line 1272
    break;
    case 6: 
#line 1272
    ptr += 3;
#line 1272
    break;
    case 7: 
#line 1272
    ptr += 4;
#line 1272
    break;
    case 3: 
#line 1275
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1276
      tmp___1 = big2_scanRef(enc, ptr + 2, end, nextTokPtr);
#line 1276
      return (tmp___1);
    }
#line 1277
    *nextTokPtr = ptr;
#line 1278
    return (6);
    case 30: 
#line 1280
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1281
      tmp___2 = big2_scanPercent(enc, ptr + 2, end, nextTokPtr);
#line 1281
      tok = tmp___2;
#line 1283
      if (tok == 22) {
#line 1283
        tmp___3 = 0;
      } else {
#line 1283
        tmp___3 = tok;
      }
#line 1283
      return (tmp___3);
    }
#line 1285
    *nextTokPtr = ptr;
#line 1286
    return (6);
    case 10: 
#line 1288
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1289
      *nextTokPtr = ptr + 2;
#line 1290
      return (7);
    }
#line 1292
    *nextTokPtr = ptr;
#line 1293
    return (6);
    case 9: 
#line 1295
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1296
      ptr += 2;
#line 1297
      if ((unsigned long )ptr == (unsigned long )end) {
#line 1298
        return (-3);
      }
#line 1299
      if ((int const   )*(ptr + 0) == 0) {
#line 1299
        tmp___5 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
      } else {
#line 1299
        tmp___4 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 1299
        tmp___5 = tmp___4;
      }
#line 1299
      if (tmp___5 == 10) {
#line 1300
        ptr += 2;
      }
#line 1301
      *nextTokPtr = ptr;
#line 1302
      return (7);
    }
#line 1304
    *nextTokPtr = ptr;
#line 1305
    return (6);
    default: 
#line 1307
    ptr += 2;
#line 1308
    break;
    }
  }
#line 1311
  *nextTokPtr = ptr;
#line 1312
  return (6);
}
}
#line 1317 "xmltok_impl.c"
static int big2_ignoreSectionTok(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                 char const   **nextTokPtr ) 
{ 
  int level ;
  size_t n ;
  int tmp ;
  int tmp___0 ;

  {
#line 1321
  level = 0;
#line 1323
  n = (size_t )(end - ptr);
#line 1324
  if (n & 1UL) {
#line 1325
    n &= 0xfffffffffffffffeUL;
#line 1326
    end = ptr + n;
  }
#line 1329
  while ((unsigned long )ptr != (unsigned long )end) {
#line 1330
    if ((int const   )*(ptr + 0) == 0) {
#line 1330
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
#line 1330
      tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 1330
      tmp___0 = tmp;
    }
#line 1330
    switch (tmp___0) {
    case 5: 
#line 1331
    if (end - ptr < 2L) {
#line 1331
      return (-2);
    }
#line 1331
    ptr += 2;
#line 1331
    break;
    case 6: 
#line 1331
    if (end - ptr < 3L) {
#line 1331
      return (-2);
    }
#line 1331
    ptr += 3;
#line 1331
    break;
    case 7: 
#line 1331
    if (end - ptr < 4L) {
#line 1331
      return (-2);
    }
#line 1331
    ptr += 4;
#line 1331
    break;
    case 8: 
    case 1: 
    case 0: 
#line 1331
    *nextTokPtr = ptr;
#line 1331
    return (0);
    case 2: 
#line 1333
    ptr += 2;
#line 1333
    if ((unsigned long )ptr == (unsigned long )end) {
#line 1334
      return (-1);
    }
#line 1335
    if ((int const   )*(ptr + 0) == 0) {
#line 1335
      if ((int const   )*(ptr + 1) == 33) {
#line 1336
        ptr += 2;
#line 1336
        if ((unsigned long )ptr == (unsigned long )end) {
#line 1337
          return (-1);
        }
#line 1338
        if ((int const   )*(ptr + 0) == 0) {
#line 1338
          if ((int const   )*(ptr + 1) == 91) {
#line 1339
            level ++;
#line 1340
            ptr += 2;
          }
        }
      }
    }
#line 1343
    break;
    case 4: 
#line 1345
    ptr += 2;
#line 1345
    if ((unsigned long )ptr == (unsigned long )end) {
#line 1346
      return (-1);
    }
#line 1347
    if ((int const   )*(ptr + 0) == 0) {
#line 1347
      if ((int const   )*(ptr + 1) == 93) {
#line 1348
        ptr += 2;
#line 1348
        if ((unsigned long )ptr == (unsigned long )end) {
#line 1349
          return (-1);
        }
#line 1350
        if ((int const   )*(ptr + 0) == 0) {
#line 1350
          if ((int const   )*(ptr + 1) == 62) {
#line 1351
            ptr += 2;
#line 1352
            if (level == 0) {
#line 1353
              *nextTokPtr = ptr;
#line 1354
              return (42);
            }
#line 1356
            level --;
          }
        }
      }
    }
#line 1359
    break;
    default: 
#line 1361
    ptr += 2;
#line 1362
    break;
    }
  }
#line 1365
  return (-1);
}
}
#line 1370 "xmltok_impl.c"
static int big2_isPublicId(ENCODING const   *enc , char const   *ptr , char const   *end ,
                           char const   **badPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1374
  ptr += 2;
#line 1375
  end -= 2;
#line 1376
  while ((unsigned long )ptr != (unsigned long )end) {
#line 1377
    if ((int const   )*(ptr + 0) == 0) {
#line 1377
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
#line 1377
      tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 1377
      tmp___0 = tmp;
    }
#line 1377
    switch (tmp___0) {
    case 23: 
    case 19: 
    case 30: 
    case 33: 
    case 16: 
    case 18: 
    case 10: 
    case 9: 
    case 15: 
    case 14: 
    case 17: 
    case 35: 
    case 34: 
    case 32: 
    case 31: 
    case 13: 
    case 27: 
    case 24: 
    case 25: 
#line 1399
    break;
    case 21: 
#line 1401
    if ((int const   )*(ptr + 0) == 0) {
#line 1401
      if ((int const   )*(ptr + 1) == 9) {
#line 1402
        *badPtr = ptr;
#line 1403
        return (0);
      }
    }
#line 1405
    break;
    case 22: 
    case 26: 
#line 1408
    if ((int const   )*(ptr + 0) == 0) {
#line 1408
      tmp___1 = (int const   )*(ptr + 1);
    } else {
#line 1408
      tmp___1 = (int const   )-1;
    }
#line 1408
    if (! (tmp___1 & -128)) {
#line 1409
      break;
    }
    default: 
#line 1411
    if ((int const   )*(ptr + 0) == 0) {
#line 1411
      tmp___2 = (int const   )*(ptr + 1);
    } else {
#line 1411
      tmp___2 = (int const   )-1;
    }
#line 1411
    switch (tmp___2) {
    case 64: 
    case 36: 
#line 1414
    break;
    default: 
#line 1416
    *badPtr = ptr;
#line 1417
    return (0);
    }
#line 1419
    break;
    }
#line 1376
    ptr += 2;
  }
#line 1422
  return (1);
}
}
#line 1430 "xmltok_impl.c"
static int big2_getAtts(ENCODING const   *enc , char const   *ptr , int attsMax ,
                        ATTRIBUTE *atts ) 
{ 
  enum __anonenum_state_1045544530 state ;
  int nAtts ;
  int open ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1434
  state = (enum __anonenum_state_1045544530 )1;
#line 1435
  nAtts = 0;
#line 1436
  open = 0;
#line 1439
  ptr += 2;
#line 1439
  while (1) {
#line 1440
    if ((int const   )*(ptr + 0) == 0) {
#line 1440
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
#line 1440
      tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 1440
      tmp___0 = tmp;
    }
#line 1440
    switch (tmp___0) {
    case 5: 
#line 1451
    if ((unsigned int )state == 0U) {
#line 1451
      if (nAtts < attsMax) {
#line 1451
        (atts + nAtts)->name = ptr;
#line 1451
        (atts + nAtts)->normalized = (char)1;
      }
#line 1451
      state = (enum __anonenum_state_1045544530 )1;
    }
#line 1451
    ptr += 0;
#line 1451
    break;
    case 6: 
#line 1451
    if ((unsigned int )state == 0U) {
#line 1451
      if (nAtts < attsMax) {
#line 1451
        (atts + nAtts)->name = ptr;
#line 1451
        (atts + nAtts)->normalized = (char)1;
      }
#line 1451
      state = (enum __anonenum_state_1045544530 )1;
    }
#line 1451
    ptr ++;
#line 1451
    break;
    case 7: 
#line 1451
    if ((unsigned int )state == 0U) {
#line 1451
      if (nAtts < attsMax) {
#line 1451
        (atts + nAtts)->name = ptr;
#line 1451
        (atts + nAtts)->normalized = (char)1;
      }
#line 1451
      state = (enum __anonenum_state_1045544530 )1;
    }
#line 1451
    ptr += 2;
#line 1451
    break;
    case 24: 
    case 22: 
    case 29: 
#line 1456
    if ((unsigned int )state == 0U) {
#line 1456
      if (nAtts < attsMax) {
#line 1456
        (atts + nAtts)->name = ptr;
#line 1456
        (atts + nAtts)->normalized = (char)1;
      }
#line 1456
      state = (enum __anonenum_state_1045544530 )1;
    }
#line 1457
    break;
    case 12: 
#line 1460
    if ((unsigned int )state != 2U) {
#line 1461
      if (nAtts < attsMax) {
#line 1462
        (atts + nAtts)->valuePtr = ptr + 2;
      }
#line 1463
      state = (enum __anonenum_state_1045544530 )2;
#line 1464
      open = 12;
    } else
#line 1466
    if (open == 12) {
#line 1467
      state = (enum __anonenum_state_1045544530 )0;
#line 1468
      if (nAtts < attsMax) {
#line 1469
        (atts + nAtts)->valueEnd = ptr;
      }
#line 1470
      nAtts ++;
    }
#line 1472
    break;
    case 13: 
#line 1474
    if ((unsigned int )state != 2U) {
#line 1475
      if (nAtts < attsMax) {
#line 1476
        (atts + nAtts)->valuePtr = ptr + 2;
      }
#line 1477
      state = (enum __anonenum_state_1045544530 )2;
#line 1478
      open = 13;
    } else
#line 1480
    if (open == 13) {
#line 1481
      state = (enum __anonenum_state_1045544530 )0;
#line 1482
      if (nAtts < attsMax) {
#line 1483
        (atts + nAtts)->valueEnd = ptr;
      }
#line 1484
      nAtts ++;
    }
#line 1486
    break;
    case 3: 
#line 1488
    if (nAtts < attsMax) {
#line 1489
      (atts + nAtts)->normalized = (char)0;
    }
#line 1490
    break;
    case 21: 
#line 1492
    if ((unsigned int )state == 1U) {
#line 1493
      state = (enum __anonenum_state_1045544530 )0;
    } else
#line 1494
    if ((unsigned int )state == 2U) {
#line 1494
      if (nAtts < attsMax) {
#line 1494
        if ((atts + nAtts)->normalized) {
#line 1494
          if ((unsigned long )ptr == (unsigned long )(atts + nAtts)->valuePtr) {
#line 1501
            (atts + nAtts)->normalized = (char)0;
          } else {
#line 1494
            if ((int const   )*(ptr + 0) == 0) {
#line 1494
              tmp___1 = (int const   )*(ptr + 1);
            } else {
#line 1494
              tmp___1 = (int const   )-1;
            }
#line 1494
            if (tmp___1 != 32) {
#line 1501
              (atts + nAtts)->normalized = (char)0;
            } else {
#line 1494
              if ((int const   )*((ptr + 2) + 0) == 0) {
#line 1494
                tmp___2 = (int const   )*((ptr + 2) + 1);
              } else {
#line 1494
                tmp___2 = (int const   )-1;
              }
#line 1494
              if (tmp___2 == 32) {
#line 1501
                (atts + nAtts)->normalized = (char)0;
              } else {
#line 1494
                if ((int const   )*((ptr + 2) + 0) == 0) {
#line 1494
                  tmp___4 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*((ptr + 2) + 1)];
                } else {
#line 1494
                  tmp___3 = unicode_byte_type((char )*((ptr + 2) + 0), (char )*((ptr + 2) + 1));
#line 1494
                  tmp___4 = tmp___3;
                }
#line 1494
                if (tmp___4 == open) {
#line 1501
                  (atts + nAtts)->normalized = (char)0;
                }
              }
            }
          }
        }
      }
    }
#line 1502
    break;
    case 10: 
    case 9: 
#line 1506
    if ((unsigned int )state == 1U) {
#line 1507
      state = (enum __anonenum_state_1045544530 )0;
    } else
#line 1508
    if ((unsigned int )state == 2U) {
#line 1508
      if (nAtts < attsMax) {
#line 1509
        (atts + nAtts)->normalized = (char)0;
      }
    }
#line 1510
    break;
    case 17: 
    case 11: 
#line 1513
    if ((unsigned int )state != 2U) {
#line 1514
      return (nAtts);
    }
#line 1515
    break;
    default: 
#line 1517
    break;
    }
#line 1439
    ptr += 2;
  }
}
}
#line 1523 "xmltok_impl.c"
static int big2_charRefNumber(ENCODING const   *enc , char const   *ptr ) 
{ 
  int result ;
  int c ;
  int tmp ;
  int c___0 ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1526
  result = 0;
#line 1528
  ptr += 4;
#line 1529
  if ((int const   )*(ptr + 0) == 0) {
#line 1529
    if ((int const   )*(ptr + 1) == 120) {
#line 1530
      ptr += 2;
#line 1530
      while (1) {
#line 1530
        if ((int const   )*(ptr + 0) == 0) {
#line 1530
          if ((int const   )*(ptr + 1) == 59) {
#line 1530
            break;
          }
        }
#line 1533
        if ((int const   )*(ptr + 0) == 0) {
#line 1533
          tmp = (int const   )*(ptr + 1);
        } else {
#line 1533
          tmp = (int const   )-1;
        }
#line 1533
        c = (int )tmp;
#line 1534
        switch (c) {
        case 57: 
        case 56: 
        case 55: 
        case 54: 
        case 53: 
        case 52: 
        case 51: 
        case 50: 
        case 49: 
        case 48: 
#line 1537
        result <<= 4;
#line 1538
        result |= c - 48;
#line 1539
        break;
        case 70: 
        case 69: 
        case 68: 
        case 67: 
        case 66: 
        case 65: 
#line 1542
        result <<= 4;
#line 1543
        result += 10 + (c - 65);
#line 1544
        break;
        case 102: 
        case 101: 
        case 100: 
        case 99: 
        case 98: 
        case 97: 
#line 1547
        result <<= 4;
#line 1548
        result += 10 + (c - 97);
#line 1549
        break;
        }
#line 1551
        if (result >= 1114112) {
#line 1552
          return (-1);
        }
#line 1530
        ptr += 2;
      }
    } else {
#line 1529
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1556
    while (1) {
#line 1556
      if ((int const   )*(ptr + 0) == 0) {
#line 1556
        if ((int const   )*(ptr + 1) == 59) {
#line 1556
          break;
        }
      }
#line 1557
      if ((int const   )*(ptr + 0) == 0) {
#line 1557
        tmp___0 = (int const   )*(ptr + 1);
      } else {
#line 1557
        tmp___0 = (int const   )-1;
      }
#line 1557
      c___0 = (int )tmp___0;
#line 1558
      result *= 10;
#line 1559
      result += c___0 - 48;
#line 1560
      if (result >= 1114112) {
#line 1561
        return (-1);
      }
#line 1556
      ptr += 2;
    }
  }
#line 1564
  tmp___1 = checkCharRefNumber(result);
#line 1564
  return (tmp___1);
}
}
#line 1567 "xmltok_impl.c"
static int big2_predefinedEntityName(ENCODING const   *enc , char const   *ptr , char const   *end ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1571
  switch ((end - ptr) / 2L) {
  case 2L: 
#line 1573
  if ((int const   )*((ptr + 2) + 0) == 0) {
#line 1573
    if ((int const   )*((ptr + 2) + 1) == 116) {
#line 1574
      if ((int const   )*(ptr + 0) == 0) {
#line 1574
        tmp = (int const   )*(ptr + 1);
      } else {
#line 1574
        tmp = (int const   )-1;
      }
#line 1574
      switch (tmp) {
      case 108: 
#line 1576
      return (60);
      case 103: 
#line 1578
      return (62);
      }
    }
  }
#line 1581
  break;
  case 3L: 
#line 1583
  if ((int const   )*(ptr + 0) == 0) {
#line 1583
    if ((int const   )*(ptr + 1) == 97) {
#line 1584
      ptr += 2;
#line 1585
      if ((int const   )*(ptr + 0) == 0) {
#line 1585
        if ((int const   )*(ptr + 1) == 109) {
#line 1586
          ptr += 2;
#line 1587
          if ((int const   )*(ptr + 0) == 0) {
#line 1587
            if ((int const   )*(ptr + 1) == 112) {
#line 1588
              return (38);
            }
          }
        }
      }
    }
  }
#line 1591
  break;
  case 4L: 
#line 1593
  if ((int const   )*(ptr + 0) == 0) {
#line 1593
    tmp___0 = (int const   )*(ptr + 1);
  } else {
#line 1593
    tmp___0 = (int const   )-1;
  }
#line 1593
  switch (tmp___0) {
  case 113: 
#line 1595
  ptr += 2;
#line 1596
  if ((int const   )*(ptr + 0) == 0) {
#line 1596
    if ((int const   )*(ptr + 1) == 117) {
#line 1597
      ptr += 2;
#line 1598
      if ((int const   )*(ptr + 0) == 0) {
#line 1598
        if ((int const   )*(ptr + 1) == 111) {
#line 1599
          ptr += 2;
#line 1600
          if ((int const   )*(ptr + 0) == 0) {
#line 1600
            if ((int const   )*(ptr + 1) == 116) {
#line 1601
              return (34);
            }
          }
        }
      }
    }
  }
#line 1604
  break;
  case 97: 
#line 1606
  ptr += 2;
#line 1607
  if ((int const   )*(ptr + 0) == 0) {
#line 1607
    if ((int const   )*(ptr + 1) == 112) {
#line 1608
      ptr += 2;
#line 1609
      if ((int const   )*(ptr + 0) == 0) {
#line 1609
        if ((int const   )*(ptr + 1) == 111) {
#line 1610
          ptr += 2;
#line 1611
          if ((int const   )*(ptr + 0) == 0) {
#line 1611
            if ((int const   )*(ptr + 1) == 115) {
#line 1612
              return (39);
            }
          }
        }
      }
    }
  }
#line 1615
  break;
  }
  }
#line 1618
  return (0);
}
}
#line 1621 "xmltok_impl.c"
static int big2_sameName(ENCODING const   *enc , char const   *ptr1 , char const   *ptr2 ) 
{ 
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 1624
  while (1) {
#line 1625
    if ((int const   )*(ptr1 + 0) == 0) {
#line 1625
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr1 + 1)];
    } else {
#line 1625
      tmp = unicode_byte_type((char )*(ptr1 + 0), (char )*(ptr1 + 1));
#line 1625
      tmp___0 = tmp;
    }
#line 1625
    switch (tmp___0) {
    case 7: 
#line 1630
    tmp___1 = ptr1;
#line 1630
    ptr1 ++;
#line 1630
    tmp___2 = ptr2;
#line 1630
    ptr2 ++;
#line 1630
    if ((int const   )*tmp___1 != (int const   )*tmp___2) {
#line 1630
      return (0);
    }
    case 6: 
#line 1630
    tmp___3 = ptr1;
#line 1630
    ptr1 ++;
#line 1630
    tmp___4 = ptr2;
#line 1630
    ptr2 ++;
#line 1630
    if ((int const   )*tmp___3 != (int const   )*tmp___4) {
#line 1630
      return (0);
    }
    case 5: 
#line 1630
    tmp___5 = ptr1;
#line 1630
    ptr1 ++;
#line 1630
    tmp___6 = ptr2;
#line 1630
    ptr2 ++;
#line 1630
    if ((int const   )*tmp___5 != (int const   )*tmp___6) {
#line 1630
      return (0);
    }
#line 1633
    tmp___7 = ptr1;
#line 1633
    ptr1 ++;
#line 1633
    tmp___8 = ptr2;
#line 1633
    ptr2 ++;
#line 1633
    if ((int const   )*tmp___7 != (int const   )*tmp___8) {
#line 1634
      return (0);
    }
#line 1635
    break;
    case 27: 
    case 26: 
    case 25: 
    case 24: 
    case 23: 
    case 22: 
    case 29: 
#line 1645
    tmp___9 = ptr2;
#line 1645
    ptr2 ++;
#line 1645
    tmp___10 = ptr1;
#line 1645
    ptr1 ++;
#line 1645
    if ((int const   )*tmp___9 != (int const   )*tmp___10) {
#line 1646
      return (0);
    }
#line 1648
    tmp___11 = ptr2;
#line 1648
    ptr2 ++;
#line 1648
    tmp___12 = ptr1;
#line 1648
    ptr1 ++;
#line 1648
    if ((int const   )*tmp___11 != (int const   )*tmp___12) {
#line 1649
      return (0);
    }
#line 1659
    break;
    default: ;
#line 1663
    if ((int const   )*(ptr2 + 0) == 0) {
#line 1663
      tmp___18 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr2 + 1)];
    } else {
#line 1663
      tmp___17 = unicode_byte_type((char )*(ptr2 + 0), (char )*(ptr2 + 1));
#line 1663
      tmp___18 = tmp___17;
    }
#line 1663
    switch (tmp___18) {
    case 27: 
    case 26: 
    case 25: 
    case 24: 
    case 23: 
    case 22: 
    case 29: 
    case 7: 
    case 6: 
    case 5: 
#line 1676
    return (0);
    default: 
#line 1678
    return (1);
    }
    }
  }
}
}
#line 1685 "xmltok_impl.c"
static int big2_nameMatchesAscii(ENCODING const   *enc , char const   *ptr1 , char const   *end1 ,
                                 char const   *ptr2 ) 
{ 


  {
#line 1689
  while (*ptr2) {
#line 1690
    if ((unsigned long )ptr1 == (unsigned long )end1) {
#line 1691
      return (0);
    }
#line 1692
    if ((int const   )*(ptr1 + 0) == 0) {
#line 1692
      if (! ((int const   )*(ptr1 + 1) == (int const   )*ptr2)) {
#line 1693
        return (0);
      }
    } else {
#line 1693
      return (0);
    }
#line 1689
    ptr1 += 2;
#line 1689
    ptr2 ++;
  }
#line 1695
  return ((unsigned long )ptr1 == (unsigned long )end1);
}
}
#line 1698 "xmltok_impl.c"
static int big2_nameLength(ENCODING const   *enc , char const   *ptr ) 
{ 
  char const   *start ;
  int tmp ;
  int tmp___0 ;

  {
#line 1701
  start = ptr;
#line 1702
  while (1) {
#line 1703
    if ((int const   )*(ptr + 0) == 0) {
#line 1703
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
#line 1703
      tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 1703
      tmp___0 = tmp;
    }
#line 1703
    switch (tmp___0) {
    case 5: 
#line 1706
    ptr += 2;
#line 1706
    break;
    case 6: 
#line 1706
    ptr += 3;
#line 1706
    break;
    case 7: 
#line 1706
    ptr += 4;
#line 1706
    break;
    case 27: 
    case 26: 
    case 25: 
    case 24: 
    case 23: 
    case 22: 
    case 29: 
#line 1717
    ptr += 2;
#line 1718
    break;
    default: 
#line 1720
    return ((int )(ptr - start));
    }
  }
}
}
#line 1725 "xmltok_impl.c"
static char const   *big2_skipS(ENCODING const   *enc , char const   *ptr ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1728
  while (1) {
#line 1729
    if ((int const   )*(ptr + 0) == 0) {
#line 1729
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
#line 1729
      tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 1729
      tmp___0 = tmp;
    }
#line 1729
    switch (tmp___0) {
    case 21: 
    case 9: 
    case 10: 
#line 1733
    ptr += 2;
#line 1734
    break;
    default: 
#line 1736
    return (ptr);
    }
  }
}
}
#line 1741 "xmltok_impl.c"
static void big2_updatePosition(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                POSITION *pos ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1747
  while ((unsigned long )ptr < (unsigned long )end) {
#line 1748
    if ((int const   )*(ptr + 0) == 0) {
#line 1748
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
#line 1748
      tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 1748
      tmp___0 = tmp;
    }
#line 1748
    switch (tmp___0) {
    case 5: 
#line 1753
    ptr += 2;
#line 1753
    break;
    case 6: 
#line 1753
    ptr += 3;
#line 1753
    break;
    case 7: 
#line 1753
    ptr += 4;
#line 1753
    break;
    case 10: 
#line 1756
    pos->columnNumber = (XML_Size )-1;
#line 1757
    (pos->lineNumber) ++;
#line 1758
    ptr += 2;
#line 1759
    break;
    case 9: 
#line 1761
    (pos->lineNumber) ++;
#line 1762
    ptr += 2;
#line 1763
    if ((unsigned long )ptr != (unsigned long )end) {
#line 1763
      if ((int const   )*(ptr + 0) == 0) {
#line 1763
        tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
      } else {
#line 1763
        tmp___1 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 1763
        tmp___2 = tmp___1;
      }
#line 1763
      if (tmp___2 == 10) {
#line 1764
        ptr += 2;
      }
    }
#line 1765
    pos->columnNumber = (XML_Size )-1;
#line 1766
    break;
    default: 
#line 1768
    ptr += 2;
#line 1769
    break;
    }
#line 1771
    (pos->columnNumber) ++;
  }
#line 1773
  return;
}
}
#line 858 "xmltok.c"
static struct normal_encoding  const  big2_encoding_ns  = 
#line 858 "xmltok.c"
     {{{& big2_prologTok, & big2_contentTok, & big2_cdataSectionTok, & big2_ignoreSectionTok},
     {& big2_attributeValueTok, & big2_entityValueTok}, & big2_sameName, & big2_nameMatchesAscii,
     & big2_nameLength, & big2_skipS, & big2_getAtts, & big2_charRefNumber, & big2_predefinedEntityName,
     & big2_updatePosition, & big2_isPublicId, & big2_toUtf8, & big2_toUtf16, 2, (char)0,
     (char)0}, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                (unsigned char)0, (unsigned char)21, (unsigned char)10, (unsigned char)0,
                (unsigned char)0, (unsigned char)9, (unsigned char)0, (unsigned char)0,
                (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                (unsigned char)21, (unsigned char)16, (unsigned char)12, (unsigned char)19,
                (unsigned char)28, (unsigned char)30, (unsigned char)3, (unsigned char)13,
                (unsigned char)31, (unsigned char)32, (unsigned char)33, (unsigned char)34,
                (unsigned char)35, (unsigned char)27, (unsigned char)26, (unsigned char)17,
                (unsigned char)25, (unsigned char)25, (unsigned char)25, (unsigned char)25,
                (unsigned char)25, (unsigned char)25, (unsigned char)25, (unsigned char)25,
                (unsigned char)25, (unsigned char)25, (unsigned char)23, (unsigned char)18,
                (unsigned char)2, (unsigned char)14, (unsigned char)11, (unsigned char)15,
                (unsigned char)28, (unsigned char)24, (unsigned char)24, (unsigned char)24,
                (unsigned char)24, (unsigned char)24, (unsigned char)24, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)20,
                (unsigned char)28, (unsigned char)4, (unsigned char)28, (unsigned char)22,
                (unsigned char)28, (unsigned char)24, (unsigned char)24, (unsigned char)24,
                (unsigned char)24, (unsigned char)24, (unsigned char)24, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)28,
                (unsigned char)36, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)22, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)22, (unsigned char)28, (unsigned char)26,
                (unsigned char)28, (unsigned char)28, (unsigned char)22, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)28,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)28,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22},
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0};
#line 875 "xmltok.c"
static struct normal_encoding  const  big2_encoding  = 
#line 875
     {{{& big2_prologTok, & big2_contentTok, & big2_cdataSectionTok, & big2_ignoreSectionTok},
     {& big2_attributeValueTok, & big2_entityValueTok}, & big2_sameName, & big2_nameMatchesAscii,
     & big2_nameLength, & big2_skipS, & big2_getAtts, & big2_charRefNumber, & big2_predefinedEntityName,
     & big2_updatePosition, & big2_isPublicId, & big2_toUtf8, & big2_toUtf16, 2, (char)0,
     (char)0}, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                (unsigned char)0, (unsigned char)21, (unsigned char)10, (unsigned char)0,
                (unsigned char)0, (unsigned char)9, (unsigned char)0, (unsigned char)0,
                (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                (unsigned char)21, (unsigned char)16, (unsigned char)12, (unsigned char)19,
                (unsigned char)28, (unsigned char)30, (unsigned char)3, (unsigned char)13,
                (unsigned char)31, (unsigned char)32, (unsigned char)33, (unsigned char)34,
                (unsigned char)35, (unsigned char)27, (unsigned char)26, (unsigned char)17,
                (unsigned char)25, (unsigned char)25, (unsigned char)25, (unsigned char)25,
                (unsigned char)25, (unsigned char)25, (unsigned char)25, (unsigned char)25,
                (unsigned char)25, (unsigned char)25, (unsigned char)22, (unsigned char)18,
                (unsigned char)2, (unsigned char)14, (unsigned char)11, (unsigned char)15,
                (unsigned char)28, (unsigned char)24, (unsigned char)24, (unsigned char)24,
                (unsigned char)24, (unsigned char)24, (unsigned char)24, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)20,
                (unsigned char)28, (unsigned char)4, (unsigned char)28, (unsigned char)22,
                (unsigned char)28, (unsigned char)24, (unsigned char)24, (unsigned char)24,
                (unsigned char)24, (unsigned char)24, (unsigned char)24, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)28,
                (unsigned char)36, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)22, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)22, (unsigned char)28, (unsigned char)26,
                (unsigned char)28, (unsigned char)28, (unsigned char)22, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)28,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)28,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22},
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0};
#line 922 "xmltok.c"
static int streqci(char const   *s1 , char const   *s2 ) 
{ 
  char c1 ;
  char const   *tmp ;
  char c2 ;
  char const   *tmp___0 ;

  {
#line 925
  while (1) {
#line 926
    tmp = s1;
#line 926
    s1 ++;
#line 926
    c1 = (char )*tmp;
#line 927
    tmp___0 = s2;
#line 927
    s2 ++;
#line 927
    c2 = (char )*tmp___0;
#line 928
    if (97 <= (int )c1) {
#line 928
      if ((int )c1 <= 122) {
#line 929
        c1 = (char )((int )c1 + -32);
      }
    }
#line 930
    if (97 <= (int )c2) {
#line 930
      if ((int )c2 <= 122) {
#line 931
        c2 = (char )((int )c2 + -32);
      }
    }
#line 932
    if ((int )c1 != (int )c2) {
#line 933
      return (0);
    }
#line 934
    if (! c1) {
#line 935
      break;
    }
  }
#line 937
  return (1);
}
}
#line 940 "xmltok.c"
static void initUpdatePosition(ENCODING const   *enc , char const   *ptr , char const   *end ,
                               POSITION *pos ) 
{ 


  {
#line 944
  normal_updatePosition(& utf8_encoding.enc, ptr, end, pos);
#line 945
  return;
}
}
#line 947 "xmltok.c"
static int toAscii(ENCODING const   *enc , char const   *ptr , char const   *end ) 
{ 
  char buf[1] ;
  char *p ;

  {
#line 951
  p = buf;
#line 952
  (*(enc->utf8Convert))(enc, & ptr, end, & p, (char const   *)(p + 1));
#line 953
  if ((unsigned long )p == (unsigned long )(buf)) {
#line 954
    return (-1);
  } else {
#line 956
    return ((int )buf[0]);
  }
}
}
#line 959 "xmltok.c"
static int isSpace(int c ) 
{ 


  {
#line 962
  switch (c) {
  case 9: 
  case 10: 
  case 13: 
  case 32: 
#line 967
  return (1);
  }
#line 969
  return (0);
}
}
#line 975 "xmltok.c"
static int parsePseudoAttribute(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                char const   **namePtr , char const   **nameEndPtr ,
                                char const   **valPtr , char const   **nextTokPtr ) 
{ 
  int c ;
  char open ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 986
  if ((unsigned long )ptr == (unsigned long )end) {
#line 987
    *namePtr = (char const   *)((void *)0);
#line 988
    return (1);
  }
#line 990
  tmp = toAscii(enc, ptr, end);
#line 990
  tmp___0 = isSpace(tmp);
#line 990
  if (! tmp___0) {
#line 991
    *nextTokPtr = ptr;
#line 992
    return (0);
  }
#line 994
  while (1) {
#line 995
    ptr += enc->minBytesPerChar;
#line 994
    tmp___1 = toAscii(enc, ptr, end);
#line 994
    tmp___2 = isSpace(tmp___1);
#line 994
    if (! tmp___2) {
#line 994
      break;
    }
  }
#line 997
  if ((unsigned long )ptr == (unsigned long )end) {
#line 998
    *namePtr = (char const   *)((void *)0);
#line 999
    return (1);
  }
#line 1001
  *namePtr = ptr;
#line 1002
  while (1) {
#line 1003
    c = toAscii(enc, ptr, end);
#line 1004
    if (c == -1) {
#line 1005
      *nextTokPtr = ptr;
#line 1006
      return (0);
    }
#line 1008
    if (c == 61) {
#line 1009
      *nameEndPtr = ptr;
#line 1010
      break;
    }
#line 1012
    tmp___4 = isSpace(c);
#line 1012
    if (tmp___4) {
#line 1013
      *nameEndPtr = ptr;
#line 1014
      while (1) {
#line 1015
        ptr += enc->minBytesPerChar;
#line 1014
        c = toAscii(enc, ptr, end);
#line 1014
        tmp___3 = isSpace(c);
#line 1014
        if (! tmp___3) {
#line 1014
          break;
        }
      }
#line 1017
      if (c != 61) {
#line 1018
        *nextTokPtr = ptr;
#line 1019
        return (0);
      }
#line 1021
      break;
    }
#line 1023
    ptr += enc->minBytesPerChar;
  }
#line 1025
  if ((unsigned long )ptr == (unsigned long )*namePtr) {
#line 1026
    *nextTokPtr = ptr;
#line 1027
    return (0);
  }
#line 1029
  ptr += enc->minBytesPerChar;
#line 1030
  c = toAscii(enc, ptr, end);
#line 1031
  while (1) {
#line 1031
    tmp___5 = isSpace(c);
#line 1031
    if (! tmp___5) {
#line 1031
      break;
    }
#line 1032
    ptr += enc->minBytesPerChar;
#line 1033
    c = toAscii(enc, ptr, end);
  }
#line 1035
  if (c != 34) {
#line 1035
    if (c != 39) {
#line 1036
      *nextTokPtr = ptr;
#line 1037
      return (0);
    }
  }
#line 1039
  open = (char )c;
#line 1040
  ptr += enc->minBytesPerChar;
#line 1041
  *valPtr = ptr;
#line 1042
  while (1) {
#line 1043
    c = toAscii(enc, ptr, end);
#line 1044
    if (c == (int )open) {
#line 1045
      break;
    }
#line 1046
    if (97 <= c) {
#line 1046
      if (! (c <= 122)) {
#line 1046
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 1046
    if (65 <= c) {
#line 1046
      if (! (c <= 90)) {
#line 1046
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1046
    if (48 <= c) {
#line 1046
      if (! (c <= 57)) {
#line 1046
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1046
    if (c != 46) {
#line 1046
      if (c != 45) {
#line 1046
        if (c != 95) {
#line 1052
          *nextTokPtr = ptr;
#line 1053
          return (0);
        }
      }
    }
#line 1042
    ptr += enc->minBytesPerChar;
  }
#line 1056
  *nextTokPtr = ptr + enc->minBytesPerChar;
#line 1057
  return (1);
}
}
#line 1060 "xmltok.c"
static char const   KW_version[8]  = 
#line 1060
  {      (char const   )118,      (char const   )101,      (char const   )114,      (char const   )115, 
        (char const   )105,      (char const   )111,      (char const   )110,      (char const   )'\000'};
#line 1064 "xmltok.c"
static char const   KW_encoding[9]  = 
#line 1064
  {      (char const   )101,      (char const   )110,      (char const   )99,      (char const   )111, 
        (char const   )100,      (char const   )105,      (char const   )110,      (char const   )103, 
        (char const   )'\000'};
#line 1068 "xmltok.c"
static char const   KW_standalone[11]  = 
#line 1068
  {      (char const   )115,      (char const   )116,      (char const   )97,      (char const   )110, 
        (char const   )100,      (char const   )97,      (char const   )108,      (char const   )111, 
        (char const   )110,      (char const   )101,      (char const   )'\000'};
#line 1073 "xmltok.c"
static char const   KW_yes[4]  = {      (char const   )121,      (char const   )101,      (char const   )115,      (char const   )'\000'};
#line 1077 "xmltok.c"
static char const   KW_no[3]  = {      (char const   )110,      (char const   )111,      (char const   )'\000'};
#line 1081 "xmltok.c"
static int doParseXmlDecl(ENCODING const   *(*encodingFinder)(ENCODING const   * ,
                                                              char const   * , char const   * ) ,
                          int isGeneralTextEntity , ENCODING const   *enc , char const   *ptr ,
                          char const   *end , char const   **badPtr , char const   **versionPtr ,
                          char const   **versionEndPtr , char const   **encodingName ,
                          ENCODING const   **encoding , int *standalone ) 
{ 
  char const   *val ;
  char const   *name ;
  char const   *nameEnd ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int c ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 1096
  val = (char const   *)((void *)0);
#line 1097
  name = (char const   *)((void *)0);
#line 1098
  nameEnd = (char const   *)((void *)0);
#line 1099
  ptr += 5 * (int )enc->minBytesPerChar;
#line 1100
  end -= 2 * (int )enc->minBytesPerChar;
#line 1101
  tmp = parsePseudoAttribute(enc, ptr, end, & name, & nameEnd, & val, & ptr);
#line 1101
  if (tmp) {
#line 1101
    if (! name) {
#line 1103
      *badPtr = ptr;
#line 1104
      return (0);
    }
  } else {
#line 1103
    *badPtr = ptr;
#line 1104
    return (0);
  }
#line 1106
  tmp___1 = (*(enc->nameMatchesAscii))(enc, name, nameEnd, KW_version);
#line 1106
  if (tmp___1) {
#line 1113
    if (versionPtr) {
#line 1114
      *versionPtr = val;
    }
#line 1115
    if (versionEndPtr) {
#line 1116
      *versionEndPtr = ptr;
    }
#line 1117
    tmp___0 = parsePseudoAttribute(enc, ptr, end, & name, & nameEnd, & val, & ptr);
#line 1117
    if (! tmp___0) {
#line 1118
      *badPtr = ptr;
#line 1119
      return (0);
    }
#line 1121
    if (! name) {
#line 1122
      if (isGeneralTextEntity) {
#line 1124
        *badPtr = ptr;
#line 1125
        return (0);
      }
#line 1127
      return (1);
    }
  } else
#line 1107
  if (! isGeneralTextEntity) {
#line 1108
    *badPtr = name;
#line 1109
    return (0);
  }
#line 1130
  tmp___4 = (*(enc->nameMatchesAscii))(enc, name, nameEnd, KW_encoding);
#line 1130
  if (tmp___4) {
#line 1131
    tmp___2 = toAscii(enc, val, end);
#line 1131
    c = tmp___2;
#line 1132
    if (97 <= c) {
#line 1132
      if (! (c <= 122)) {
#line 1132
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1132
    if (65 <= c) {
#line 1132
      if (! (c <= 90)) {
#line 1133
        *badPtr = val;
#line 1134
        return (0);
      }
    } else {
#line 1133
      *badPtr = val;
#line 1134
      return (0);
    }
#line 1136
    if (encodingName) {
#line 1137
      *encodingName = val;
    }
#line 1138
    if (encoding) {
#line 1139
      *encoding = (*encodingFinder)(enc, val, ptr - enc->minBytesPerChar);
    }
#line 1140
    tmp___3 = parsePseudoAttribute(enc, ptr, end, & name, & nameEnd, & val, & ptr);
#line 1140
    if (! tmp___3) {
#line 1141
      *badPtr = ptr;
#line 1142
      return (0);
    }
#line 1144
    if (! name) {
#line 1145
      return (1);
    }
  }
#line 1147
  tmp___5 = (*(enc->nameMatchesAscii))(enc, name, nameEnd, KW_standalone);
#line 1147
  if (tmp___5) {
#line 1147
    if (isGeneralTextEntity) {
#line 1149
      *badPtr = name;
#line 1150
      return (0);
    }
  } else {
#line 1149
    *badPtr = name;
#line 1150
    return (0);
  }
#line 1152
  tmp___7 = (*(enc->nameMatchesAscii))(enc, val, ptr - enc->minBytesPerChar, KW_yes);
#line 1152
  if (tmp___7) {
#line 1153
    if (standalone) {
#line 1154
      *standalone = 1;
    }
  } else {
#line 1156
    tmp___6 = (*(enc->nameMatchesAscii))(enc, val, ptr - enc->minBytesPerChar, KW_no);
#line 1156
    if (tmp___6) {
#line 1157
      if (standalone) {
#line 1158
        *standalone = 0;
      }
    } else {
#line 1161
      *badPtr = val;
#line 1162
      return (0);
    }
  }
#line 1164
  while (1) {
#line 1164
    tmp___8 = toAscii(enc, ptr, end);
#line 1164
    tmp___9 = isSpace(tmp___8);
#line 1164
    if (! tmp___9) {
#line 1164
      break;
    }
#line 1165
    ptr += enc->minBytesPerChar;
  }
#line 1166
  if ((unsigned long )ptr != (unsigned long )end) {
#line 1167
    *badPtr = ptr;
#line 1168
    return (0);
  }
#line 1170
  return (1);
}
}
#line 1173 "xmltok.c"
static int checkCharRefNumber(int result ) 
{ 


  {
#line 1176
  switch (result >> 8) {
  case 223: 
  case 222: 
  case 221: 
  case 220: 
  case 219: 
  case 218: 
  case 217: 
  case 216: 
#line 1179
  return (-1);
  case 0: 
#line 1181
  if ((int )latin1_encoding.type[result] == 0) {
#line 1182
    return (-1);
  }
#line 1183
  break;
  case 255: 
#line 1185
  if (result == 65534) {
#line 1186
    return (-1);
  } else
#line 1185
  if (result == 65535) {
#line 1186
    return (-1);
  }
#line 1187
  break;
  }
#line 1189
  return (result);
}
}
#line 1192 "xmltok.c"
int XmlUtf8Encode(int c , char *buf ) 
{ 


  {
#line 1202
  if (c < 0) {
#line 1203
    return (0);
  }
#line 1204
  if (c < 128) {
#line 1205
    *(buf + 0) = (char )c;
#line 1206
    return (1);
  }
#line 1208
  if (c < 2048) {
#line 1209
    *(buf + 0) = (char )((c >> 6) | 192);
#line 1210
    *(buf + 1) = (char )((c & 63) | 128);
#line 1211
    return (2);
  }
#line 1213
  if (c < 65536) {
#line 1214
    *(buf + 0) = (char )((c >> 12) | 224);
#line 1215
    *(buf + 1) = (char )(((c >> 6) & 63) | 128);
#line 1216
    *(buf + 2) = (char )((c & 63) | 128);
#line 1217
    return (3);
  }
#line 1219
  if (c < 1114112) {
#line 1220
    *(buf + 0) = (char )((c >> 18) | 240);
#line 1221
    *(buf + 1) = (char )(((c >> 12) & 63) | 128);
#line 1222
    *(buf + 2) = (char )(((c >> 6) & 63) | 128);
#line 1223
    *(buf + 3) = (char )((c & 63) | 128);
#line 1224
    return (4);
  }
#line 1226
  return (0);
}
}
#line 1229 "xmltok.c"
int XmlUtf16Encode(int charNum , unsigned short *buf ) 
{ 


  {
#line 1232
  if (charNum < 0) {
#line 1233
    return (0);
  }
#line 1234
  if (charNum < 65536) {
#line 1235
    *(buf + 0) = (unsigned short )charNum;
#line 1236
    return (1);
  }
#line 1238
  if (charNum < 1114112) {
#line 1239
    charNum -= 65536;
#line 1240
    *(buf + 0) = (unsigned short )((charNum >> 10) + 55296);
#line 1241
    *(buf + 1) = (unsigned short )((charNum & 1023) + 56320);
#line 1242
    return (2);
  }
#line 1244
  return (0);
}
}
#line 1257 "xmltok.c"
int XmlSizeOfUnknownEncoding(void) 
{ 


  {
#line 1260
  return ((int )sizeof(struct unknown_encoding ));
}
}
#line 1263 "xmltok.c"
static int unknown_isName(ENCODING const   *enc , char const   *p ) 
{ 
  struct unknown_encoding  const  *uenc ;
  int c ;
  int tmp ;

  {
#line 1266
  uenc = (struct unknown_encoding  const  *)enc;
#line 1267
  tmp = (*(uenc->convert))((void *)uenc->userData, p);
#line 1267
  c = tmp;
#line 1268
  if (c & -65536) {
#line 1269
    return (0);
  }
#line 1270
  return ((int )(namingBitmap[((int const   )namePages[c >> 8] << 3) + (int const   )((c & 255) >> 5)] & (unsigned int const   )(1 << ((c & 255) & 31))));
}
}
#line 1273 "xmltok.c"
static int unknown_isNmstrt(ENCODING const   *enc , char const   *p ) 
{ 
  struct unknown_encoding  const  *uenc ;
  int c ;
  int tmp ;

  {
#line 1276
  uenc = (struct unknown_encoding  const  *)enc;
#line 1277
  tmp = (*(uenc->convert))((void *)uenc->userData, p);
#line 1277
  c = tmp;
#line 1278
  if (c & -65536) {
#line 1279
    return (0);
  }
#line 1280
  return ((int )(namingBitmap[((int const   )nmstrtPages[c >> 8] << 3) + (int const   )((c & 255) >> 5)] & (unsigned int const   )(1 << ((c & 255) & 31))));
}
}
#line 1283 "xmltok.c"
static int unknown_isInvalid(ENCODING const   *enc , char const   *p ) 
{ 
  struct unknown_encoding  const  *uenc ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1286
  uenc = (struct unknown_encoding  const  *)enc;
#line 1287
  tmp = (*(uenc->convert))((void *)uenc->userData, p);
#line 1287
  c = tmp;
#line 1288
  if (c & -65536) {
#line 1288
    tmp___1 = 1;
  } else {
#line 1288
    tmp___0 = checkCharRefNumber(c);
#line 1288
    if (tmp___0 < 0) {
#line 1288
      tmp___1 = 1;
    } else {
#line 1288
      tmp___1 = 0;
    }
  }
#line 1288
  return (tmp___1);
}
}
#line 1291 "xmltok.c"
static void unknown_toUtf8(ENCODING const   *enc , char const   **fromP , char const   *fromLim ,
                           char **toP , char const   *toLim ) 
{ 
  struct unknown_encoding  const  *uenc ;
  char buf[4] ;
  char const   *utf8 ;
  int n ;
  char const   *tmp ;
  int c ;
  int tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 1296
  uenc = (struct unknown_encoding  const  *)enc;
#line 1298
  while (! ((unsigned long )*fromP == (unsigned long )fromLim)) {
#line 1303
    utf8 = (char const   *)(uenc->utf8[(unsigned char )*(*fromP)]);
#line 1304
    tmp = utf8;
#line 1304
    utf8 ++;
#line 1304
    n = (int )*tmp;
#line 1305
    if (n == 0) {
#line 1306
      tmp___0 = (*(uenc->convert))((void *)uenc->userData, *fromP);
#line 1306
      c = tmp___0;
#line 1307
      n = XmlUtf8Encode(c, buf);
#line 1308
      if ((long )n > toLim - (char const   *)*toP) {
#line 1309
        break;
      }
#line 1310
      utf8 = (char const   *)(buf);
#line 1311
      *fromP += (int )((struct normal_encoding  const  *)enc)->type[(unsigned char )*(*fromP)] - 3;
    } else {
#line 1315
      if ((long )n > toLim - (char const   *)*toP) {
#line 1316
        break;
      }
#line 1317
      (*fromP) ++;
    }
#line 1319
    while (1) {
#line 1320
      tmp___1 = *toP;
#line 1320
      (*toP) ++;
#line 1320
      tmp___2 = utf8;
#line 1320
      utf8 ++;
#line 1320
      *tmp___1 = (char )*tmp___2;
#line 1319
      n --;
#line 1319
      if (! (n != 0)) {
#line 1319
        break;
      }
    }
  }
#line 1323
  return;
}
}
#line 1325 "xmltok.c"
static void unknown_toUtf16(ENCODING const   *enc , char const   **fromP , char const   *fromLim ,
                            unsigned short **toP , unsigned short const   *toLim ) 
{ 
  struct unknown_encoding  const  *uenc ;
  unsigned short c ;
  int tmp ;
  unsigned short *tmp___0 ;

  {
#line 1330
  uenc = (struct unknown_encoding  const  *)enc;
#line 1331
  while (1) {
#line 1331
    if ((unsigned long )*fromP != (unsigned long )fromLim) {
#line 1331
      if (! ((unsigned long )*toP != (unsigned long )toLim)) {
#line 1331
        break;
      }
    } else {
#line 1331
      break;
    }
#line 1332
    c = uenc->utf16[(unsigned char )*(*fromP)];
#line 1333
    if ((int )c == 0) {
#line 1334
      tmp = (*(uenc->convert))((void *)uenc->userData, *fromP);
#line 1334
      c = (unsigned short )tmp;
#line 1336
      *fromP += (int )((struct normal_encoding  const  *)enc)->type[(unsigned char )*(*fromP)] - 3;
    } else {
#line 1340
      (*fromP) ++;
    }
#line 1341
    tmp___0 = *toP;
#line 1341
    (*toP) ++;
#line 1341
    *tmp___0 = c;
  }
#line 1343
  return;
}
}
#line 1345 "xmltok.c"
ENCODING *XmlInitUnknownEncoding(void *mem , int *table , int (*convert)(void *userData ,
                                                                         char const   *p ) ,
                                 void *userData ) 
{ 
  int i ;
  struct unknown_encoding *e ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1352
  e = (struct unknown_encoding *)mem;
#line 1353
  i = 0;
#line 1353
  while (i < (int )sizeof(struct normal_encoding )) {
#line 1354
    *((char *)mem + i) = *((char *)(& latin1_encoding) + i);
#line 1353
    i ++;
  }
#line 1355
  i = 0;
#line 1355
  while (i < 128) {
#line 1356
    if ((int )latin1_encoding.type[i] != 28) {
#line 1356
      if ((int )latin1_encoding.type[i] != 0) {
#line 1356
        if (*(table + i) != i) {
#line 1359
          return ((ENCODING *)0);
        }
      }
    }
#line 1355
    i ++;
  }
#line 1360
  i = 0;
#line 1360
  while (i < 256) {
#line 1361
    c = *(table + i);
#line 1362
    if (c == -1) {
#line 1363
      e->normal.type[i] = (unsigned char)1;
#line 1365
      e->utf16[i] = (unsigned short)65535;
#line 1366
      e->utf8[i][0] = (char)1;
#line 1367
      e->utf8[i][1] = (char)0;
    } else
#line 1369
    if (c < 0) {
#line 1370
      if (c < -4) {
#line 1371
        return ((ENCODING *)0);
      }
#line 1372
      e->normal.type[i] = (unsigned char )(5 - (c + 2));
#line 1373
      e->utf8[i][0] = (char)0;
#line 1374
      e->utf16[i] = (unsigned short)0;
    } else
#line 1376
    if (c < 128) {
#line 1377
      if ((int )latin1_encoding.type[c] != 28) {
#line 1377
        if ((int )latin1_encoding.type[c] != 0) {
#line 1377
          if (c != i) {
#line 1380
            return ((ENCODING *)0);
          }
        }
      }
#line 1381
      e->normal.type[i] = latin1_encoding.type[c];
#line 1382
      e->utf8[i][0] = (char)1;
#line 1383
      e->utf8[i][1] = (char )c;
#line 1384
      if (c == 0) {
#line 1384
        tmp = 65535;
      } else {
#line 1384
        tmp = c;
      }
#line 1384
      e->utf16[i] = (unsigned short )tmp;
    } else {
#line 1386
      tmp___1 = checkCharRefNumber(c);
#line 1386
      if (tmp___1 < 0) {
#line 1387
        e->normal.type[i] = (unsigned char)0;
#line 1389
        e->utf16[i] = (unsigned short)65535;
#line 1390
        e->utf8[i][0] = (char)1;
#line 1391
        e->utf8[i][1] = (char)0;
      } else {
#line 1394
        if (c > 65535) {
#line 1395
          return ((ENCODING *)0);
        }
#line 1396
        if (namingBitmap[((int const   )nmstrtPages[c >> 8] << 3) + (int const   )((c & 255) >> 5)] & (unsigned int const   )(1 << ((c & 255) & 31))) {
#line 1397
          e->normal.type[i] = (unsigned char)22;
        } else
#line 1398
        if (namingBitmap[((int const   )namePages[c >> 8] << 3) + (int const   )((c & 255) >> 5)] & (unsigned int const   )(1 << ((c & 255) & 31))) {
#line 1399
          e->normal.type[i] = (unsigned char)26;
        } else {
#line 1401
          e->normal.type[i] = (unsigned char)28;
        }
#line 1402
        tmp___0 = XmlUtf8Encode(c, e->utf8[i] + 1);
#line 1402
        e->utf8[i][0] = (char )tmp___0;
#line 1403
        e->utf16[i] = (unsigned short )c;
      }
    }
#line 1360
    i ++;
  }
#line 1406
  e->userData = userData;
#line 1407
  e->convert = convert;
#line 1408
  if (convert) {
#line 1409
    e->normal.isName2 = & unknown_isName;
#line 1410
    e->normal.isName3 = & unknown_isName;
#line 1411
    e->normal.isName4 = & unknown_isName;
#line 1412
    e->normal.isNmstrt2 = & unknown_isNmstrt;
#line 1413
    e->normal.isNmstrt3 = & unknown_isNmstrt;
#line 1414
    e->normal.isNmstrt4 = & unknown_isNmstrt;
#line 1415
    e->normal.isInvalid2 = & unknown_isInvalid;
#line 1416
    e->normal.isInvalid3 = & unknown_isInvalid;
#line 1417
    e->normal.isInvalid4 = & unknown_isInvalid;
  }
#line 1419
  e->normal.enc.utf8Convert = & unknown_toUtf8;
#line 1420
  e->normal.enc.utf16Convert = & unknown_toUtf16;
#line 1421
  return (& e->normal.enc);
}
}
#line 1438 "xmltok.c"
static char const   KW_ISO_8859_1[11]  = 
#line 1438
  {      (char const   )73,      (char const   )83,      (char const   )79,      (char const   )45, 
        (char const   )56,      (char const   )56,      (char const   )53,      (char const   )57, 
        (char const   )45,      (char const   )49,      (char const   )'\000'};
#line 1442 "xmltok.c"
static char const   KW_US_ASCII[9]  = 
#line 1442
  {      (char const   )85,      (char const   )83,      (char const   )45,      (char const   )65, 
        (char const   )83,      (char const   )67,      (char const   )73,      (char const   )73, 
        (char const   )'\000'};
#line 1446 "xmltok.c"
static char const   KW_UTF_8[6]  = {      (char const   )85,      (char const   )84,      (char const   )70,      (char const   )45, 
        (char const   )56,      (char const   )'\000'};
#line 1449 "xmltok.c"
static char const   KW_UTF_16[7]  = {      (char const   )85,      (char const   )84,      (char const   )70,      (char const   )45, 
        (char const   )49,      (char const   )54,      (char const   )'\000'};
#line 1452 "xmltok.c"
static char const   KW_UTF_16BE[9]  = 
#line 1452
  {      (char const   )85,      (char const   )84,      (char const   )70,      (char const   )45, 
        (char const   )49,      (char const   )54,      (char const   )66,      (char const   )69, 
        (char const   )'\000'};
#line 1456 "xmltok.c"
static char const   KW_UTF_16LE[9]  = 
#line 1456
  {      (char const   )85,      (char const   )84,      (char const   )70,      (char const   )45, 
        (char const   )49,      (char const   )54,      (char const   )76,      (char const   )69, 
        (char const   )'\000'};
#line 1464
static int getEncodingIndex(char const   *name ) ;
#line 1464 "xmltok.c"
static char const   * const  encodingNames[6]  = {      (char const   * const  )(KW_ISO_8859_1),      (char const   * const  )(KW_US_ASCII),      (char const   * const  )(KW_UTF_8),      (char const   * const  )(KW_UTF_16), 
        (char const   * const  )(KW_UTF_16BE),      (char const   * const  )(KW_UTF_16LE)};
#line 1461 "xmltok.c"
static int getEncodingIndex(char const   *name ) 
{ 
  int i ;
  int tmp ;

  {
#line 1473
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 1474
    return (6);
  }
#line 1475
  i = 0;
#line 1475
  while (i < (int )(sizeof(encodingNames) / sizeof(encodingNames[0]))) {
#line 1476
    tmp = streqci(name, (char const   *)encodingNames[i]);
#line 1476
    if (tmp) {
#line 1477
      return (i);
    }
#line 1475
    i ++;
  }
#line 1478
  return (-1);
}
}
#line 1496 "xmltok.c"
static int initScan(ENCODING const   * const  *encodingTable , INIT_ENCODING const   *enc ,
                    int state , char const   *ptr , char const   *end , char const   **nextTokPtr ) 
{ 
  ENCODING const   **encPtr ;
  int tmp ;
  int e ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1506
  if ((unsigned long )ptr == (unsigned long )end) {
#line 1507
    return (-4);
  }
#line 1508
  encPtr = (ENCODING const   **)enc->encPtr;
#line 1509
  if ((unsigned long )(ptr + 1) == (unsigned long )end) {
#line 1518
    switch ((int )enc->initEnc.isUtf16) {
    case 4: 
    case 5: 
    case 3: 
#line 1522
    return (-1);
    }
#line 1524
    switch ((int )((unsigned char )*ptr)) {
    case 239: 
    case 255: 
    case 254: 
#line 1528
    if ((int )enc->initEnc.isUtf16 == 0) {
#line 1528
      if (state == 1) {
#line 1530
        break;
      }
    }
    case 60: 
    case 0: 
#line 1534
    return (-1);
    }
  } else {
#line 1538
    switch (((int )((unsigned char )*(ptr + 0)) << 8) | (int )((unsigned char )*(ptr + 1))) {
    case 65279: 
#line 1540
    if ((int )enc->initEnc.isUtf16 == 0) {
#line 1540
      if (state == 1) {
#line 1542
        break;
      }
    }
#line 1543
    *nextTokPtr = ptr + 2;
#line 1544
    *encPtr = (ENCODING const   *)*(encodingTable + 4);
#line 1545
    return (14);
    case 15360: 
#line 1548
    if ((int )enc->initEnc.isUtf16 == 4) {
#line 1548
      goto _L;
    } else
#line 1548
    if ((int )enc->initEnc.isUtf16 == 3) {
      _L: /* CIL Label */ 
#line 1548
      if (state == 1) {
#line 1551
        break;
      }
    }
#line 1552
    *encPtr = (ENCODING const   *)*(encodingTable + 5);
#line 1553
    tmp = (*((*encPtr)->scanners[state]))(*encPtr, ptr, end, nextTokPtr);
#line 1553
    return (tmp);
    case 65534: 
#line 1555
    if ((int )enc->initEnc.isUtf16 == 0) {
#line 1555
      if (state == 1) {
#line 1557
        break;
      }
    }
#line 1558
    *nextTokPtr = ptr + 2;
#line 1559
    *encPtr = (ENCODING const   *)*(encodingTable + 5);
#line 1560
    return (14);
    case 61371: 
#line 1569
    if (state == 1) {
#line 1570
      e = (int )enc->initEnc.isUtf16;
#line 1571
      if (e == 0) {
#line 1573
        break;
      } else
#line 1571
      if (e == 4) {
#line 1573
        break;
      } else
#line 1571
      if (e == 5) {
#line 1573
        break;
      } else
#line 1571
      if (e == 3) {
#line 1573
        break;
      }
    }
#line 1575
    if ((unsigned long )(ptr + 2) == (unsigned long )end) {
#line 1576
      return (-1);
    }
#line 1577
    if ((int )((unsigned char )*(ptr + 2)) == 191) {
#line 1578
      *nextTokPtr = ptr + 3;
#line 1579
      *encPtr = (ENCODING const   *)*(encodingTable + 2);
#line 1580
      return (14);
    }
#line 1582
    break;
    default: 
#line 1584
    if ((int const   )*(ptr + 0) == 0) {
#line 1591
      if (state == 1) {
#line 1591
        if ((int )enc->initEnc.isUtf16 == 5) {
#line 1592
          break;
        }
      }
#line 1593
      *encPtr = (ENCODING const   *)*(encodingTable + 4);
#line 1594
      tmp___0 = (*((*encPtr)->scanners[state]))(*encPtr, ptr, end, nextTokPtr);
#line 1594
      return (tmp___0);
    } else
#line 1596
    if ((int const   )*(ptr + 1) == 0) {
#line 1606
      if (state == 1) {
#line 1607
        break;
      }
#line 1608
      *encPtr = (ENCODING const   *)*(encodingTable + 5);
#line 1609
      tmp___1 = (*((*encPtr)->scanners[state]))(*encPtr, ptr, end, nextTokPtr);
#line 1609
      return (tmp___1);
    }
#line 1611
    break;
    }
  }
#line 1614
  *encPtr = (ENCODING const   *)*(encodingTable + (int )enc->initEnc.isUtf16);
#line 1615
  tmp___2 = (*((*encPtr)->scanners[state]))(*encPtr, ptr, end, nextTokPtr);
#line 1615
  return (tmp___2);
}
}
#line 8 "xmltok_ns.c"
ENCODING const   *XmlGetUtf8InternalEncoding(void) 
{ 


  {
#line 11
  return (& internal_utf8_encoding.enc);
}
}
#line 14 "xmltok_ns.c"
ENCODING const   *XmlGetUtf16InternalEncoding(void) 
{ 


  {
#line 18
  return (& internal_little2_encoding.enc);
}
}
#line 29 "xmltok_ns.c"
static ENCODING const   * const  encodings[7]  = {      (ENCODING const   * const  )(& latin1_encoding.enc),      (ENCODING const   * const  )(& ascii_encoding.enc),      (ENCODING const   * const  )(& utf8_encoding.enc),      (ENCODING const   * const  )(& big2_encoding.enc), 
        (ENCODING const   * const  )(& big2_encoding.enc),      (ENCODING const   * const  )(& little2_encoding.enc),      (ENCODING const   * const  )(& utf8_encoding.enc)};
#line 39 "xmltok_ns.c"
static int initScanProlog(ENCODING const   *enc , char const   *ptr , char const   *end ,
                          char const   **nextTokPtr ) 
{ 
  int tmp ;

  {
#line 43
  tmp = initScan(encodings, (INIT_ENCODING const   *)enc, 0, ptr, end, nextTokPtr);
#line 43
  return (tmp);
}
}
#line 47 "xmltok_ns.c"
static int initScanContent(ENCODING const   *enc , char const   *ptr , char const   *end ,
                           char const   **nextTokPtr ) 
{ 
  int tmp ;

  {
#line 51
  tmp = initScan(encodings, (INIT_ENCODING const   *)enc, 1, ptr, end, nextTokPtr);
#line 51
  return (tmp);
}
}
#line 55 "xmltok_ns.c"
int XmlInitEncoding(INIT_ENCODING *p , ENCODING const   **encPtr , char const   *name ) 
{ 
  int i ;
  int tmp ;

  {
#line 59
  tmp = getEncodingIndex(name);
#line 59
  i = tmp;
#line 60
  if (i == -1) {
#line 61
    return (0);
  }
#line 62
  p->initEnc.isUtf16 = (char )i;
#line 63
  p->initEnc.scanners[0] = & initScanProlog;
#line 64
  p->initEnc.scanners[1] = & initScanContent;
#line 65
  p->initEnc.updatePosition = & initUpdatePosition;
#line 66
  p->encPtr = encPtr;
#line 67
  *encPtr = (ENCODING const   *)(& p->initEnc);
#line 68
  return (1);
}
}
#line 71 "xmltok_ns.c"
static ENCODING const   *findEncoding(ENCODING const   *enc , char const   *ptr ,
                                      char const   *end ) 
{ 
  char buf[128] ;
  char *p ;
  int i ;
  int tmp ;

  {
#line 76
  p = buf;
#line 78
  (*(enc->utf8Convert))(enc, & ptr, end, & p, (char const   *)((p + 128) - 1));
#line 79
  if ((unsigned long )ptr != (unsigned long )end) {
#line 80
    return ((ENCODING const   *)0);
  }
#line 81
  *p = (char)0;
#line 82
  tmp = streqci((char const   *)(buf), KW_UTF_16);
#line 82
  if (tmp) {
#line 82
    if (enc->minBytesPerChar == 2) {
#line 83
      return (enc);
    }
  }
#line 84
  i = getEncodingIndex((char const   *)(buf));
#line 85
  if (i == -1) {
#line 86
    return ((ENCODING const   *)0);
  }
#line 87
  return ((ENCODING const   *)encodings[i]);
}
}
#line 90 "xmltok_ns.c"
int XmlParseXmlDecl(int isGeneralTextEntity , ENCODING const   *enc , char const   *ptr ,
                    char const   *end , char const   **badPtr , char const   **versionPtr ,
                    char const   **versionEndPtr , char const   **encodingName , ENCODING const   **encoding ,
                    int *standalone ) 
{ 
  int tmp ;

  {
#line 102
  tmp = doParseXmlDecl(& findEncoding, isGeneralTextEntity, enc, ptr, end, badPtr,
                       versionPtr, versionEndPtr, encodingName, encoding, standalone);
#line 102
  return (tmp);
}
}
#line 8 "xmltok_ns.c"
ENCODING const   *XmlGetUtf8InternalEncodingNS(void) 
{ 


  {
#line 11
  return (& internal_utf8_encoding_ns.enc);
}
}
#line 14 "xmltok_ns.c"
ENCODING const   *XmlGetUtf16InternalEncodingNS(void) 
{ 


  {
#line 18
  return (& internal_little2_encoding_ns.enc);
}
}
#line 29 "xmltok_ns.c"
static ENCODING const   * const  encodingsNS[7]  = {      (ENCODING const   * const  )(& latin1_encoding_ns.enc),      (ENCODING const   * const  )(& ascii_encoding_ns.enc),      (ENCODING const   * const  )(& utf8_encoding_ns.enc),      (ENCODING const   * const  )(& big2_encoding_ns.enc), 
        (ENCODING const   * const  )(& big2_encoding_ns.enc),      (ENCODING const   * const  )(& little2_encoding_ns.enc),      (ENCODING const   * const  )(& utf8_encoding_ns.enc)};
#line 39 "xmltok_ns.c"
static int initScanPrologNS(ENCODING const   *enc , char const   *ptr , char const   *end ,
                            char const   **nextTokPtr ) 
{ 
  int tmp ;

  {
#line 43
  tmp = initScan(encodingsNS, (INIT_ENCODING const   *)enc, 0, ptr, end, nextTokPtr);
#line 43
  return (tmp);
}
}
#line 47 "xmltok_ns.c"
static int initScanContentNS(ENCODING const   *enc , char const   *ptr , char const   *end ,
                             char const   **nextTokPtr ) 
{ 
  int tmp ;

  {
#line 51
  tmp = initScan(encodingsNS, (INIT_ENCODING const   *)enc, 1, ptr, end, nextTokPtr);
#line 51
  return (tmp);
}
}
#line 55 "xmltok_ns.c"
int XmlInitEncodingNS(INIT_ENCODING *p , ENCODING const   **encPtr , char const   *name ) 
{ 
  int i ;
  int tmp ;

  {
#line 59
  tmp = getEncodingIndex(name);
#line 59
  i = tmp;
#line 60
  if (i == -1) {
#line 61
    return (0);
  }
#line 62
  p->initEnc.isUtf16 = (char )i;
#line 63
  p->initEnc.scanners[0] = & initScanPrologNS;
#line 64
  p->initEnc.scanners[1] = & initScanContentNS;
#line 65
  p->initEnc.updatePosition = & initUpdatePosition;
#line 66
  p->encPtr = encPtr;
#line 67
  *encPtr = (ENCODING const   *)(& p->initEnc);
#line 68
  return (1);
}
}
#line 71 "xmltok_ns.c"
static ENCODING const   *findEncodingNS(ENCODING const   *enc , char const   *ptr ,
                                        char const   *end ) 
{ 
  char buf[128] ;
  char *p ;
  int i ;
  int tmp ;

  {
#line 76
  p = buf;
#line 78
  (*(enc->utf8Convert))(enc, & ptr, end, & p, (char const   *)((p + 128) - 1));
#line 79
  if ((unsigned long )ptr != (unsigned long )end) {
#line 80
    return ((ENCODING const   *)0);
  }
#line 81
  *p = (char)0;
#line 82
  tmp = streqci((char const   *)(buf), KW_UTF_16);
#line 82
  if (tmp) {
#line 82
    if (enc->minBytesPerChar == 2) {
#line 83
      return (enc);
    }
  }
#line 84
  i = getEncodingIndex((char const   *)(buf));
#line 85
  if (i == -1) {
#line 86
    return ((ENCODING const   *)0);
  }
#line 87
  return ((ENCODING const   *)encodingsNS[i]);
}
}
#line 90 "xmltok_ns.c"
int XmlParseXmlDeclNS(int isGeneralTextEntity , ENCODING const   *enc , char const   *ptr ,
                      char const   *end , char const   **badPtr , char const   **versionPtr ,
                      char const   **versionEndPtr , char const   **encodingName ,
                      ENCODING const   **encoding , int *standalone ) 
{ 
  int tmp ;

  {
#line 102
  tmp = doParseXmlDecl(& findEncodingNS, isGeneralTextEntity, enc, ptr, end, badPtr,
                       versionPtr, versionEndPtr, encodingName, encoding, standalone);
#line 102
  return (tmp);
}
}
#line 1639 "xmltok.c"
ENCODING *XmlInitUnknownEncodingNS(void *mem , int *table , int (*convert)(void *userData ,
                                                                           char const   *p ) ,
                                   void *userData ) 
{ 
  ENCODING *enc ;
  ENCODING *tmp ;

  {
#line 1645
  tmp = XmlInitUnknownEncoding(mem, table, convert, userData);
#line 1645
  enc = tmp;
#line 1646
  if (enc) {
#line 1647
    ((struct normal_encoding *)enc)->type[58] = (unsigned char)23;
  }
#line 1648
  return (enc);
}
}
#line 1 "xmlrole.o"
#pragma merger("0","./xmlrole.i","-std=gnu99,-g,-O0,-Wall,-Wmissing-prototypes,-Wstrict-prototypes,-fexceptions")
#line 33 "xmlrole.c"
static char const   KW_ANY[4]  = {      (char const   )65,      (char const   )78,      (char const   )89,      (char const   )'\000'};
#line 35 "xmlrole.c"
static char const   KW_ATTLIST[8]  = 
#line 35
  {      (char const   )65,      (char const   )84,      (char const   )84,      (char const   )76, 
        (char const   )73,      (char const   )83,      (char const   )84,      (char const   )'\000'};
#line 37 "xmlrole.c"
static char const   KW_CDATA[6]  = {      (char const   )67,      (char const   )68,      (char const   )65,      (char const   )84, 
        (char const   )65,      (char const   )'\000'};
#line 39 "xmlrole.c"
static char const   KW_DOCTYPE[8]  = 
#line 39
  {      (char const   )68,      (char const   )79,      (char const   )67,      (char const   )84, 
        (char const   )89,      (char const   )80,      (char const   )69,      (char const   )'\000'};
#line 41 "xmlrole.c"
static char const   KW_ELEMENT[8]  = 
#line 41
  {      (char const   )69,      (char const   )76,      (char const   )69,      (char const   )77, 
        (char const   )69,      (char const   )78,      (char const   )84,      (char const   )'\000'};
#line 43 "xmlrole.c"
static char const   KW_EMPTY[6]  = {      (char const   )69,      (char const   )77,      (char const   )80,      (char const   )84, 
        (char const   )89,      (char const   )'\000'};
#line 45 "xmlrole.c"
static char const   KW_ENTITIES[9]  = 
#line 45
  {      (char const   )69,      (char const   )78,      (char const   )84,      (char const   )73, 
        (char const   )84,      (char const   )73,      (char const   )69,      (char const   )83, 
        (char const   )'\000'};
#line 48 "xmlrole.c"
static char const   KW_ENTITY[7]  = {      (char const   )69,      (char const   )78,      (char const   )84,      (char const   )73, 
        (char const   )84,      (char const   )89,      (char const   )'\000'};
#line 50 "xmlrole.c"
static char const   KW_FIXED[6]  = {      (char const   )70,      (char const   )73,      (char const   )88,      (char const   )69, 
        (char const   )68,      (char const   )'\000'};
#line 52 "xmlrole.c"
static char const   KW_ID[3]  = {      (char const   )73,      (char const   )68,      (char const   )'\000'};
#line 54 "xmlrole.c"
static char const   KW_IDREF[6]  = {      (char const   )73,      (char const   )68,      (char const   )82,      (char const   )69, 
        (char const   )70,      (char const   )'\000'};
#line 56 "xmlrole.c"
static char const   KW_IDREFS[7]  = {      (char const   )73,      (char const   )68,      (char const   )82,      (char const   )69, 
        (char const   )70,      (char const   )83,      (char const   )'\000'};
#line 59 "xmlrole.c"
static char const   KW_IGNORE[7]  = {      (char const   )73,      (char const   )71,      (char const   )78,      (char const   )79, 
        (char const   )82,      (char const   )69,      (char const   )'\000'};
#line 62 "xmlrole.c"
static char const   KW_IMPLIED[8]  = 
#line 62
  {      (char const   )73,      (char const   )77,      (char const   )80,      (char const   )76, 
        (char const   )73,      (char const   )69,      (char const   )68,      (char const   )'\000'};
#line 65 "xmlrole.c"
static char const   KW_INCLUDE[8]  = 
#line 65
  {      (char const   )73,      (char const   )78,      (char const   )67,      (char const   )76, 
        (char const   )85,      (char const   )68,      (char const   )69,      (char const   )'\000'};
#line 68 "xmlrole.c"
static char const   KW_NDATA[6]  = {      (char const   )78,      (char const   )68,      (char const   )65,      (char const   )84, 
        (char const   )65,      (char const   )'\000'};
#line 70 "xmlrole.c"
static char const   KW_NMTOKEN[8]  = 
#line 70
  {      (char const   )78,      (char const   )77,      (char const   )84,      (char const   )79, 
        (char const   )75,      (char const   )69,      (char const   )78,      (char const   )'\000'};
#line 72 "xmlrole.c"
static char const   KW_NMTOKENS[9]  = 
#line 72
  {      (char const   )78,      (char const   )77,      (char const   )84,      (char const   )79, 
        (char const   )75,      (char const   )69,      (char const   )78,      (char const   )83, 
        (char const   )'\000'};
#line 75 "xmlrole.c"
static char const   KW_NOTATION[9]  = 
#line 75
  {      (char const   )78,      (char const   )79,      (char const   )84,      (char const   )65, 
        (char const   )84,      (char const   )73,      (char const   )79,      (char const   )78, 
        (char const   )'\000'};
#line 78 "xmlrole.c"
static char const   KW_PCDATA[7]  = {      (char const   )80,      (char const   )67,      (char const   )68,      (char const   )65, 
        (char const   )84,      (char const   )65,      (char const   )'\000'};
#line 80 "xmlrole.c"
static char const   KW_PUBLIC[7]  = {      (char const   )80,      (char const   )85,      (char const   )66,      (char const   )76, 
        (char const   )73,      (char const   )67,      (char const   )'\000'};
#line 82 "xmlrole.c"
static char const   KW_REQUIRED[9]  = 
#line 82
  {      (char const   )82,      (char const   )69,      (char const   )81,      (char const   )85, 
        (char const   )73,      (char const   )82,      (char const   )69,      (char const   )68, 
        (char const   )'\000'};
#line 85 "xmlrole.c"
static char const   KW_SYSTEM[7]  = {      (char const   )83,      (char const   )89,      (char const   )83,      (char const   )84, 
        (char const   )69,      (char const   )77,      (char const   )'\000'};
#line 107
static int prolog0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) ;
#line 107
static int prolog1(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) ;
#line 107
static int prolog2(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) ;
#line 107
static int doctype0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int doctype1(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int doctype2(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int doctype3(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int doctype4(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int doctype5(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int internalSubset(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                          ENCODING const   *enc ) ;
#line 107
static int entity0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) ;
#line 107
static int entity1(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) ;
#line 107
static int entity2(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) ;
#line 107
static int entity3(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) ;
#line 107
static int entity4(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) ;
#line 107
static int entity5(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) ;
#line 107
static int entity6(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) ;
#line 107
static int entity7(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) ;
#line 107
static int entity8(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) ;
#line 107
static int entity9(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) ;
#line 107
static int entity10(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int notation0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                     ENCODING const   *enc ) ;
#line 107
static int notation1(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                     ENCODING const   *enc ) ;
#line 107
static int notation2(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                     ENCODING const   *enc ) ;
#line 107
static int notation3(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                     ENCODING const   *enc ) ;
#line 107
static int notation4(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                     ENCODING const   *enc ) ;
#line 107
static int attlist0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int attlist1(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int attlist2(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int attlist3(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int attlist4(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int attlist5(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int attlist6(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int attlist7(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int attlist8(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int attlist9(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int element0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int element1(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int element2(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int element3(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int element4(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int element5(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int element6(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int element7(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int externalSubset0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                           ENCODING const   *enc ) ;
#line 107
static int externalSubset1(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                           ENCODING const   *enc ) ;
#line 107
static int condSect0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                     ENCODING const   *enc ) ;
#line 107
static int condSect1(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                     ENCODING const   *enc ) ;
#line 107
static int condSect2(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                     ENCODING const   *enc ) ;
#line 107
static int declClose(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                     ENCODING const   *enc ) ;
#line 107
static int error(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                 ENCODING const   *enc ) ;
#line 125
static int common(PROLOG_STATE *state , int tok ) ;
#line 127 "xmlrole.c"
static int prolog0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 134
  switch (tok) {
  case 15: 
#line 136
  state->handler = & prolog1;
#line 137
  return (0);
  case 12: 
#line 139
  state->handler = & prolog1;
#line 140
  return (1);
  case 11: 
#line 142
  state->handler = & prolog1;
#line 143
  return (55);
  case 13: 
#line 145
  state->handler = & prolog1;
#line 146
  return (56);
  case 14: 
#line 148
  return (0);
  case 16: 
#line 150
  tmp = (*(enc->nameMatchesAscii))(enc, ptr + 2 * (int )enc->minBytesPerChar, end,
                                   KW_DOCTYPE);
#line 150
  if (! tmp) {
#line 154
    break;
  }
#line 155
  state->handler = & doctype0;
#line 156
  return (3);
  case 29: 
#line 158
  state->handler = & error;
#line 159
  return (2);
  }
#line 161
  tmp___0 = common(state, tok);
#line 161
  return (tmp___0);
}
}
#line 164 "xmlrole.c"
static int prolog1(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 171
  switch (tok) {
  case 15: 
#line 173
  return (0);
  case 11: 
#line 175
  return (55);
  case 13: 
#line 177
  return (56);
  case 14: 
#line 179
  return (0);
  case 16: 
#line 181
  tmp = (*(enc->nameMatchesAscii))(enc, ptr + 2 * (int )enc->minBytesPerChar, end,
                                   KW_DOCTYPE);
#line 181
  if (! tmp) {
#line 185
    break;
  }
#line 186
  state->handler = & doctype0;
#line 187
  return (3);
  case 29: 
#line 189
  state->handler = & error;
#line 190
  return (2);
  }
#line 192
  tmp___0 = common(state, tok);
#line 192
  return (tmp___0);
}
}
#line 195 "xmlrole.c"
static int prolog2(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) 
{ 
  int tmp ;

  {
#line 202
  switch (tok) {
  case 15: 
#line 204
  return (0);
  case 11: 
#line 206
  return (55);
  case 13: 
#line 208
  return (56);
  case 29: 
#line 210
  state->handler = & error;
#line 211
  return (2);
  }
#line 213
  tmp = common(state, tok);
#line 213
  return (tmp);
}
}
#line 216 "xmlrole.c"
static int doctype0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;

  {
#line 223
  switch (tok) {
  case 15: 
#line 225
  return (3);
  case 41: 
  case 18: 
#line 228
  state->handler = & doctype1;
#line 229
  return (4);
  }
#line 231
  tmp = common(state, tok);
#line 231
  return (tmp);
}
}
#line 234 "xmlrole.c"
static int doctype1(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 241
  switch (tok) {
  case 15: 
#line 243
  return (3);
  case 25: 
#line 245
  state->handler = & internalSubset;
#line 246
  return (7);
  case 17: 
#line 248
  state->handler = & prolog2;
#line 249
  return (8);
  case 18: 
#line 251
  tmp = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_SYSTEM);
#line 251
  if (tmp) {
#line 252
    state->handler = & doctype3;
#line 253
    return (3);
  }
#line 255
  tmp___0 = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_PUBLIC);
#line 255
  if (tmp___0) {
#line 256
    state->handler = & doctype2;
#line 257
    return (3);
  }
#line 259
  break;
  }
#line 261
  tmp___1 = common(state, tok);
#line 261
  return (tmp___1);
}
}
#line 264 "xmlrole.c"
static int doctype2(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;

  {
#line 271
  switch (tok) {
  case 15: 
#line 273
  return (3);
  case 27: 
#line 275
  state->handler = & doctype3;
#line 276
  return (6);
  }
#line 278
  tmp = common(state, tok);
#line 278
  return (tmp);
}
}
#line 281 "xmlrole.c"
static int doctype3(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;

  {
#line 288
  switch (tok) {
  case 15: 
#line 290
  return (3);
  case 27: 
#line 292
  state->handler = & doctype4;
#line 293
  return (5);
  }
#line 295
  tmp = common(state, tok);
#line 295
  return (tmp);
}
}
#line 298 "xmlrole.c"
static int doctype4(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;

  {
#line 305
  switch (tok) {
  case 15: 
#line 307
  return (3);
  case 25: 
#line 309
  state->handler = & internalSubset;
#line 310
  return (7);
  case 17: 
#line 312
  state->handler = & prolog2;
#line 313
  return (8);
  }
#line 315
  tmp = common(state, tok);
#line 315
  return (tmp);
}
}
#line 318 "xmlrole.c"
static int doctype5(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;

  {
#line 325
  switch (tok) {
  case 15: 
#line 327
  return (3);
  case 17: 
#line 329
  state->handler = & prolog2;
#line 330
  return (8);
  }
#line 332
  tmp = common(state, tok);
#line 332
  return (tmp);
}
}
#line 335 "xmlrole.c"
static int internalSubset(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                          ENCODING const   *enc ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 342
  switch (tok) {
  case 15: 
#line 344
  return (0);
  case 16: 
#line 346
  tmp = (*(enc->nameMatchesAscii))(enc, ptr + 2 * (int )enc->minBytesPerChar, end,
                                   KW_ENTITY);
#line 346
  if (tmp) {
#line 350
    state->handler = & entity0;
#line 351
    return (11);
  }
#line 353
  tmp___0 = (*(enc->nameMatchesAscii))(enc, ptr + 2 * (int )enc->minBytesPerChar,
                                       end, KW_ATTLIST);
#line 353
  if (tmp___0) {
#line 357
    state->handler = & attlist0;
#line 358
    return (33);
  }
#line 360
  tmp___1 = (*(enc->nameMatchesAscii))(enc, ptr + 2 * (int )enc->minBytesPerChar,
                                       end, KW_ELEMENT);
#line 360
  if (tmp___1) {
#line 364
    state->handler = & element0;
#line 365
    return (39);
  }
#line 367
  tmp___2 = (*(enc->nameMatchesAscii))(enc, ptr + 2 * (int )enc->minBytesPerChar,
                                       end, KW_NOTATION);
#line 367
  if (tmp___2) {
#line 371
    state->handler = & notation0;
#line 372
    return (17);
  }
#line 374
  break;
  case 11: 
#line 376
  return (55);
  case 13: 
#line 378
  return (56);
  case 28: 
#line 380
  return (60);
  case 26: 
#line 382
  state->handler = & doctype5;
#line 383
  return (3);
  case -4: 
#line 385
  return (0);
  }
#line 387
  tmp___3 = common(state, tok);
#line 387
  return (tmp___3);
}
}
#line 392 "xmlrole.c"
static int externalSubset0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                           ENCODING const   *enc ) 
{ 
  int tmp ;

  {
#line 399
  state->handler = & externalSubset1;
#line 400
  if (tok == 12) {
#line 401
    return (57);
  }
#line 402
  tmp = externalSubset1(state, tok, ptr, end, enc);
#line 402
  return (tmp);
}
}
#line 405 "xmlrole.c"
static int externalSubset1(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                           ENCODING const   *enc ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 412
  switch (tok) {
  case 33: 
#line 414
  state->handler = & condSect0;
#line 415
  return (0);
  case 34: 
#line 417
  if (state->includeLevel == 0U) {
#line 418
    break;
  }
#line 419
  (state->includeLevel) --;
#line 420
  return (0);
  case 15: 
#line 422
  return (0);
  case 26: 
#line 424
  break;
  case -4: 
#line 426
  if (state->includeLevel) {
#line 427
    break;
  }
#line 428
  return (0);
  default: 
#line 430
  tmp = internalSubset(state, tok, ptr, end, enc);
#line 430
  return (tmp);
  }
#line 432
  tmp___0 = common(state, tok);
#line 432
  return (tmp___0);
}
}
#line 437 "xmlrole.c"
static int entity0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) 
{ 
  int tmp ;

  {
#line 444
  switch (tok) {
  case 15: 
#line 446
  return (11);
  case 22: 
#line 448
  state->handler = & entity1;
#line 449
  return (11);
  case 18: 
#line 451
  state->handler = & entity2;
#line 452
  return (9);
  }
#line 454
  tmp = common(state, tok);
#line 454
  return (tmp);
}
}
#line 457 "xmlrole.c"
static int entity1(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) 
{ 
  int tmp ;

  {
#line 464
  switch (tok) {
  case 15: 
#line 466
  return (11);
  case 18: 
#line 468
  state->handler = & entity7;
#line 469
  return (10);
  }
#line 471
  tmp = common(state, tok);
#line 471
  return (tmp);
}
}
#line 474 "xmlrole.c"
static int entity2(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 481
  switch (tok) {
  case 15: 
#line 483
  return (11);
  case 18: 
#line 485
  tmp = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_SYSTEM);
#line 485
  if (tmp) {
#line 486
    state->handler = & entity4;
#line 487
    return (11);
  }
#line 489
  tmp___0 = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_PUBLIC);
#line 489
  if (tmp___0) {
#line 490
    state->handler = & entity3;
#line 491
    return (11);
  }
#line 493
  break;
  case 27: 
#line 495
  state->handler = & declClose;
#line 496
  state->role_none = 11;
#line 497
  return (12);
  }
#line 499
  tmp___1 = common(state, tok);
#line 499
  return (tmp___1);
}
}
#line 502 "xmlrole.c"
static int entity3(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) 
{ 
  int tmp ;

  {
#line 509
  switch (tok) {
  case 15: 
#line 511
  return (11);
  case 27: 
#line 513
  state->handler = & entity4;
#line 514
  return (14);
  }
#line 516
  tmp = common(state, tok);
#line 516
  return (tmp);
}
}
#line 519 "xmlrole.c"
static int entity4(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) 
{ 
  int tmp ;

  {
#line 526
  switch (tok) {
  case 15: 
#line 528
  return (11);
  case 27: 
#line 530
  state->handler = & entity5;
#line 531
  return (13);
  }
#line 533
  tmp = common(state, tok);
#line 533
  return (tmp);
}
}
#line 536 "xmlrole.c"
static int entity5(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 543
  switch (tok) {
  case 15: 
#line 545
  return (11);
  case 17: 
#line 547
  if (state->documentEntity) {
#line 547
    state->handler = & internalSubset;
  } else {
#line 547
    state->handler = & externalSubset1;
  }
#line 548
  return (15);
  case 18: 
#line 550
  tmp = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_NDATA);
#line 550
  if (tmp) {
#line 551
    state->handler = & entity6;
#line 552
    return (11);
  }
#line 554
  break;
  }
#line 556
  tmp___0 = common(state, tok);
#line 556
  return (tmp___0);
}
}
#line 559 "xmlrole.c"
static int entity6(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) 
{ 
  int tmp ;

  {
#line 566
  switch (tok) {
  case 15: 
#line 568
  return (11);
  case 18: 
#line 570
  state->handler = & declClose;
#line 571
  state->role_none = 11;
#line 572
  return (16);
  }
#line 574
  tmp = common(state, tok);
#line 574
  return (tmp);
}
}
#line 577 "xmlrole.c"
static int entity7(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 584
  switch (tok) {
  case 15: 
#line 586
  return (11);
  case 18: 
#line 588
  tmp = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_SYSTEM);
#line 588
  if (tmp) {
#line 589
    state->handler = & entity9;
#line 590
    return (11);
  }
#line 592
  tmp___0 = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_PUBLIC);
#line 592
  if (tmp___0) {
#line 593
    state->handler = & entity8;
#line 594
    return (11);
  }
#line 596
  break;
  case 27: 
#line 598
  state->handler = & declClose;
#line 599
  state->role_none = 11;
#line 600
  return (12);
  }
#line 602
  tmp___1 = common(state, tok);
#line 602
  return (tmp___1);
}
}
#line 605 "xmlrole.c"
static int entity8(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) 
{ 
  int tmp ;

  {
#line 612
  switch (tok) {
  case 15: 
#line 614
  return (11);
  case 27: 
#line 616
  state->handler = & entity9;
#line 617
  return (14);
  }
#line 619
  tmp = common(state, tok);
#line 619
  return (tmp);
}
}
#line 622 "xmlrole.c"
static int entity9(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) 
{ 
  int tmp ;

  {
#line 629
  switch (tok) {
  case 15: 
#line 631
  return (11);
  case 27: 
#line 633
  state->handler = & entity10;
#line 634
  return (13);
  }
#line 636
  tmp = common(state, tok);
#line 636
  return (tmp);
}
}
#line 639 "xmlrole.c"
static int entity10(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;

  {
#line 646
  switch (tok) {
  case 15: 
#line 648
  return (11);
  case 17: 
#line 650
  if (state->documentEntity) {
#line 650
    state->handler = & internalSubset;
  } else {
#line 650
    state->handler = & externalSubset1;
  }
#line 651
  return (15);
  }
#line 653
  tmp = common(state, tok);
#line 653
  return (tmp);
}
}
#line 656 "xmlrole.c"
static int notation0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                     ENCODING const   *enc ) 
{ 
  int tmp ;

  {
#line 663
  switch (tok) {
  case 15: 
#line 665
  return (17);
  case 18: 
#line 667
  state->handler = & notation1;
#line 668
  return (18);
  }
#line 670
  tmp = common(state, tok);
#line 670
  return (tmp);
}
}
#line 673 "xmlrole.c"
static int notation1(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                     ENCODING const   *enc ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 680
  switch (tok) {
  case 15: 
#line 682
  return (17);
  case 18: 
#line 684
  tmp = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_SYSTEM);
#line 684
  if (tmp) {
#line 685
    state->handler = & notation3;
#line 686
    return (17);
  }
#line 688
  tmp___0 = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_PUBLIC);
#line 688
  if (tmp___0) {
#line 689
    state->handler = & notation2;
#line 690
    return (17);
  }
#line 692
  break;
  }
#line 694
  tmp___1 = common(state, tok);
#line 694
  return (tmp___1);
}
}
#line 697 "xmlrole.c"
static int notation2(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                     ENCODING const   *enc ) 
{ 
  int tmp ;

  {
#line 704
  switch (tok) {
  case 15: 
#line 706
  return (17);
  case 27: 
#line 708
  state->handler = & notation4;
#line 709
  return (21);
  }
#line 711
  tmp = common(state, tok);
#line 711
  return (tmp);
}
}
#line 714 "xmlrole.c"
static int notation3(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                     ENCODING const   *enc ) 
{ 
  int tmp ;

  {
#line 721
  switch (tok) {
  case 15: 
#line 723
  return (17);
  case 27: 
#line 725
  state->handler = & declClose;
#line 726
  state->role_none = 17;
#line 727
  return (19);
  }
#line 729
  tmp = common(state, tok);
#line 729
  return (tmp);
}
}
#line 732 "xmlrole.c"
static int notation4(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                     ENCODING const   *enc ) 
{ 
  int tmp ;

  {
#line 739
  switch (tok) {
  case 15: 
#line 741
  return (17);
  case 27: 
#line 743
  state->handler = & declClose;
#line 744
  state->role_none = 17;
#line 745
  return (19);
  case 17: 
#line 747
  if (state->documentEntity) {
#line 747
    state->handler = & internalSubset;
  } else {
#line 747
    state->handler = & externalSubset1;
  }
#line 748
  return (20);
  }
#line 750
  tmp = common(state, tok);
#line 750
  return (tmp);
}
}
#line 753 "xmlrole.c"
static int attlist0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;

  {
#line 760
  switch (tok) {
  case 15: 
#line 762
  return (33);
  case 41: 
  case 18: 
#line 765
  state->handler = & attlist1;
#line 766
  return (34);
  }
#line 768
  tmp = common(state, tok);
#line 768
  return (tmp);
}
}
#line 771 "xmlrole.c"
static int attlist1(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;

  {
#line 778
  switch (tok) {
  case 15: 
#line 780
  return (33);
  case 17: 
#line 782
  if (state->documentEntity) {
#line 782
    state->handler = & internalSubset;
  } else {
#line 782
    state->handler = & externalSubset1;
  }
#line 783
  return (33);
  case 41: 
  case 18: 
#line 786
  state->handler = & attlist2;
#line 787
  return (22);
  }
#line 789
  tmp = common(state, tok);
#line 789
  return (tmp);
}
}
#line 804 "xmlrole.c"
static char const   * const  types[8]  = 
#line 804
  {      (char const   * const  )(KW_CDATA),      (char const   * const  )(KW_ID),      (char const   * const  )(KW_IDREF),      (char const   * const  )(KW_IDREFS), 
        (char const   * const  )(KW_ENTITY),      (char const   * const  )(KW_ENTITIES),      (char const   * const  )(KW_NMTOKEN),      (char const   * const  )(KW_NMTOKENS)};
#line 792 "xmlrole.c"
static int attlist2(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 799
  switch (tok) {
  case 15: 
#line 801
  return (33);
  case 18: 
#line 815
  i = 0;
#line 815
  while (i < (int )(sizeof(types) / sizeof(types[0]))) {
#line 816
    tmp = (*(enc->nameMatchesAscii))(enc, ptr, end, (char const   *)types[i]);
#line 816
    if (tmp) {
#line 817
      state->handler = & attlist8;
#line 818
      return (23 + i);
    }
#line 815
    i ++;
  }
#line 821
  tmp___0 = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_NOTATION);
#line 821
  if (tmp___0) {
#line 822
    state->handler = & attlist5;
#line 823
    return (33);
  }
#line 825
  break;
  case 23: 
#line 827
  state->handler = & attlist3;
#line 828
  return (33);
  }
#line 830
  tmp___1 = common(state, tok);
#line 830
  return (tmp___1);
}
}
#line 833 "xmlrole.c"
static int attlist3(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;

  {
#line 840
  switch (tok) {
  case 15: 
#line 842
  return (33);
  case 41: 
  case 18: 
  case 19: 
#line 846
  state->handler = & attlist4;
#line 847
  return (31);
  }
#line 849
  tmp = common(state, tok);
#line 849
  return (tmp);
}
}
#line 852 "xmlrole.c"
static int attlist4(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;

  {
#line 859
  switch (tok) {
  case 15: 
#line 861
  return (33);
  case 24: 
#line 863
  state->handler = & attlist8;
#line 864
  return (33);
  case 21: 
#line 866
  state->handler = & attlist3;
#line 867
  return (33);
  }
#line 869
  tmp = common(state, tok);
#line 869
  return (tmp);
}
}
#line 872 "xmlrole.c"
static int attlist5(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;

  {
#line 879
  switch (tok) {
  case 15: 
#line 881
  return (33);
  case 23: 
#line 883
  state->handler = & attlist6;
#line 884
  return (33);
  }
#line 886
  tmp = common(state, tok);
#line 886
  return (tmp);
}
}
#line 889 "xmlrole.c"
static int attlist6(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;

  {
#line 896
  switch (tok) {
  case 15: 
#line 898
  return (33);
  case 18: 
#line 900
  state->handler = & attlist7;
#line 901
  return (32);
  }
#line 903
  tmp = common(state, tok);
#line 903
  return (tmp);
}
}
#line 906 "xmlrole.c"
static int attlist7(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;

  {
#line 913
  switch (tok) {
  case 15: 
#line 915
  return (33);
  case 24: 
#line 917
  state->handler = & attlist8;
#line 918
  return (33);
  case 21: 
#line 920
  state->handler = & attlist6;
#line 921
  return (33);
  }
#line 923
  tmp = common(state, tok);
#line 923
  return (tmp);
}
}
#line 927 "xmlrole.c"
static int attlist8(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 934
  switch (tok) {
  case 15: 
#line 936
  return (33);
  case 20: 
#line 938
  tmp = (*(enc->nameMatchesAscii))(enc, ptr + enc->minBytesPerChar, end, KW_IMPLIED);
#line 938
  if (tmp) {
#line 942
    state->handler = & attlist1;
#line 943
    return (35);
  }
#line 945
  tmp___0 = (*(enc->nameMatchesAscii))(enc, ptr + enc->minBytesPerChar, end, KW_REQUIRED);
#line 945
  if (tmp___0) {
#line 949
    state->handler = & attlist1;
#line 950
    return (36);
  }
#line 952
  tmp___1 = (*(enc->nameMatchesAscii))(enc, ptr + enc->minBytesPerChar, end, KW_FIXED);
#line 952
  if (tmp___1) {
#line 956
    state->handler = & attlist9;
#line 957
    return (33);
  }
#line 959
  break;
  case 27: 
#line 961
  state->handler = & attlist1;
#line 962
  return (37);
  }
#line 964
  tmp___2 = common(state, tok);
#line 964
  return (tmp___2);
}
}
#line 967 "xmlrole.c"
static int attlist9(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;

  {
#line 974
  switch (tok) {
  case 15: 
#line 976
  return (33);
  case 27: 
#line 978
  state->handler = & attlist1;
#line 979
  return (38);
  }
#line 981
  tmp = common(state, tok);
#line 981
  return (tmp);
}
}
#line 984 "xmlrole.c"
static int element0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;

  {
#line 991
  switch (tok) {
  case 15: 
#line 993
  return (39);
  case 41: 
  case 18: 
#line 996
  state->handler = & element1;
#line 997
  return (40);
  }
#line 999
  tmp = common(state, tok);
#line 999
  return (tmp);
}
}
#line 1002 "xmlrole.c"
static int element1(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1009
  switch (tok) {
  case 15: 
#line 1011
  return (39);
  case 18: 
#line 1013
  tmp = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_EMPTY);
#line 1013
  if (tmp) {
#line 1014
    state->handler = & declClose;
#line 1015
    state->role_none = 39;
#line 1016
    return (42);
  }
#line 1018
  tmp___0 = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_ANY);
#line 1018
  if (tmp___0) {
#line 1019
    state->handler = & declClose;
#line 1020
    state->role_none = 39;
#line 1021
    return (41);
  }
#line 1023
  break;
  case 23: 
#line 1025
  state->handler = & element2;
#line 1026
  state->level = 1U;
#line 1027
  return (44);
  }
#line 1029
  tmp___1 = common(state, tok);
#line 1029
  return (tmp___1);
}
}
#line 1032 "xmlrole.c"
static int element2(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1039
  switch (tok) {
  case 15: 
#line 1041
  return (39);
  case 20: 
#line 1043
  tmp = (*(enc->nameMatchesAscii))(enc, ptr + enc->minBytesPerChar, end, KW_PCDATA);
#line 1043
  if (tmp) {
#line 1047
    state->handler = & element3;
#line 1048
    return (43);
  }
#line 1050
  break;
  case 23: 
#line 1052
  state->level = 2U;
#line 1053
  state->handler = & element6;
#line 1054
  return (44);
  case 41: 
  case 18: 
#line 1057
  state->handler = & element7;
#line 1058
  return (51);
  case 30: 
#line 1060
  state->handler = & element7;
#line 1061
  return (53);
  case 31: 
#line 1063
  state->handler = & element7;
#line 1064
  return (52);
  case 32: 
#line 1066
  state->handler = & element7;
#line 1067
  return (54);
  }
#line 1069
  tmp___0 = common(state, tok);
#line 1069
  return (tmp___0);
}
}
#line 1072 "xmlrole.c"
static int element3(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;

  {
#line 1079
  switch (tok) {
  case 15: 
#line 1081
  return (39);
  case 24: 
#line 1083
  state->handler = & declClose;
#line 1084
  state->role_none = 39;
#line 1085
  return (45);
  case 36: 
#line 1087
  state->handler = & declClose;
#line 1088
  state->role_none = 39;
#line 1089
  return (46);
  case 21: 
#line 1091
  state->handler = & element4;
#line 1092
  return (39);
  }
#line 1094
  tmp = common(state, tok);
#line 1094
  return (tmp);
}
}
#line 1097 "xmlrole.c"
static int element4(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;

  {
#line 1104
  switch (tok) {
  case 15: 
#line 1106
  return (39);
  case 41: 
  case 18: 
#line 1109
  state->handler = & element5;
#line 1110
  return (51);
  }
#line 1112
  tmp = common(state, tok);
#line 1112
  return (tmp);
}
}
#line 1115 "xmlrole.c"
static int element5(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;

  {
#line 1122
  switch (tok) {
  case 15: 
#line 1124
  return (39);
  case 36: 
#line 1126
  state->handler = & declClose;
#line 1127
  state->role_none = 39;
#line 1128
  return (46);
  case 21: 
#line 1130
  state->handler = & element4;
#line 1131
  return (39);
  }
#line 1133
  tmp = common(state, tok);
#line 1133
  return (tmp);
}
}
#line 1136 "xmlrole.c"
static int element6(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;

  {
#line 1143
  switch (tok) {
  case 15: 
#line 1145
  return (39);
  case 23: 
#line 1147
  (state->level) ++;
#line 1148
  return (44);
  case 41: 
  case 18: 
#line 1151
  state->handler = & element7;
#line 1152
  return (51);
  case 30: 
#line 1154
  state->handler = & element7;
#line 1155
  return (53);
  case 31: 
#line 1157
  state->handler = & element7;
#line 1158
  return (52);
  case 32: 
#line 1160
  state->handler = & element7;
#line 1161
  return (54);
  }
#line 1163
  tmp = common(state, tok);
#line 1163
  return (tmp);
}
}
#line 1166 "xmlrole.c"
static int element7(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;

  {
#line 1173
  switch (tok) {
  case 15: 
#line 1175
  return (39);
  case 24: 
#line 1177
  (state->level) --;
#line 1178
  if (state->level == 0U) {
#line 1179
    state->handler = & declClose;
#line 1180
    state->role_none = 39;
  }
#line 1182
  return (45);
  case 36: 
#line 1184
  (state->level) --;
#line 1185
  if (state->level == 0U) {
#line 1186
    state->handler = & declClose;
#line 1187
    state->role_none = 39;
  }
#line 1189
  return (46);
  case 35: 
#line 1191
  (state->level) --;
#line 1192
  if (state->level == 0U) {
#line 1193
    state->handler = & declClose;
#line 1194
    state->role_none = 39;
  }
#line 1196
  return (47);
  case 37: 
#line 1198
  (state->level) --;
#line 1199
  if (state->level == 0U) {
#line 1200
    state->handler = & declClose;
#line 1201
    state->role_none = 39;
  }
#line 1203
  return (48);
  case 38: 
#line 1205
  state->handler = & element6;
#line 1206
  return (50);
  case 21: 
#line 1208
  state->handler = & element6;
#line 1209
  return (49);
  }
#line 1211
  tmp = common(state, tok);
#line 1211
  return (tmp);
}
}
#line 1216 "xmlrole.c"
static int condSect0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                     ENCODING const   *enc ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1223
  switch (tok) {
  case 15: 
#line 1225
  return (0);
  case 18: 
#line 1227
  tmp = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_INCLUDE);
#line 1227
  if (tmp) {
#line 1228
    state->handler = & condSect1;
#line 1229
    return (0);
  }
#line 1231
  tmp___0 = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_IGNORE);
#line 1231
  if (tmp___0) {
#line 1232
    state->handler = & condSect2;
#line 1233
    return (0);
  }
#line 1235
  break;
  }
#line 1237
  tmp___1 = common(state, tok);
#line 1237
  return (tmp___1);
}
}
#line 1240 "xmlrole.c"
static int condSect1(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                     ENCODING const   *enc ) 
{ 
  int tmp ;

  {
#line 1247
  switch (tok) {
  case 15: 
#line 1249
  return (0);
  case 25: 
#line 1251
  state->handler = & externalSubset1;
#line 1252
  (state->includeLevel) ++;
#line 1253
  return (0);
  }
#line 1255
  tmp = common(state, tok);
#line 1255
  return (tmp);
}
}
#line 1258 "xmlrole.c"
static int condSect2(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                     ENCODING const   *enc ) 
{ 
  int tmp ;

  {
#line 1265
  switch (tok) {
  case 15: 
#line 1267
  return (0);
  case 25: 
#line 1269
  state->handler = & externalSubset1;
#line 1270
  return (58);
  }
#line 1272
  tmp = common(state, tok);
#line 1272
  return (tmp);
}
}
#line 1277 "xmlrole.c"
static int declClose(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                     ENCODING const   *enc ) 
{ 
  int tmp ;

  {
#line 1284
  switch (tok) {
  case 15: 
#line 1286
  return (state->role_none);
  case 17: 
#line 1288
  if (state->documentEntity) {
#line 1288
    state->handler = & internalSubset;
  } else {
#line 1288
    state->handler = & externalSubset1;
  }
#line 1289
  return (state->role_none);
  }
#line 1291
  tmp = common(state, tok);
#line 1291
  return (tmp);
}
}
#line 1294 "xmlrole.c"
static int error(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                 ENCODING const   *enc ) 
{ 


  {
#line 1301
  return (0);
}
}
#line 1304 "xmlrole.c"
static int common(PROLOG_STATE *state , int tok ) 
{ 


  {
#line 1308
  if (! state->documentEntity) {
#line 1308
    if (tok == 28) {
#line 1309
      return (59);
    }
  }
#line 1311
  state->handler = & error;
#line 1312
  return (-1);
}
}
#line 1315 "xmlrole.c"
void XmlPrologStateInit(PROLOG_STATE *state ) 
{ 


  {
#line 1318
  state->handler = & prolog0;
#line 1320
  state->documentEntity = 1;
#line 1321
  state->includeLevel = 0U;
#line 1322
  state->inEntityValue = 0;
#line 1324
  return;
}
}
#line 1328 "xmlrole.c"
void XmlPrologStateInitExternalEntity(PROLOG_STATE *state ) 
{ 


  {
#line 1331
  state->handler = & externalSubset0;
#line 1332
  state->documentEntity = 0;
#line 1333
  state->includeLevel = 0U;
#line 1334
  return;
}
}
#line 1 "elements.o"
#pragma merger("0","./elements.i","-std=gnu99,-g,-O0,-Wall,-Wmissing-prototypes,-Wstrict-prototypes,-fexceptions")
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 580
extern int putchar(int __c ) ;
#line 695
extern int puts(char const   *__s ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 27 "elements.c"
int SYMINPUT_SIZE  ;
#line 29 "elements.c"
void *sym_memcpy(void *dst , void const   *src , size_t len ) 
{ 
  size_t i ;
  char *d ;
  char const   *s ;

  {
#line 33
  d = (char *)dst;
#line 34
  s = (char const   *)src;
#line 36
  i = (size_t )0;
#line 36
  while (i < len) {
#line 37
    *(d + i) = (char )*(s + i);
#line 36
    i ++;
  }
#line 40
  return (dst);
}
}
#line 43
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *Ptr1 ,
                                                                                        void const   *Ptr2 ,
                                                                                        size_t Count )  __attribute__((__pure__)) ;
#line 43 "elements.c"
int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *Ptr1 , void const   *Ptr2 ,
                                                          size_t Count ) 
{ 
  int v ;
  char *p1 ;
  char *p2 ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;

  {
#line 46
  v = 0;
#line 47
  p1 = (char *)Ptr1;
#line 48
  p2 = (char *)Ptr2;
#line 50
  while (1) {
#line 50
    tmp___1 = Count;
#line 50
    Count --;
#line 50
    if (tmp___1 > 0UL) {
#line 50
      if (! (v == 0)) {
#line 50
        break;
      }
    } else {
#line 50
      break;
    }
#line 51
    tmp = p1;
#line 51
    p1 ++;
#line 51
    tmp___0 = p2;
#line 51
    p2 ++;
#line 51
    v = (int )*tmp - (int )*tmp___0;
  }
#line 54
  return (v);
}
}
#line 58 "elements.c"
static void startElement(void *userData , char const   *name , char const   **atts ) 
{ 
  int i ;
  int *depthPtr ;

  {
#line 62
  depthPtr = (int *)userData;
#line 63
  i = 0;
#line 63
  while (i < *depthPtr) {
#line 64
    putchar('\t');
#line 63
    i ++;
  }
#line 65
  puts(name);
#line 66
  (*depthPtr) ++;
#line 67
  return;
}
}
#line 69 "elements.c"
static void endElement(void *userData , char const   *name ) 
{ 
  int *depthPtr ;

  {
#line 72
  depthPtr = (int *)userData;
#line 73
  (*depthPtr) --;
#line 74
  return;
}
}
#line 76 "elements.c"
static void myDataHandler(void *userData , XML_Char const   *s , int len ) 
{ 


  {
#line 79
  return;
}
}
#line 82 "elements.c"
static void myCommentHandler(void *userData , XML_Char const   *s ) 
{ 


  {
#line 85
  return;
}
}
#line 88 "elements.c"
static void myDefaultHandler(void *userdata , XML_Char const   *s , int len ) 
{ 


  {
#line 91
  return;
}
}
#line 94 "elements.c"
int myUnknownEncodingHandler(void *a , XML_Char const   *b , XML_Encoding *info ) 
{ 


  {
#line 97
  return (0);
}
}
#line 100 "elements.c"
static void myVoidHandler(void *userdata ) 
{ 


  {
#line 103
  return;
}
}
#line 106 "elements.c"
static void myNamespaceDeclHandler(void *userData , XML_Char const   *prefix , XML_Char const   *uri ) 
{ 


  {
#line 110
  return;
}
}
#line 113 "elements.c"
static void myUnparsedEntityDeclHandler(void *userData , XML_Char const   *entityName ,
                                        XML_Char const   *base , XML_Char const   *systemId ,
                                        XML_Char const   *publicId , XML_Char const   *notationName ) 
{ 


  {
#line 120
  return;
}
}
#line 123 "elements.c"
static void myProcessingInstruction(void *userData , XML_Char const   *target , XML_Char const   *data ) 
{ 


  {
#line 127
  return;
}
}
#line 130 "elements.c"
int main(int argc , char **argv ) 
{ 
  char *buf ;
  char a ;
  XML_Parser parser ;
  XML_Parser tmp ;
  int depth ;
  void *tmp___0 ;
  enum XML_Status tmp___1 ;

  {
#line 134
  a = (char )'A';
#line 135
  tmp = XML_ParserCreateNS("UTF-8", (XML_Char )":");
#line 135
  parser = tmp;
#line 137
  depth = 0;
#line 138
  XML_SetUserData(parser, (void *)(& depth));
#line 139
  XML_SetElementHandler(parser, & startElement, & endElement);
#line 140
  XML_SetCharacterDataHandler(parser, & myDataHandler);
#line 141
  XML_SetCommentHandler(parser, & myCommentHandler);
#line 142
  XML_SetDefaultHandler(parser, & myDefaultHandler);
#line 143
  XML_SetUnknownEncodingHandler(parser, & myUnknownEncodingHandler, (void *)(& a));
#line 144
  XML_SetCdataSectionHandler(parser, & myVoidHandler, & myVoidHandler);
#line 145
  XML_SetParamEntityParsing(parser, (enum XML_ParamEntityParsing )2);
#line 146
  XML_GetSpecifiedAttributeCount(parser);
#line 147
  XML_SetNamespaceDeclHandler(parser, & myNamespaceDeclHandler, (void (*)(void *userData ,
                                                                          XML_Char const   *prefix ))(& myNamespaceDeclHandler));
#line 148
  XML_SetUnparsedEntityDeclHandler(parser, & myUnparsedEntityDeclHandler);
#line 149
  XML_SetProcessingInstructionHandler(parser, & myProcessingInstruction);
#line 151
  SYMINPUT_SIZE = atoi((char const   *)*(argv + 2));
#line 152
  tmp___0 = malloc((size_t )SYMINPUT_SIZE);
#line 152
  buf = (char *)tmp___0;
#line 154
  tmp___1 = XML_Parse(parser, (char const   *)buf, SYMINPUT_SIZE, 1);
#line 154
  if ((unsigned int )tmp___1 == 0U) {
#line 155
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"PARSE ERROR:%s\n",
            buf);
#line 162
    return (1);
  }
#line 164
  XML_ParserFree(parser);
#line 165
  return (0);
}
}
